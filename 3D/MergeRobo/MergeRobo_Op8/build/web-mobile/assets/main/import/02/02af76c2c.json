[1,["faHvrLiwRMO6zVZYs7TpY6","9dTNv/2rpNRrjg8BmGBts9@953b3","1brw/JvvpFnIvdrxpFCgMZ","12Y9dMgWdJKJGmTiZyQR9H@fc873","a8N8sJtcpByruvqEfCcdFU","eeW9BrPKNEyKtUT7DtIl6J@1996b","7dj5uJT9FMn6OrOOx83tfK@f9941","e9KGWKiD1OmJ9yPv2EAcxX@a58ca","5519gNyINEjLsdujo0tbT+","eeRheGDp5C+Y/Kp+cBKMpM@1f586","c6025CLuxPPJrYF8nbEdL7@6c48a","d1NGQ2rJZCcbhjH0/erZWw","1aDnxnbOZKu7GZJlErgYNt","4dCcgUmKlKlYfayMieDe8D@eb908","4dCcgUmKlKlYfayMieDe8D@30732","4dCcgUmKlKlYfayMieDe8D@793db","4dCcgUmKlKlYfayMieDe8D@f1394","4dCcgUmKlKlYfayMieDe8D@504e2","4dCcgUmKlKlYfayMieDe8D@75ee4","4dCcgUmKlKlYfayMieDe8D@fed22","4dCcgUmKlKlYfayMieDe8D@a72ab","4dCcgUmKlKlYfayMieDe8D@a3f07","4dCcgUmKlKlYfayMieDe8D@2224c","4dCcgUmKlKlYfayMieDe8D@405eb","4dCcgUmKlKlYfayMieDe8D@62756","8801i9sZVC7YgvtgkJf+P6","30JhWFgrtOhp93jo3uf7RF","9dTNv/2rpNRrjg8BmGBts9@9fd92","9dTNv/2rpNRrjg8BmGBts9@30732","9dTNv/2rpNRrjg8BmGBts9@b22e3","9dTNv/2rpNRrjg8BmGBts9@f1394","9dTNv/2rpNRrjg8BmGBts9@8dd90","9dTNv/2rpNRrjg8BmGBts9@75ee4","9dTNv/2rpNRrjg8BmGBts9@999bc","9dTNv/2rpNRrjg8BmGBts9@a72ab","9dTNv/2rpNRrjg8BmGBts9@6d452","9dTNv/2rpNRrjg8BmGBts9@2224c","9dTNv/2rpNRrjg8BmGBts9@9c565","9dTNv/2rpNRrjg8BmGBts9@62756","9dTNv/2rpNRrjg8BmGBts9@65061","9dTNv/2rpNRrjg8BmGBts9@7d08b","9dTNv/2rpNRrjg8BmGBts9@2796d","9dTNv/2rpNRrjg8BmGBts9@b5902","bc67+sUb9Gn7QOUccqExpZ@99d6c","24pF+vWxhBh5k3n5hTEOVT@6c48a","fbXY8s6StHypsrlG0j58W0@6c48a","3foayWK8pAXofxFm3igdB7@6c48a","7cYjEr+ABBaI4SradIq8jN","3fu5wPHRVPc75Lq3ZjnEeE","bbvdCDv55PyJivjZ3HxKbt","4ch5id+2pNBY0XDn29q6s8","9fc4fZYs9G7Jx1RuScFb6+@37358","40KtS7a1VPdKJCMBkId6DA","509AO8N9dCY4JC2+SZLyqN@6c48a","10kauf/hdBtraIPFDDYozC@6c48a","18XqHpKn9BR7xbVFnFEZ9Y@6c48a","14keyxtUlE5qRHRf1ntswB","6egFMUFrBAA7eTC8YQVPlU@6c48a","9398BhvRBG45iTd0Q+8ZkT@6c48a","05/AjxB6FOzoKYwl4Rjf9E@6c48a","64ui3C+HVP2qDvc1h/yUvR@6c48a","7dj5uJT9FMn6OrOOx83tfK@6c48a","40UfVBkRBDbJbQKs2Dr/eB","17f+mB9ctBOKHHfi2ASpgU","49r686cztLgYffy3zfFErP@78249","8aUa/RdFRFYJu9VMNQ6MQe@6c48a","afHwiiuh5Ctb7Sj3EO3iDM@6c48a","9dTNv/2rpNRrjg8BmGBts9@6c3a1","a8cLPnlwNARonQrXZMim+j@6c48a","cf3h69QOZFnK5v7t/NlO4w@6c48a","18XqHpKn9BR7xbVFnFEZ9Y@f9941","56V372P5JJ35w5bdwELy6c","cf3h69QOZFnK5v7t/NlO4w@f9941","10kauf/hdBtraIPFDDYozC@f9941","8aUa/RdFRFYJu9VMNQ6MQe@f9941","a8cLPnlwNARonQrXZMim+j@f9941","841489+zFNhoQYM8muwfPd","f09ppTaQdAxp1Kfl+cOjrf","078CoEXBBCVruc3p9EqMu2","deIBAT5zxG/KGW2ojgDH9c@b4251","21wrcxYrlJJ6IscFzd2F0N@7f3dc","1eOHNMDNFFcqIc3VPOHmBW@3566d","1eOHNMDNFFcqIc3VPOHmBW@30732","1eOHNMDNFFcqIc3VPOHmBW@5fd49","1eOHNMDNFFcqIc3VPOHmBW@f1394","1eOHNMDNFFcqIc3VPOHmBW@398a7","1eOHNMDNFFcqIc3VPOHmBW@75ee4","1eOHNMDNFFcqIc3VPOHmBW@0f0b7","1eOHNMDNFFcqIc3VPOHmBW@a72ab","1eOHNMDNFFcqIc3VPOHmBW@55a28","1eOHNMDNFFcqIc3VPOHmBW@2224c","1eOHNMDNFFcqIc3VPOHmBW@03d47","1eOHNMDNFFcqIc3VPOHmBW@62756","1eOHNMDNFFcqIc3VPOHmBW@79a0e","1eOHNMDNFFcqIc3VPOHmBW@7d08b","95kt3MOoxBJqWFyzatX5tm","d7B8zTVDZGBIeDya74wfhV@b7bbc","35AWkPrIZE77OxQ6HwHWjh","bc67+sUb9Gn7QOUccqExpZ@6ec10","bc67+sUb9Gn7QOUccqExpZ@3620d","bc67+sUb9Gn7QOUccqExpZ@29372","bc67+sUb9Gn7QOUccqExpZ@cbffa","bc67+sUb9Gn7QOUccqExpZ@ed581","bc67+sUb9Gn7QOUccqExpZ@3c0d1","adSgwdGcVO67GRK/JoUPpj","bc67+sUb9Gn7QOUccqExpZ@b755d","bc67+sUb9Gn7QOUccqExpZ@6745b","c1ctcqW61DF6NeZl8H60t+@b47c0","6fAc9/gb9Kfr1dCvwZaWSA@b47c0","f6Tzv9D1pKMZXmZAWxgAq2","f8RWMSNbtIT42iB3eJMC5y","a04e3tGp5NdowowQOCKFkV","67v5GrdcZH54DL2IjRSQle","3fct6/xFNAkYd1mNgaePbC","05Ix0D3H9GKonLe80eJjTE"],["node","_mesh","_parent","_skeleton","targetInfo","_effectAsset","_defaultClip","mainTexture","_spriteFrame","root","_clip","target","source","_textureSource","asset","_particleSystem","_mainTexture","data","Level","NodesController","AudioManager","_cameraComponent","BossController","GameController","IronSource","scene","DieSound","Dino_AttkSound","chooseSound","succesSound","MergeSound","bgSound","hideMask","Camera","_skeletonData","_envmapHDR","_envmapLDR","metallicRoughnessMap","occlusionMap","emissiveMap"],[["cc.Node",["_name","_layer","_id","_objFlags","__editorExtras__","_active","_children","_parent","_lpos","_components","_lrot","_euler","_prefab","_lscale"],-3,2,1,5,2,5,5,4,5],["cc.Node",["_name","_layer","_active","_id","_components","_parent","_lpos","_children","_lscale","_lrot","_euler"],-1,9,1,5,2,5,5,5],"cc.ImageAsset",["cc.RealKeyframeValue",["rightTangent","rightTangentWeight","leftTangent","leftTangentWeight","value","interpolationMode"],-3],"cc.SpriteFrame",["cc.CurveRange",["mode","constantMax","constantMin","constant","multiplier","spline"],-2,4],["cc.Material",["_states","_defines","_techIdx","_name","_props"],-1,12],["cc.ParticleSystem",["duration","loop","playOnAwake","_simulationSpace","startSize3D","startRotation3D","_aabbHalfX","_aabbHalfY","_aabbHalfZ","node","__prefab","_materials","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","_colorOverLifetimeModule","_shapeModule","_sizeOvertimeModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_rotationOvertimeModule","_textureAnimationModule","_trailModule","renderer","bursts"],-6,1,4,12,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,9],["cc.GradientRange",["_mode","gradient","color"],2,4,5],["cc.ColorKey",["time","color"],2,5],["cc.ShapeModule",["_enable","emitFrom","_shapeType","radius","radiusThickness","arcSpeed"],-2,4],["cc.ParticleSystemRenderer",["_alignSpace","_lengthScale","_renderMode","_mainTexture","_mesh"],0,6,6],["cc.SkeletalAnimation",["playOnLoad","node","_clips","_defaultClip"],2,1,3,6],["cc.UITransform",["node","_contentSize","_anchorPoint"],3,1,5,5],["cc.Sprite",["_sizeMode","node","_spriteFrame","_color"],2,1,6,5],["cc.MeshRenderer",["_name","node","_materials","lightmapSettings","_mesh"],2,1,3,4,6],["cc.AudioSource",["_playOnAwake","_loop","node","_clip"],1,1,6],"cc.TextureCube",["cc.Node",["_name","_layer","_children","_components","_lpos","_lrot","_euler","_lscale"],1,2,12,5,5,5,5],["cc.PrefabInfo",["fileId","root","asset","targetOverrides","nestedPrefabInstanceRoots"],2,1,1,9,2],["cc.ColorOvertimeModule",["_enable","color"],2,4],["cc.Gradient",["colorKeys","alphaKeys"],3,9,9],["cc.SizeOvertimeModule",["_enable","separateAxes","size","x","y","z"],1,4,4,4,4],["cc.LimitVelocityOvertimeModule",["_enable","dampen","limitX","limitY","limitZ","limit"],1,4,4,4,4],["cc.RotationOvertimeModule",["_enable","_separateAxes","x","y","z"],1,4,4,4],["cc.TextureAnimationModule",["_enable","_numTilesX","_numTilesY","cycleCount","frameOverTime","startFrame"],-1,4,4],["cc.Animation",["playOnLoad","node","_clips","_defaultClip"],2,1,3,6],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides"],1,9],["cc.Camera",["_priority","_far","_clearFlags","_visibility","_name","_fov","_projection","_orthoHeight","node","_color"],-5,1,5],["cc.AudioClip",["_name","_native","_duration"],0],["cc.Material",["_props","_states","_defines"],0],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.Prefab",["_name"],2],["cc.Node",["_name","_layer","_parent","_children","_lpos","_lrot","_euler"],1,1,9,5,5,5],["cc.PrefabInfo",["fileId","root","instance","asset"],2,1,4,6],["cc.CompPrefabInfo",["fileId"],2],["cc.VelocityOvertimeModule",["x","y","z","speedModifier"],3,4,4,4,4],["cc.ForceOvertimeModule",["x","y","z"],3,4,4,4],["cc.RealCurve",["_times","_values"],2,9],["cc.TrailModule",["lifeTime","widthRatio","colorOverTrail","colorOvertime","_particleSystem"],3,4,4,4,4,1],["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.Skeleton",["_name","_hash","_joints","_bindposes"],0,12],["sp.SkeletonData",["_name","_atlasText","textureNames","_skeletonJson","textures"],-1,3],["cc.Burst",["count"],3,4],["cc.AlphaKey",["alpha","time"],1],["cc.SceneAsset",["_name"],2],["cc.BoxCollider",["node","_center","_size"],3,1,5,5],["cc.RigidBody",["_group","_type","node"],1,1],["1a87c5dfeZJjbk21OBfx/iP",["node","AudioManager","NodesController","Level"],3,1,1,1,1],["cc.Canvas",["node","_cameraComponent"],3,1,1],["cc.Widget",["_alignFlags","_top","_bottom","node"],0,1],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.TargetOverrideInfo",["propertyPath","source","sourceInfo","target","targetInfo"],2,1,4,1,4],["cc.TargetInfo",["localID"],2],["cc.SceneGlobals",["ambient","shadows","_skybox","fog","octree"],3,4,4,4,4,4],["cc.AmbientInfo",["_skyIllumLDR","_skyColorHDR","_groundAlbedoHDR","_skyColorLDR","_groundAlbedoLDR"],2,5,5,5,5],["cc.ShadowsInfo",["_type","_enabled","_pcf","_bias","_normalBias","_near","_far","_shadowDistance","_invisibleOcclusionRange","_orthoSize","_maxReceived","_shadowColor","_size"],-8,5,5],["cc.SkyboxInfo",["_enabled","_envmapHDR","_envmapLDR"],2,6,6],["cc.FogInfo",[],3],["cc.OctreeInfo",[],3],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["dd163zuMEBDDa1UHoAitHH9",["node"],3,1],["d10beQtB81Cg6A6SV/C935H",["canvas","details"],3,1,1],["12589K2EypIhboUdyGU7pg7",["node"],3,1],["d6ba26BX9VFWrvN11awPr8L",["node","NodesController","GameController","AudioManager","BossController"],3,1,1,1,1,1],["cc.ModelLightmapSettings",[],3],["cc.PlaneCollider",["node"],3,1],["sp.Skeleton",["loop","_preCacheMode","defaultSkin","defaultAnimation","node","_skeletonData"],-1,1,6],["068c9ERAfJF1b4+fsWryUsH",["AudioManager"],3,1],["c38f329EN1D9YpLdfC+d21z",["node"],3,1],["cc.SkinnedMeshRenderer",["_shadowCastingMode","node","_materials","lightmapSettings","_skinningRoot","_mesh","_skeleton"],2,1,3,4,1,6,6],["cc.DirectionalLight",["_colorTemperature","_illuminanceHDR","_illuminanceLDR","node","_staticSettings"],0,1,4],["cc.StaticLightSettings",[],3],["96cd1/50FZEdpbn/o5xig83",["node","NodesController"],3,1,1],["6c960lg0NRGuppywOJ0wWQL",["node","IronSource","AudioManager","NodesController","GameController"],3,1,1,1,1,1],["9e7afRzdixF9ayAvRwivwpz",["AudioManager"],3,1]],[[53,0,2],[0,0,1,7,6,8,10,11,3],[5,1],[69,1],[60,0,1,2,3],[1,0,1,5,4,3],[74,0,1,2,3,4,5,6,2],[0,0,1,7,8,3],[33,0,1,2,3,4,5,6,3],[31,0,1,2,3],[5,3,2],[41,0,1,2,3,4],[62,0,1,2,3],[61,0,1,2,2],[64,0,1,2,2],[0,0,1,7,6,3],[13,0,1,1],[29,0,1,2,4],[0,0,1,6,8,10,11,3],[8,1],[43,0,1],[15,0,1,2,3,4,2],[15,1,2,3,4,1],[1,0,1,5,4,6,3],[52,0,1,2,3,4,2],[6,2,0,1,4,4],[0,0,7,9,2],[1,0,1,5,4,6,8,3],[34,0,1,2,3,2],[38,0,1,2],[63,0,1,2,2],[5,0,5,2],[12,0,1,2,3,2],[47,0,1,2,3],[26,0,1,2,3,2],[27,0,2,2],[14,0,1,3,2,2],[16,0,2,2],[6,0,1,4,3],[6,3,0,1,4,4],[1,0,2,1,5,4,6,9,8,10,4],[5,0,2,1,4],[46,0,1,2,1],[13,0,1],[0,3,4,7,12,3],[0,3,4,12,3],[0,0,2,7,9,3],[1,0,1,7,4,3],[1,0,1,5,4,6,9,8,10,3],[19,0,1,2,2],[35,0,2],[5,0,1,3],[9,0,1,2],[36,0,1,2,3,1],[37,0,1,2,1],[3,5,4,3],[39,0,1,2,3,4,1],[44,0,1,3],[14,1,3,2,1],[32,0,2],[0,0,1,6,3],[0,0,5,1,7,6,8,10,13,11,4],[0,0,1,7,6,8,13,3],[1,0,1,7,4,6,9,8,10,3],[1,0,5,4,2],[1,0,3,5,4,3],[8,0,1,2],[8,2,1],[20,0,1,2],[9,0,2],[22,2,3,4,5,1],[23,2,3,4,5,1],[24,2,3,4,1],[25,0,1,2,3,4,5,5],[3,4,0,1,2,3,6],[3,5,4,0,1,2,3,7],[3,5,0,1,2,3,6],[40,0,1,2,4],[26,1,2,3,1],[14,1,2,1],[16,0,2,3,2],[30,0,1,2,4],[0,0,9,12,8,10,11,2],[0,0,6,9,12,10,11,2],[0,0,7,9,12,2],[0,0,2,6,9,3],[0,0,1,6,8,3],[0,0,5,1,6,8,10,13,11,4],[0,0,1,7,6,8,3],[0,0,7,9,8,2],[0,0,1,7,6,8,10,13,11,3],[1,0,1,7,4,6,3],[1,0,2,1,7,4,6,8,4],[1,0,2,1,5,7,4,4],[1,0,1,5,7,4,3],[1,0,3,5,7,4,3],[1,0,1,4,6,8,3],[1,0,1,5,7,4,6,3],[1,0,2,1,5,4,8,4],[1,0,5,4,9,10,2],[18,0,1,2,3,4,5,7,6,3],[18,0,2,3,4,5,6,2],[19,0,3,4,2],[7,0,3,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,3],[7,0,1,2,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,35,25,26,27,28,29,30,31,32,33,34,4],[7,4,5,0,1,2,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,35,25,26,27,28,29,30,31,32,33,34,9],[5,0,4,5,3],[20,1,1],[21,0,1],[21,0,1,1],[9,1],[10,0,2,3,4,5,5],[10,0,1,5,3],[10,1,5,2],[22,0,1,2,3,4,5,3],[23,0,1,2,3,4,5,3],[24,0,1,2,3,4,3],[25,4,5,1],[3,0,1,2,3,5],[3,4,1,3,4],[3,5,4,0,2,5],[3,5,2],[11,1,3,2],[11,0,3,2],[11,2,0,4,3,3],[42,0,1,2,3,4,5],[45,0,2],[12,0,1,2,2],[12,1,1],[48,0,1,2,3,1],[13,0,1,2,1],[49,0,1,1],[50,0,1,2,3,4],[51,0,1,2,3,2],[54,0,1,2,3,4,1],[55,0,1,2,3,4,2],[56,0,1,2,3,4,5,6,7,8,9,10,11,12,12],[57,0,1,2,2],[58,1],[59,1],[27,0,1,2,3],[65,0,1],[66,0,1,1],[67,0,1],[68,0,1,2,3,4,1],[15,1,2,3,1],[70,0,1],[71,0,1,2,3,4,5,5],[72,0,1],[28,4,0,5,1,2,3,8,9,7],[28,6,0,7,1,2,3,8,9,7],[16,1,0,2,3],[73,0,1],[75,0,1,2,3,4,4],[76,1],[77,0,1,1],[78,0,1,2,3,4,1],[79,0,1]],[[[[17,"Ig_BreakWall",".mp3",1.07102],-1],0,0,[],[],[]],[[[25,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true,"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[7,5],[53,2]],[[{"name":"icon_legacy","rect":{"x":0,"y":0,"width":192,"height":192},"offset":{"x":0,"y":0},"originalSize":{"width":192,"height":192},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[4],0,[0],[13],[54]],[[[9,".bin",3383603168,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":224,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":224,"count":4,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-0.5,0],"maxPosition",8,[1,0.5,0.5,0]]],-1],0,0,[],[],[]],[[[25,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[7,5],[44,11]],[[[38,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[7,5],[45,11]],[[{"name":"hand-001","rect":{"x":0,"y":0,"width":201,"height":257},"offset":{"x":0,"y":0},"originalSize":{"width":201,"height":257},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[4],0,[0],[13],[55]],[[[59,"FireBall"],[82,"FireBall",[-2],[49,"0dZngw4XVG4L0NExqeSESL",-1,0],[1,-1.488,0,1.296],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[103,0.1,0,1,[50,"997SBNaQNCWKIt4cMMbVIk"],[[0,null],6,0],[19],[41,3,3,1],[2],[2],[10,1],[2],[2],[51,3,4.71238898038469],[2],[10,0.5],[2],[10,100],[2],[68,true,[66,1,[108,[[110],[69,0.25892857142857145],[52,0.4955357142857143,[4,4281459711]],[52,0.7566964285714286,[4,4278211071]],[52,1,[4,4278191239]]]]]],[111,true,3,0.2,0.2,[10,1]],[70,[2],[2],[2],[2]],[53,[2],[2],[2],[10,1]],[54,[2],[2],[2]],[71,[2],[2],[2],[2]],[72,[2],[2],[2]],[73,true,4,4,1,[31,1,[29,[0,1],[[118,1,1,1,1],[74,1,1,1,1,1]]]],[2]],[56,[10,1],[2],[19],[19],-3],[122,-15,1]]],0,[0,9,1,0,-1,2,0,15,2,0,17,1,3],[0,0],[-1,16],[56,44]],[[[77,"builtin-standard",[{"hash":4038009253,"name":"builtin-standard|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"metallicRoughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":7,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":8,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":9,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_vertexId","format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_color","format":44,"location":13,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":14,"defines":[]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":17,"location":0,"defines":["!CC_USE_ACCURATE_FOG"]},{"name":"v_shadowPos","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":2,"defines":["USE_VERTEX_COLOR"]},{"name":"v_position","type":15,"count":1,"stageFlags":17,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":17,"location":4,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":5,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":6,"defines":[]},{"name":"v_tangent","type":15,"count":1,"stageFlags":17,"location":7,"defines":["USE_NORMAL_MAP"]},{"name":"v_bitangent","type":15,"count":1,"stageFlags":17,"location":8,"defines":["USE_NORMAL_MAP"]},{"name":"v_luv","type":15,"count":1,"stageFlags":17,"location":9,"defines":["USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":["CC_FORWARD_ADD"]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 13) in vec4 a_color;\n  layout(location = 2) out vec4 v_color;\n#endif\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\nlayout(location = 6) out vec2 v_uv1;\n#if USE_NORMAL_MAP\n  layout(location = 7) out vec3 v_tangent;\n  layout(location = 8) out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 14) in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) in float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(cc_shadowLPNNInfo.z > 0.0001)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n#endif\n#if CC_USE_IBL\n  layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    layout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      {\n        vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\n        float pcf = cc_shadowWHPBInfo.z;\n        if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n        else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n        else shadow = CCGetShadowFactorHard(pos);\n        shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n      }\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(location = 1) in highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) in vec3 v_luv;\n  layout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nlayout(location = 3) in vec3 v_position;\nlayout(location = 5) in vec2 v_uv;\nlayout(location = 6) in vec2 v_uv1;\nlayout(location = 4) in vec3 v_normal;\n#if USE_VERTEX_COLOR\n  layout(location = 2) in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 7) in vec3 v_tangent;\n  layout(location = 8) in vec3 v_bitangent;\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  layout(set = 1, binding = 3) uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  layout(set = 1, binding = 4) uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  layout(set = 1, binding = 5) uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(set = 2, binding = 1) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(set = 1, binding = 7) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(set = 1, binding = 8) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(set = 1, binding = 9) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(cc_shadowLPNNInfo.z > 0.0001)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      {\n        vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\n        float pcf = cc_shadowWHPBInfo.z;\n        if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n        else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n        else shadow = CCGetShadowFactorHard(pos);\n        shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n      }\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if USE_VERTEX_COLOR\n  in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n#endif\n      uniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n  uniform mediump vec4 cc_viewPort;\n     uniform vec4 albedo;\n     uniform vec4 albedoScaleAndCutoff;\n     uniform vec4 pbrParams;\n     uniform vec4 emissive;\n     uniform vec4 emissiveScaleParam;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(cc_shadowLPNNInfo.z > 0.0001)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DLodEXT(tex, coord, lod);\n      #else\n        return texture2D(tex, coord, lod);\n      #endif\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return textureCubeLodEXT(tex, coord, lod);\n      #else\n        return textureCube(tex, coord, lod);\n      #endif\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      {\n        vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\n        float pcf = cc_shadowWHPBInfo.z;\n        if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n        else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n        else shadow = CCGetShadowFactorHard(pos);\n        shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n      }\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = textureCube(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if USE_VERTEX_COLOR\n  varying vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    CC_APPLY_FOG(color, s.position.xyz);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    gl_FragData[2] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":222,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":65}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"USE_TWOSIDE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"CC_USE_IBL","type":"number","defines":[],"range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","defines":["CC_USE_IBL"],"range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","defines":["USE_NORMAL_MAP"],"options":["v_uv","v_uv1"]},{"name":"PBR_UV","type":"string","defines":[],"options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean","defines":[]},{"name":"USE_METALLIC_ROUGHNESS_MAP","type":"boolean","defines":[]},{"name":"USE_OCCLUSION_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"EMISSIVE_UV","type":"string","defines":["USE_EMISSIVE_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]}]},{"hash":210600745,"name":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_vertexId","format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_texCoord1","format":21,"location":13,"defines":[]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_worldPos","type":16,"count":1,"stageFlags":17,"location":2,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":17,"location":3,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 13) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out vec2 v_uv1;\nlayout(location = 2) out vec4 v_worldPos;\nlayout(location = 3) out float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in vec2 v_uv1;\nlayout(location = 2) in vec4 v_worldPos;\nlayout(location = 3) in float v_clip_depth;\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\n      uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 albedo;\n   uniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture2D(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":183,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":65}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]}]}],[{"name":"opaque","passes":[{"program":"builtin-standard|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"SpecularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]},{"name":"transparent","passes":[{"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"SpecularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]],[[[9,".bin",1807389818,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":94536,"length":9672,"count":2418,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":94536,"count":1313,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,17,18,19,20]]},"minPosition",8,[1,0.00014011404709890485,3.9426605979997476e-8,-0.002747314516454935],"maxPosition",8,[1,0.005042050965130329,0.02120165526866913,0.005284117069095373]]],-1],0,0,[],[],[]],[[[9,".bin",3410698223,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":149400,"length":17016,"count":4254,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":149400,"count":2075,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,2,9,10,11,12]]},"minPosition",8,[1,0.0027620994951575994,0.015239289961755276,-0.003292680950835347],"maxPosition",8,[1,0.01094001904129982,0.031005149707198143,0.0028642856050282717]]],-1],0,0,[],[],[]],[[[11,"Skin-4",2311663973,["Root_M","Root_M/Spine1_M","Root_M/Spine1_M/Chest_M","Root_M/Spine1_M/Chest_M/Neck_M","Root_M/Spine1_M/Chest_M/Neck_M/Head_M","Root_M/Spine1_M/Chest_M/Scapula_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R","Root_M/Spine1_M/Chest_M/Scapula_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L","Root_M/Hip_R","Root_M/Hip_R/Knee_R","Root_M/Hip_R/Knee_R/Ankle_R","Root_M/Hip_R/Knee_R/Ankle_R/Toes_R","Root_M/Hip_L","Root_M/Hip_L/Knee_L","Root_M/Hip_L/Knee_L/Ankle_L","Root_M/Hip_L/Knee_L/Ankle_L/Toes_L"],[[[7,-1.6073266766851061e-16,-5.002625820273957e-16,1,0,0.9995050430297852,-0.031458914279937744,1.4491539940461042e-16,0,0.031458914279937744,0.9995050430297852,5.050714527667544e-16,0,-0.019512146711349487,0.0004364966880530119,-3.2884277806782753e-18,1],[7,-1.6051606546202993e-16,-4.955657313953114e-16,1,0,0.9981581568717957,-0.06066583842039108,1.3015651204319428e-16,0,0.06066583842039108,0.9981581568717957,5.043908088540763e-16,0,-0.024823229759931564,0.0011626967461779714,-3.024364845781441e-18,1],[7,-1.6073587051184242e-16,-5.003653906513687e-16,1,0,0.9995249509811401,-0.03081941418349743,1.4523855570887774e-16,0,0.03081941418349743,0.9995249509811401,5.05081511283003e-16,0,-0.02732432447373867,0.0003465543850325048,-1.9691652799332707e-18,1],[7,5.751306066253416e-17,-4.843061753670192e-16,1,0,0.9392595887184143,0.34320753812789917,1.1219782537462701e-16,0,-0.34320753812789917,0.9392595887184143,4.746281357303692e-16,0,-0.02801189385354519,-0.010852459818124771,-9.365741732283693e-18,1],[7,-1.6081226229577292e-16,-5.053215392444312e-16,1,0,1,-2.0489094865183688e-8,1.6081224906088311e-16,0,2.0489094865183688e-8,1,5.053215392444312e-16,0,-0.03196112811565399,0.00012439562124200165,-9.574726432503377e-18,1],[7,-0.9999274015426636,-0.0000014861826684864354,-0.012051843106746674,0,-0.012051843106746674,0.00012334794155322015,0.9999273419380188,0,4.953271126595382e-10,1,-0.00012335690553300083,0,-0.0026569380424916744,0.00010892005229834467,-0.02848154492676258,1],[7,-0.13757513463497162,-0.002986916108056903,-0.9904868006706238,0,-0.9848853349685669,-0.10582999140024185,0.13711625337600708,0,-0.10523276776075363,0.9943797588348389,0.011617805808782578,0,0.027152078226208687,0.0031008601654320955,-0.009787609800696373,1],[7,-0.13418284058570862,0.03050908073782921,-0.9904868006706238,0,-0.9143990874290466,0.3814191222190857,0.13562361896038055,0,0.38192838430404663,0.9238986372947693,-0.023282427340745926,0,0.020675957202911377,-0.008082355372607708,-0.009775741025805473,1],[7,-0.1095951646566391,0.04025038704276085,-0.9931610226631165,0,-0.916633665561676,0.38233044743537903,0.11664529889822006,0,0.38441070914268494,0.9231485724449158,-0.005006704945117235,0,0.015505842864513397,-0.00802612118422985,-0.009472150355577469,1],[7,-0.9999274015426636,-0.000001486659016336489,-0.012051837518811226,0,0.0120518384501338,-0.00012334641360212117,-0.9999273419380188,0,-9.146007654567759e-16,-1,0.00012335537758190185,0,0.0026569380424916744,-0.00010892009595409036,0.02848154492676258,1],[7,-0.1382497102022171,-0.0029869170393794775,-0.9903929233551025,0,0.9847917556762695,0.10582999885082245,-0.13778701424598694,0,0.10522483289241791,-0.9943797588348389,-0.011689475737512112,0,-0.027123883366584778,-0.0030986019410192966,0.009807745926082134,1],[7,-0.13483723998069763,0.030672883614897728,-0.9903929233551025,0,0.9810152649879456,-0.13646891713142395,-0.13778701424598694,0,-0.1393841803073883,-0.9901694059371948,-0.011689475737512112,0,-0.02204393781721592,0.0023237529676407576,0.009807745926082134,1],[7,-0.11025131493806839,0.04041488096117973,-0.9930816888809204,0,0.9838196039199829,-0.13753312826156616,-0.11482014507055283,0,-0.14122207462787628,-0.9896723031997681,-0.024597741663455963,0,-0.016886811703443527,0.0022708119358867407,0.009415285661816597,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,-0.9993575811386108,-0.03419242799282074,0.01073656789958477,0,-0.034194398671388626,0.9994152188301086,-2.2132606511404695e-11,0,0.01896691881120205,0.0005232312832958996,-0.0027990643866360188,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,-0.9948249459266663,-0.10103510320186615,0.01073656789958477,0,-0.10104092955589294,0.9948822855949402,-2.213251457106047e-11,0,0.01038399152457714,0.0012213099980726838,-0.0027990643866360188,1],[7,-1.8117590760979851e-10,-0.0015915741678327322,-0.9999987483024597,0,-1,-7.552468872518148e-8,3.013794214190568e-10,0,-7.552507241825879e-8,0.9999987483024597,-0.0015915741678327322,0,0.002713743830099702,0.0009506093338131905,-0.0027716041076928377,1],[7,7.942823003759258e-7,6.541559827155652e-8,-1,0,-0.08185373991727829,0.9966443777084351,1.8111570576628822e-10,0,0.9966443777084351,0.08185373991727829,7.96971448835393e-7,0,-0.0015626671956852078,-0.0007490511634387076,-0.0027741852682083845,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,0.9993575811386108,0.03419242799282074,-0.01073656789958477,0,0.034194398671388626,-0.9994152188301086,2.2804104762017604e-15,0,-0.01896691881120205,-0.0005232313415035605,0.0027990643866360188,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,0.9948249459266663,0.10103511065244675,-0.01073656789958477,0,0.10104092955589294,-0.9948822855949402,2.2699371255671978e-15,0,-0.01038399152457714,-0.0012213099980726838,0.0027990643866360188,1],[7,-1.8150986269560576e-10,-0.0015915741678327322,-0.9999987483024597,0,1,7.69743095929698e-8,-3.0402055872791323e-10,0,7.697469328604711e-8,-0.9999987483024597,0.0015915741678327322,0,-0.002713743830099702,-0.0009506093920208514,0.0027716041076928377,1],[7,-7.873639447097958e-7,-6.519635320501038e-8,-1,0,0.08185373991727829,-0.9966443777084351,5.288988691454222e-10,0,-0.9966443777084351,-0.08185373991727829,7.900583796072169e-7,0,0.0015626716194674373,0.0007490515126846731,0.0027741827070713043,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[11,"Skin-0",2311663973,["Root_M","Root_M/Spine1_M","Root_M/Spine1_M/Chest_M","Root_M/Spine1_M/Chest_M/Neck_M","Root_M/Spine1_M/Chest_M/Neck_M/Head_M","Root_M/Spine1_M/Chest_M/Scapula_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R","Root_M/Spine1_M/Chest_M/Scapula_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L","Root_M/Hip_R","Root_M/Hip_R/Knee_R","Root_M/Hip_R/Knee_R/Ankle_R","Root_M/Hip_R/Knee_R/Ankle_R/Toes_R","Root_M/Hip_L","Root_M/Hip_L/Knee_L","Root_M/Hip_L/Knee_L/Ankle_L","Root_M/Hip_L/Knee_L/Ankle_L/Toes_L"],[[[7,-1.6073266766851061e-16,-5.002625820273957e-16,1,0,0.9995050430297852,-0.031458914279937744,1.4491539940461042e-16,0,0.031458914279937744,0.9995050430297852,5.050714527667544e-16,0,-0.019512146711349487,0.0004364966880530119,-3.2884277806782753e-18,1],[7,-1.6051606546202993e-16,-4.955657313953114e-16,1,0,0.9981581568717957,-0.06066583842039108,1.3015651204319428e-16,0,0.06066583842039108,0.9981581568717957,5.043908088540763e-16,0,-0.024823229759931564,0.0011626967461779714,-3.024364845781441e-18,1],[7,-1.6073587051184242e-16,-5.003653906513687e-16,1,0,0.9995249509811401,-0.03081941418349743,1.4523855570887774e-16,0,0.03081941418349743,0.9995249509811401,5.05081511283003e-16,0,-0.02732432447373867,0.0003465543850325048,-1.9691652799332707e-18,1],[7,5.751306066253416e-17,-4.843061753670192e-16,1,0,0.9392595887184143,0.34320753812789917,1.1219782537462701e-16,0,-0.34320753812789917,0.9392595887184143,4.746281357303692e-16,0,-0.02801189385354519,-0.010852459818124771,-9.365741732283693e-18,1],[7,-1.6081226229577292e-16,-5.053215392444312e-16,1,0,1,-2.0489094865183688e-8,1.6081224906088311e-16,0,2.0489094865183688e-8,1,5.053215392444312e-16,0,-0.03196112811565399,0.00012439562124200165,-9.574726432503377e-18,1],[7,-0.9999274015426636,-0.0000014861826684864354,-0.012051843106746674,0,-0.012051843106746674,0.00012334794155322015,0.9999273419380188,0,4.953271126595382e-10,1,-0.00012335690553300083,0,-0.0026569380424916744,0.00010892005229834467,-0.02848154492676258,1],[7,-0.13757513463497162,-0.002986916108056903,-0.9904868006706238,0,-0.9848853349685669,-0.10582999140024185,0.13711625337600708,0,-0.10523276776075363,0.9943797588348389,0.011617805808782578,0,0.027152078226208687,0.0031008601654320955,-0.009787609800696373,1],[7,-0.13418284058570862,0.03050908073782921,-0.9904868006706238,0,-0.9143990874290466,0.3814191222190857,0.13562361896038055,0,0.38192838430404663,0.9238986372947693,-0.023282427340745926,0,0.020675957202911377,-0.008082355372607708,-0.009775741025805473,1],[7,-0.1095951646566391,0.04025038704276085,-0.9931610226631165,0,-0.916633665561676,0.38233044743537903,0.11664529889822006,0,0.38441070914268494,0.9231485724449158,-0.005006704945117235,0,0.015505842864513397,-0.00802612118422985,-0.009472150355577469,1],[7,-0.9999274015426636,-0.000001486659016336489,-0.012051837518811226,0,0.0120518384501338,-0.00012334641360212117,-0.9999273419380188,0,-9.146007654567759e-16,-1,0.00012335537758190185,0,0.0026569380424916744,-0.00010892009595409036,0.02848154492676258,1],[7,-0.1382497102022171,-0.0029869170393794775,-0.9903929233551025,0,0.9847917556762695,0.10582999885082245,-0.13778701424598694,0,0.10522483289241791,-0.9943797588348389,-0.011689475737512112,0,-0.027123883366584778,-0.0030986019410192966,0.009807745926082134,1],[7,-0.13483723998069763,0.030672883614897728,-0.9903929233551025,0,0.9810152649879456,-0.13646891713142395,-0.13778701424598694,0,-0.1393841803073883,-0.9901694059371948,-0.011689475737512112,0,-0.02204393781721592,0.0023237529676407576,0.009807745926082134,1],[7,-0.11025131493806839,0.04041488096117973,-0.9930816888809204,0,0.9838196039199829,-0.13753312826156616,-0.11482014507055283,0,-0.14122207462787628,-0.9896723031997681,-0.024597741663455963,0,-0.016886811703443527,0.0022708119358867407,0.009415285661816597,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,-0.9993575811386108,-0.03419242799282074,0.01073656789958477,0,-0.034194398671388626,0.9994152188301086,-2.2132606511404695e-11,0,0.01896691881120205,0.0005232312832958996,-0.0027990643866360188,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,-0.9948249459266663,-0.10103510320186615,0.01073656789958477,0,-0.10104092955589294,0.9948822855949402,-2.213251457106047e-11,0,0.01038399152457714,0.0012213099980726838,-0.0027990643866360188,1],[7,-1.8117590760979851e-10,-0.0015915741678327322,-0.9999987483024597,0,-1,-7.552468872518148e-8,3.013794214190568e-10,0,-7.552507241825879e-8,0.9999987483024597,-0.0015915741678327322,0,0.002713743830099702,0.0009506093338131905,-0.0027716041076928377,1],[7,7.942823003759258e-7,6.541559827155652e-8,-1,0,-0.08185373991727829,0.9966443777084351,1.8111570576628822e-10,0,0.9966443777084351,0.08185373991727829,7.96971448835393e-7,0,-0.0015626671956852078,-0.0007490511634387076,-0.0027741852682083845,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,0.9993575811386108,0.03419242799282074,-0.01073656789958477,0,0.034194398671388626,-0.9994152188301086,2.2804104762017604e-15,0,-0.01896691881120205,-0.0005232313415035605,0.0027990643866360188,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,0.9948249459266663,0.10103511065244675,-0.01073656789958477,0,0.10104092955589294,-0.9948822855949402,2.2699371255671978e-15,0,-0.01038399152457714,-0.0012213099980726838,0.0027990643866360188,1],[7,-1.8150986269560576e-10,-0.0015915741678327322,-0.9999987483024597,0,1,7.69743095929698e-8,-3.0402055872791323e-10,0,7.697469328604711e-8,-0.9999987483024597,0.0015915741678327322,0,-0.002713743830099702,-0.0009506093920208514,0.0027716041076928377,1],[7,-7.873639447097958e-7,-6.519635320501038e-8,-1,0,0.08185373991727829,-0.9966443777084351,5.288988691454222e-10,0,-0.9966443777084351,-0.08185373991727829,7.900583796072169e-7,0,0.0015626716194674373,0.0007490515126846731,0.0027741827070713043,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[9,".bin",3282262026,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":149688,"length":14628,"count":3657,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":149688,"count":2079,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,9,13,17]]},"minPosition",8,[1,-0.004253585822880268,0.017822612076997757,-0.0038464791141450405],"maxPosition",8,[1,0.004253585822880268,0.031113214790821075,0.004096930380910635]]],-1],0,0,[],[],[]],[[[9,".bin",1190738828,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":76032,"length":7908,"count":1977,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":76032,"count":1056,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,9]]},"minPosition",8,[1,-0.0019124604295939207,0.029204759746789932,-0.003246339038014412],"maxPosition",8,[1,0.0019124604295939207,0.03494063764810562,0.0021485798060894012]]],-1],0,0,[],[],[]],[[[9,".bin",2334841053,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":94536,"length":9672,"count":2418,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":94536,"count":1313,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,13,14,15,16]]},"minPosition",8,[1,-0.005042050965130329,3.9426605979997476e-8,-0.002747314516454935],"maxPosition",8,[1,-0.00014011170424055308,0.02120167762041092,0.005284117069095373]]],-1],0,0,[],[],[]],[[[9,".bin",863031265,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":185832,"length":27600,"count":6900,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":185832,"count":2581,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.01371309906244278,0.017852870747447014,-0.009863494895398617],"maxPosition",8,[1,0.01371309906244278,0.03421872854232788,-0.003442745190113783]]],-1],0,0,[],[],[]],[[[11,"Skin-5",2311663973,["Root_M","Root_M/Spine1_M","Root_M/Spine1_M/Chest_M","Root_M/Spine1_M/Chest_M/Neck_M","Root_M/Spine1_M/Chest_M/Neck_M/Head_M","Root_M/Spine1_M/Chest_M/Scapula_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R","Root_M/Spine1_M/Chest_M/Scapula_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L","Root_M/Hip_R","Root_M/Hip_R/Knee_R","Root_M/Hip_R/Knee_R/Ankle_R","Root_M/Hip_R/Knee_R/Ankle_R/Toes_R","Root_M/Hip_L","Root_M/Hip_L/Knee_L","Root_M/Hip_L/Knee_L/Ankle_L","Root_M/Hip_L/Knee_L/Ankle_L/Toes_L"],[[[7,-1.6073266766851061e-16,-5.002625820273957e-16,1,0,0.9995050430297852,-0.031458914279937744,1.4491539940461042e-16,0,0.031458914279937744,0.9995050430297852,5.050714527667544e-16,0,-0.019512146711349487,0.0004364966880530119,-3.2884277806782753e-18,1],[7,-1.6051606546202993e-16,-4.955657313953114e-16,1,0,0.9981581568717957,-0.06066583842039108,1.3015651204319428e-16,0,0.06066583842039108,0.9981581568717957,5.043908088540763e-16,0,-0.024823229759931564,0.0011626967461779714,-3.024364845781441e-18,1],[7,-1.6073587051184242e-16,-5.003653906513687e-16,1,0,0.9995249509811401,-0.03081941418349743,1.4523855570887774e-16,0,0.03081941418349743,0.9995249509811401,5.05081511283003e-16,0,-0.02732432447373867,0.0003465543850325048,-1.9691652799332707e-18,1],[7,5.751306066253416e-17,-4.843061753670192e-16,1,0,0.9392595887184143,0.34320753812789917,1.1219782537462701e-16,0,-0.34320753812789917,0.9392595887184143,4.746281357303692e-16,0,-0.02801189385354519,-0.010852459818124771,-9.365741732283693e-18,1],[7,-1.6081226229577292e-16,-5.053215392444312e-16,1,0,1,-2.0489094865183688e-8,1.6081224906088311e-16,0,2.0489094865183688e-8,1,5.053215392444312e-16,0,-0.03196112811565399,0.00012439562124200165,-9.574726432503377e-18,1],[7,-0.9999274015426636,-0.0000014861826684864354,-0.012051843106746674,0,-0.012051843106746674,0.00012334794155322015,0.9999273419380188,0,4.953271126595382e-10,1,-0.00012335690553300083,0,-0.0026569380424916744,0.00010892005229834467,-0.02848154492676258,1],[7,-0.13757513463497162,-0.002986916108056903,-0.9904868006706238,0,-0.9848853349685669,-0.10582999140024185,0.13711625337600708,0,-0.10523276776075363,0.9943797588348389,0.011617805808782578,0,0.027152078226208687,0.0031008601654320955,-0.009787609800696373,1],[7,-0.13418284058570862,0.03050908073782921,-0.9904868006706238,0,-0.9143990874290466,0.3814191222190857,0.13562361896038055,0,0.38192838430404663,0.9238986372947693,-0.023282427340745926,0,0.020675957202911377,-0.008082355372607708,-0.009775741025805473,1],[7,-0.1095951646566391,0.04025038704276085,-0.9931610226631165,0,-0.916633665561676,0.38233044743537903,0.11664529889822006,0,0.38441070914268494,0.9231485724449158,-0.005006704945117235,0,0.015505842864513397,-0.00802612118422985,-0.009472150355577469,1],[7,-0.9999274015426636,-0.000001486659016336489,-0.012051837518811226,0,0.0120518384501338,-0.00012334641360212117,-0.9999273419380188,0,-9.146007654567759e-16,-1,0.00012335537758190185,0,0.0026569380424916744,-0.00010892009595409036,0.02848154492676258,1],[7,-0.1382497102022171,-0.0029869170393794775,-0.9903929233551025,0,0.9847917556762695,0.10582999885082245,-0.13778701424598694,0,0.10522483289241791,-0.9943797588348389,-0.011689475737512112,0,-0.027123883366584778,-0.0030986019410192966,0.009807745926082134,1],[7,-0.13483723998069763,0.030672883614897728,-0.9903929233551025,0,0.9810152649879456,-0.13646891713142395,-0.13778701424598694,0,-0.1393841803073883,-0.9901694059371948,-0.011689475737512112,0,-0.02204393781721592,0.0023237529676407576,0.009807745926082134,1],[7,-0.11025131493806839,0.04041488096117973,-0.9930816888809204,0,0.9838196039199829,-0.13753312826156616,-0.11482014507055283,0,-0.14122207462787628,-0.9896723031997681,-0.024597741663455963,0,-0.016886811703443527,0.0022708119358867407,0.009415285661816597,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,-0.9993575811386108,-0.03419242799282074,0.01073656789958477,0,-0.034194398671388626,0.9994152188301086,-2.2132606511404695e-11,0,0.01896691881120205,0.0005232312832958996,-0.0027990643866360188,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,-0.9948249459266663,-0.10103510320186615,0.01073656789958477,0,-0.10104092955589294,0.9948822855949402,-2.213251457106047e-11,0,0.01038399152457714,0.0012213099980726838,-0.0027990643866360188,1],[7,-1.8117590760979851e-10,-0.0015915741678327322,-0.9999987483024597,0,-1,-7.552468872518148e-8,3.013794214190568e-10,0,-7.552507241825879e-8,0.9999987483024597,-0.0015915741678327322,0,0.002713743830099702,0.0009506093338131905,-0.0027716041076928377,1],[7,7.942823003759258e-7,6.541559827155652e-8,-1,0,-0.08185373991727829,0.9966443777084351,1.8111570576628822e-10,0,0.9966443777084351,0.08185373991727829,7.96971448835393e-7,0,-0.0015626671956852078,-0.0007490511634387076,-0.0027741852682083845,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,0.9993575811386108,0.03419242799282074,-0.01073656789958477,0,0.034194398671388626,-0.9994152188301086,2.2804104762017604e-15,0,-0.01896691881120205,-0.0005232313415035605,0.0027990643866360188,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,0.9948249459266663,0.10103511065244675,-0.01073656789958477,0,0.10104092955589294,-0.9948822855949402,2.2699371255671978e-15,0,-0.01038399152457714,-0.0012213099980726838,0.0027990643866360188,1],[7,-1.8150986269560576e-10,-0.0015915741678327322,-0.9999987483024597,0,1,7.69743095929698e-8,-3.0402055872791323e-10,0,7.697469328604711e-8,-0.9999987483024597,0.0015915741678327322,0,-0.002713743830099702,-0.0009506093920208514,0.0027716041076928377,1],[7,-7.873639447097958e-7,-6.519635320501038e-8,-1,0,0.08185373991727829,-0.9966443777084351,5.288988691454222e-10,0,-0.9966443777084351,-0.08185373991727829,7.900583796072169e-7,0,0.0015626716194674373,0.0007490515126846731,0.0027741827070713043,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[11,"Skin-2",2311663973,["Root_M","Root_M/Spine1_M","Root_M/Spine1_M/Chest_M","Root_M/Spine1_M/Chest_M/Neck_M","Root_M/Spine1_M/Chest_M/Neck_M/Head_M","Root_M/Spine1_M/Chest_M/Scapula_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R","Root_M/Spine1_M/Chest_M/Scapula_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L","Root_M/Hip_R","Root_M/Hip_R/Knee_R","Root_M/Hip_R/Knee_R/Ankle_R","Root_M/Hip_R/Knee_R/Ankle_R/Toes_R","Root_M/Hip_L","Root_M/Hip_L/Knee_L","Root_M/Hip_L/Knee_L/Ankle_L","Root_M/Hip_L/Knee_L/Ankle_L/Toes_L"],[[[7,-1.6073266766851061e-16,-5.002625820273957e-16,1,0,0.9995050430297852,-0.031458914279937744,1.4491539940461042e-16,0,0.031458914279937744,0.9995050430297852,5.050714527667544e-16,0,-0.019512146711349487,0.0004364966880530119,-3.2884277806782753e-18,1],[7,-1.6051606546202993e-16,-4.955657313953114e-16,1,0,0.9981581568717957,-0.06066583842039108,1.3015651204319428e-16,0,0.06066583842039108,0.9981581568717957,5.043908088540763e-16,0,-0.024823229759931564,0.0011626967461779714,-3.024364845781441e-18,1],[7,-1.6073587051184242e-16,-5.003653906513687e-16,1,0,0.9995249509811401,-0.03081941418349743,1.4523855570887774e-16,0,0.03081941418349743,0.9995249509811401,5.05081511283003e-16,0,-0.02732432447373867,0.0003465543850325048,-1.9691652799332707e-18,1],[7,5.751306066253416e-17,-4.843061753670192e-16,1,0,0.9392595887184143,0.34320753812789917,1.1219782537462701e-16,0,-0.34320753812789917,0.9392595887184143,4.746281357303692e-16,0,-0.02801189385354519,-0.010852459818124771,-9.365741732283693e-18,1],[7,-1.6081226229577292e-16,-5.053215392444312e-16,1,0,1,-2.0489094865183688e-8,1.6081224906088311e-16,0,2.0489094865183688e-8,1,5.053215392444312e-16,0,-0.03196112811565399,0.00012439562124200165,-9.574726432503377e-18,1],[7,-0.9999274015426636,-0.0000014861826684864354,-0.012051843106746674,0,-0.012051843106746674,0.00012334794155322015,0.9999273419380188,0,4.953271126595382e-10,1,-0.00012335690553300083,0,-0.0026569380424916744,0.00010892005229834467,-0.02848154492676258,1],[7,-0.13757513463497162,-0.002986916108056903,-0.9904868006706238,0,-0.9848853349685669,-0.10582999140024185,0.13711625337600708,0,-0.10523276776075363,0.9943797588348389,0.011617805808782578,0,0.027152078226208687,0.0031008601654320955,-0.009787609800696373,1],[7,-0.13418284058570862,0.03050908073782921,-0.9904868006706238,0,-0.9143990874290466,0.3814191222190857,0.13562361896038055,0,0.38192838430404663,0.9238986372947693,-0.023282427340745926,0,0.020675957202911377,-0.008082355372607708,-0.009775741025805473,1],[7,-0.1095951646566391,0.04025038704276085,-0.9931610226631165,0,-0.916633665561676,0.38233044743537903,0.11664529889822006,0,0.38441070914268494,0.9231485724449158,-0.005006704945117235,0,0.015505842864513397,-0.00802612118422985,-0.009472150355577469,1],[7,-0.9999274015426636,-0.000001486659016336489,-0.012051837518811226,0,0.0120518384501338,-0.00012334641360212117,-0.9999273419380188,0,-9.146007654567759e-16,-1,0.00012335537758190185,0,0.0026569380424916744,-0.00010892009595409036,0.02848154492676258,1],[7,-0.1382497102022171,-0.0029869170393794775,-0.9903929233551025,0,0.9847917556762695,0.10582999885082245,-0.13778701424598694,0,0.10522483289241791,-0.9943797588348389,-0.011689475737512112,0,-0.027123883366584778,-0.0030986019410192966,0.009807745926082134,1],[7,-0.13483723998069763,0.030672883614897728,-0.9903929233551025,0,0.9810152649879456,-0.13646891713142395,-0.13778701424598694,0,-0.1393841803073883,-0.9901694059371948,-0.011689475737512112,0,-0.02204393781721592,0.0023237529676407576,0.009807745926082134,1],[7,-0.11025131493806839,0.04041488096117973,-0.9930816888809204,0,0.9838196039199829,-0.13753312826156616,-0.11482014507055283,0,-0.14122207462787628,-0.9896723031997681,-0.024597741663455963,0,-0.016886811703443527,0.0022708119358867407,0.009415285661816597,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,-0.9993575811386108,-0.03419242799282074,0.01073656789958477,0,-0.034194398671388626,0.9994152188301086,-2.2132606511404695e-11,0,0.01896691881120205,0.0005232312832958996,-0.0027990643866360188,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,-0.9948249459266663,-0.10103510320186615,0.01073656789958477,0,-0.10104092955589294,0.9948822855949402,-2.213251457106047e-11,0,0.01038399152457714,0.0012213099980726838,-0.0027990643866360188,1],[7,-1.8117590760979851e-10,-0.0015915741678327322,-0.9999987483024597,0,-1,-7.552468872518148e-8,3.013794214190568e-10,0,-7.552507241825879e-8,0.9999987483024597,-0.0015915741678327322,0,0.002713743830099702,0.0009506093338131905,-0.0027716041076928377,1],[7,7.942823003759258e-7,6.541559827155652e-8,-1,0,-0.08185373991727829,0.9966443777084351,1.8111570576628822e-10,0,0.9966443777084351,0.08185373991727829,7.96971448835393e-7,0,-0.0015626671956852078,-0.0007490511634387076,-0.0027741852682083845,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,0.9993575811386108,0.03419242799282074,-0.01073656789958477,0,0.034194398671388626,-0.9994152188301086,2.2804104762017604e-15,0,-0.01896691881120205,-0.0005232313415035605,0.0027990643866360188,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,0.9948249459266663,0.10103511065244675,-0.01073656789958477,0,0.10104092955589294,-0.9948822855949402,2.2699371255671978e-15,0,-0.01038399152457714,-0.0012213099980726838,0.0027990643866360188,1],[7,-1.8150986269560576e-10,-0.0015915741678327322,-0.9999987483024597,0,1,7.69743095929698e-8,-3.0402055872791323e-10,0,7.697469328604711e-8,-0.9999987483024597,0.0015915741678327322,0,-0.002713743830099702,-0.0009506093920208514,0.0027716041076928377,1],[7,-7.873639447097958e-7,-6.519635320501038e-8,-1,0,0.08185373991727829,-0.9966443777084351,5.288988691454222e-10,0,-0.9966443777084351,-0.08185373991727829,7.900583796072169e-7,0,0.0015626716194674373,0.0007490515126846731,0.0027741827070713043,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[9,".bin",3629128062,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":149472,"length":17004,"count":4251,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":149472,"count":2076,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,5,6,7,8]]},"minPosition",8,[1,-0.01094001904129982,0.01523931510746479,-0.0032927049323916435],"maxPosition",8,[1,-0.002762042684480548,0.031005149707198143,0.00286426255479455]]],-1],0,0,[],[],[]],[[[11,"Skin-6",2311663973,["Root_M","Root_M/Spine1_M","Root_M/Spine1_M/Chest_M","Root_M/Spine1_M/Chest_M/Neck_M","Root_M/Spine1_M/Chest_M/Neck_M/Head_M","Root_M/Spine1_M/Chest_M/Scapula_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R","Root_M/Spine1_M/Chest_M/Scapula_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L","Root_M/Hip_R","Root_M/Hip_R/Knee_R","Root_M/Hip_R/Knee_R/Ankle_R","Root_M/Hip_R/Knee_R/Ankle_R/Toes_R","Root_M/Hip_L","Root_M/Hip_L/Knee_L","Root_M/Hip_L/Knee_L/Ankle_L","Root_M/Hip_L/Knee_L/Ankle_L/Toes_L"],[[[7,-1.6073266766851061e-16,-5.002625820273957e-16,1,0,0.9995050430297852,-0.031458914279937744,1.4491539940461042e-16,0,0.031458914279937744,0.9995050430297852,5.050714527667544e-16,0,-0.019512146711349487,0.0004364966880530119,-3.2884277806782753e-18,1],[7,-1.6051606546202993e-16,-4.955657313953114e-16,1,0,0.9981581568717957,-0.06066583842039108,1.3015651204319428e-16,0,0.06066583842039108,0.9981581568717957,5.043908088540763e-16,0,-0.024823229759931564,0.0011626967461779714,-3.024364845781441e-18,1],[7,-1.6073587051184242e-16,-5.003653906513687e-16,1,0,0.9995249509811401,-0.03081941418349743,1.4523855570887774e-16,0,0.03081941418349743,0.9995249509811401,5.05081511283003e-16,0,-0.02732432447373867,0.0003465543850325048,-1.9691652799332707e-18,1],[7,5.751306066253416e-17,-4.843061753670192e-16,1,0,0.9392595887184143,0.34320753812789917,1.1219782537462701e-16,0,-0.34320753812789917,0.9392595887184143,4.746281357303692e-16,0,-0.02801189385354519,-0.010852459818124771,-9.365741732283693e-18,1],[7,-1.6081226229577292e-16,-5.053215392444312e-16,1,0,1,-2.0489094865183688e-8,1.6081224906088311e-16,0,2.0489094865183688e-8,1,5.053215392444312e-16,0,-0.03196112811565399,0.00012439562124200165,-9.574726432503377e-18,1],[7,-0.9999274015426636,-0.0000014861826684864354,-0.012051843106746674,0,-0.012051843106746674,0.00012334794155322015,0.9999273419380188,0,4.953271126595382e-10,1,-0.00012335690553300083,0,-0.0026569380424916744,0.00010892005229834467,-0.02848154492676258,1],[7,-0.13757513463497162,-0.002986916108056903,-0.9904868006706238,0,-0.9848853349685669,-0.10582999140024185,0.13711625337600708,0,-0.10523276776075363,0.9943797588348389,0.011617805808782578,0,0.027152078226208687,0.0031008601654320955,-0.009787609800696373,1],[7,-0.13418284058570862,0.03050908073782921,-0.9904868006706238,0,-0.9143990874290466,0.3814191222190857,0.13562361896038055,0,0.38192838430404663,0.9238986372947693,-0.023282427340745926,0,0.020675957202911377,-0.008082355372607708,-0.009775741025805473,1],[7,-0.1095951646566391,0.04025038704276085,-0.9931610226631165,0,-0.916633665561676,0.38233044743537903,0.11664529889822006,0,0.38441070914268494,0.9231485724449158,-0.005006704945117235,0,0.015505842864513397,-0.00802612118422985,-0.009472150355577469,1],[7,-0.9999274015426636,-0.000001486659016336489,-0.012051837518811226,0,0.0120518384501338,-0.00012334641360212117,-0.9999273419380188,0,-9.146007654567759e-16,-1,0.00012335537758190185,0,0.0026569380424916744,-0.00010892009595409036,0.02848154492676258,1],[7,-0.1382497102022171,-0.0029869170393794775,-0.9903929233551025,0,0.9847917556762695,0.10582999885082245,-0.13778701424598694,0,0.10522483289241791,-0.9943797588348389,-0.011689475737512112,0,-0.027123883366584778,-0.0030986019410192966,0.009807745926082134,1],[7,-0.13483723998069763,0.030672883614897728,-0.9903929233551025,0,0.9810152649879456,-0.13646891713142395,-0.13778701424598694,0,-0.1393841803073883,-0.9901694059371948,-0.011689475737512112,0,-0.02204393781721592,0.0023237529676407576,0.009807745926082134,1],[7,-0.11025131493806839,0.04041488096117973,-0.9930816888809204,0,0.9838196039199829,-0.13753312826156616,-0.11482014507055283,0,-0.14122207462787628,-0.9896723031997681,-0.024597741663455963,0,-0.016886811703443527,0.0022708119358867407,0.009415285661816597,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,-0.9993575811386108,-0.03419242799282074,0.01073656789958477,0,-0.034194398671388626,0.9994152188301086,-2.2132606511404695e-11,0,0.01896691881120205,0.0005232312832958996,-0.0027990643866360188,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,-0.9948249459266663,-0.10103510320186615,0.01073656789958477,0,-0.10104092955589294,0.9948822855949402,-2.213251457106047e-11,0,0.01038399152457714,0.0012213099980726838,-0.0027990643866360188,1],[7,-1.8117590760979851e-10,-0.0015915741678327322,-0.9999987483024597,0,-1,-7.552468872518148e-8,3.013794214190568e-10,0,-7.552507241825879e-8,0.9999987483024597,-0.0015915741678327322,0,0.002713743830099702,0.0009506093338131905,-0.0027716041076928377,1],[7,7.942823003759258e-7,6.541559827155652e-8,-1,0,-0.08185373991727829,0.9966443777084351,1.8111570576628822e-10,0,0.9966443777084351,0.08185373991727829,7.96971448835393e-7,0,-0.0015626671956852078,-0.0007490511634387076,-0.0027741852682083845,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,0.9993575811386108,0.03419242799282074,-0.01073656789958477,0,0.034194398671388626,-0.9994152188301086,2.2804104762017604e-15,0,-0.01896691881120205,-0.0005232313415035605,0.0027990643866360188,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,0.9948249459266663,0.10103511065244675,-0.01073656789958477,0,0.10104092955589294,-0.9948822855949402,2.2699371255671978e-15,0,-0.01038399152457714,-0.0012213099980726838,0.0027990643866360188,1],[7,-1.8150986269560576e-10,-0.0015915741678327322,-0.9999987483024597,0,1,7.69743095929698e-8,-3.0402055872791323e-10,0,7.697469328604711e-8,-0.9999987483024597,0.0015915741678327322,0,-0.002713743830099702,-0.0009506093920208514,0.0027716041076928377,1],[7,-7.873639447097958e-7,-6.519635320501038e-8,-1,0,0.08185373991727829,-0.9966443777084351,5.288988691454222e-10,0,-0.9966443777084351,-0.08185373991727829,7.900583796072169e-7,0,0.0015626716194674373,0.0007490515126846731,0.0027741827070713043,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[11,"Skin-3",2311663973,["Root_M","Root_M/Spine1_M","Root_M/Spine1_M/Chest_M","Root_M/Spine1_M/Chest_M/Neck_M","Root_M/Spine1_M/Chest_M/Neck_M/Head_M","Root_M/Spine1_M/Chest_M/Scapula_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R","Root_M/Spine1_M/Chest_M/Scapula_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L","Root_M/Hip_R","Root_M/Hip_R/Knee_R","Root_M/Hip_R/Knee_R/Ankle_R","Root_M/Hip_R/Knee_R/Ankle_R/Toes_R","Root_M/Hip_L","Root_M/Hip_L/Knee_L","Root_M/Hip_L/Knee_L/Ankle_L","Root_M/Hip_L/Knee_L/Ankle_L/Toes_L"],[[[7,-1.6073266766851061e-16,-5.002625820273957e-16,1,0,0.9995050430297852,-0.031458914279937744,1.4491539940461042e-16,0,0.031458914279937744,0.9995050430297852,5.050714527667544e-16,0,-0.019512146711349487,0.0004364966880530119,-3.2884277806782753e-18,1],[7,-1.6051606546202993e-16,-4.955657313953114e-16,1,0,0.9981581568717957,-0.06066583842039108,1.3015651204319428e-16,0,0.06066583842039108,0.9981581568717957,5.043908088540763e-16,0,-0.024823229759931564,0.0011626967461779714,-3.024364845781441e-18,1],[7,-1.6073587051184242e-16,-5.003653906513687e-16,1,0,0.9995249509811401,-0.03081941418349743,1.4523855570887774e-16,0,0.03081941418349743,0.9995249509811401,5.05081511283003e-16,0,-0.02732432447373867,0.0003465543850325048,-1.9691652799332707e-18,1],[7,5.751306066253416e-17,-4.843061753670192e-16,1,0,0.9392595887184143,0.34320753812789917,1.1219782537462701e-16,0,-0.34320753812789917,0.9392595887184143,4.746281357303692e-16,0,-0.02801189385354519,-0.010852459818124771,-9.365741732283693e-18,1],[7,-1.6081226229577292e-16,-5.053215392444312e-16,1,0,1,-2.0489094865183688e-8,1.6081224906088311e-16,0,2.0489094865183688e-8,1,5.053215392444312e-16,0,-0.03196112811565399,0.00012439562124200165,-9.574726432503377e-18,1],[7,-0.9999274015426636,-0.0000014861826684864354,-0.012051843106746674,0,-0.012051843106746674,0.00012334794155322015,0.9999273419380188,0,4.953271126595382e-10,1,-0.00012335690553300083,0,-0.0026569380424916744,0.00010892005229834467,-0.02848154492676258,1],[7,-0.13757513463497162,-0.002986916108056903,-0.9904868006706238,0,-0.9848853349685669,-0.10582999140024185,0.13711625337600708,0,-0.10523276776075363,0.9943797588348389,0.011617805808782578,0,0.027152078226208687,0.0031008601654320955,-0.009787609800696373,1],[7,-0.13418284058570862,0.03050908073782921,-0.9904868006706238,0,-0.9143990874290466,0.3814191222190857,0.13562361896038055,0,0.38192838430404663,0.9238986372947693,-0.023282427340745926,0,0.020675957202911377,-0.008082355372607708,-0.009775741025805473,1],[7,-0.1095951646566391,0.04025038704276085,-0.9931610226631165,0,-0.916633665561676,0.38233044743537903,0.11664529889822006,0,0.38441070914268494,0.9231485724449158,-0.005006704945117235,0,0.015505842864513397,-0.00802612118422985,-0.009472150355577469,1],[7,-0.9999274015426636,-0.000001486659016336489,-0.012051837518811226,0,0.0120518384501338,-0.00012334641360212117,-0.9999273419380188,0,-9.146007654567759e-16,-1,0.00012335537758190185,0,0.0026569380424916744,-0.00010892009595409036,0.02848154492676258,1],[7,-0.1382497102022171,-0.0029869170393794775,-0.9903929233551025,0,0.9847917556762695,0.10582999885082245,-0.13778701424598694,0,0.10522483289241791,-0.9943797588348389,-0.011689475737512112,0,-0.027123883366584778,-0.0030986019410192966,0.009807745926082134,1],[7,-0.13483723998069763,0.030672883614897728,-0.9903929233551025,0,0.9810152649879456,-0.13646891713142395,-0.13778701424598694,0,-0.1393841803073883,-0.9901694059371948,-0.011689475737512112,0,-0.02204393781721592,0.0023237529676407576,0.009807745926082134,1],[7,-0.11025131493806839,0.04041488096117973,-0.9930816888809204,0,0.9838196039199829,-0.13753312826156616,-0.11482014507055283,0,-0.14122207462787628,-0.9896723031997681,-0.024597741663455963,0,-0.016886811703443527,0.0022708119358867407,0.009415285661816597,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,-0.9993575811386108,-0.03419242799282074,0.01073656789958477,0,-0.034194398671388626,0.9994152188301086,-2.2132606511404695e-11,0,0.01896691881120205,0.0005232312832958996,-0.0027990643866360188,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,-0.9948249459266663,-0.10103510320186615,0.01073656789958477,0,-0.10104092955589294,0.9948822855949402,-2.213251457106047e-11,0,0.01038399152457714,0.0012213099980726838,-0.0027990643866360188,1],[7,-1.8117590760979851e-10,-0.0015915741678327322,-0.9999987483024597,0,-1,-7.552468872518148e-8,3.013794214190568e-10,0,-7.552507241825879e-8,0.9999987483024597,-0.0015915741678327322,0,0.002713743830099702,0.0009506093338131905,-0.0027716041076928377,1],[7,7.942823003759258e-7,6.541559827155652e-8,-1,0,-0.08185373991727829,0.9966443777084351,1.8111570576628822e-10,0,0.9966443777084351,0.08185373991727829,7.96971448835393e-7,0,-0.0015626671956852078,-0.0007490511634387076,-0.0027741852682083845,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,0.9993575811386108,0.03419242799282074,-0.01073656789958477,0,0.034194398671388626,-0.9994152188301086,2.2804104762017604e-15,0,-0.01896691881120205,-0.0005232313415035605,0.0027990643866360188,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,0.9948249459266663,0.10103511065244675,-0.01073656789958477,0,0.10104092955589294,-0.9948822855949402,2.2699371255671978e-15,0,-0.01038399152457714,-0.0012213099980726838,0.0027990643866360188,1],[7,-1.8150986269560576e-10,-0.0015915741678327322,-0.9999987483024597,0,1,7.69743095929698e-8,-3.0402055872791323e-10,0,7.697469328604711e-8,-0.9999987483024597,0.0015915741678327322,0,-0.002713743830099702,-0.0009506093920208514,0.0027716041076928377,1],[7,-7.873639447097958e-7,-6.519635320501038e-8,-1,0,0.08185373991727829,-0.9966443777084351,5.288988691454222e-10,0,-0.9966443777084351,-0.08185373991727829,7.900583796072169e-7,0,0.0015626716194674373,0.0007490515126846731,0.0027741827070713043,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[11,"Skin-1",3957892668,["Root_M/Spine1_M/Chest_M"],[[[7,-1.6073587051184242e-16,-5.003653906513687e-16,1,0,0.9995249509811401,-0.03081941418349743,1.4523855570887774e-16,0,0.03081941418349743,0.9995249509811401,5.05081511283003e-16,0,-0.02732432447373867,0.0003465543850325048,-1.9691652799332707e-18,1]],8]]],0,0,[],[],[]],[[[25,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true,"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.15,"metallic":0.65},"albedoScale",8,[1,1.5,1.5,1.5],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[7,5],[57,2]],[[[25,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true,"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[7,5],[58,2]],[[[17,"PurchaseDino",".mp3",0.36],-1],0,0,[],[],[]],[[[38,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[7,5],[46,11]],[[[9,".bin",1247067917,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":3168,"length":768,"count":192,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":3168,"count":66,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.3200426995754242,-0.32004261016845703,0],"maxPosition",8,[1,0.32004252076148987,0.3200426399707794,0.29342496395111084]]],-1],0,0,[],[],[]],[[[25,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true,"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[7,5],[59,2]],[[[11,"Skin-4",3761838401,["Root_M","Root_M/Spine1_M","Root_M/Spine1_M/Chest_M","Root_M/Spine1_M/Chest_M/Neck_M","Root_M/Spine1_M/Chest_M/Neck_M/Head_M","Root_M/Spine1_M/Chest_M/Scapula_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R","Root_M/Hip_R","Root_M/Hip_R/Knee_R"],[[[7,-1.6073266766851061e-16,-5.002625820273957e-16,1,0,0.9995050430297852,-0.031458914279937744,1.4491539940461042e-16,0,0.031458914279937744,0.9995050430297852,5.050714527667544e-16,0,-0.019512146711349487,0.0004364966880530119,-3.2884277806782753e-18,1],[7,-1.6051606546202993e-16,-4.955657313953114e-16,1,0,0.9981581568717957,-0.06066583842039108,1.3015651204319428e-16,0,0.06066583842039108,0.9981581568717957,5.043908088540763e-16,0,-0.024823229759931564,0.0011626967461779714,-3.024364845781441e-18,1],[7,-1.6073587051184242e-16,-5.003653906513687e-16,1,0,0.9995249509811401,-0.03081941418349743,1.4523855570887774e-16,0,0.03081941418349743,0.9995249509811401,5.05081511283003e-16,0,-0.02732432447373867,0.0003465543850325048,-1.9691652799332707e-18,1],[7,5.751306066253416e-17,-4.843061753670192e-16,1,0,0.9392595887184143,0.34320753812789917,1.1219782537462701e-16,0,-0.34320753812789917,0.9392595887184143,4.746281357303692e-16,0,-0.02801189385354519,-0.010852459818124771,-9.365741732283693e-18,1],[7,-1.6081226229577292e-16,-5.053215392444312e-16,1,0,1,-2.0489094865183688e-8,1.6081224906088311e-16,0,2.0489094865183688e-8,1,5.053215392444312e-16,0,-0.03196112811565399,0.00012439562124200165,-9.574726432503377e-18,1],[7,-0.9999274015426636,-0.0000014861826684864354,-0.012051843106746674,0,-0.012051843106746674,0.00012334794155322015,0.9999273419380188,0,4.953271126595382e-10,1,-0.00012335690553300083,0,-0.002503913827240467,0.00010892027785303071,-0.028479700908064842,1],[7,-0.0927719995379448,-0.02428782358765602,-0.9953911304473877,0,-0.9907236695289612,-0.09744593501091003,0.0947146937251091,0,-0.09929723292589188,0.9949443936347961,-0.015022268518805504,0,0.027415143325924873,0.00269489549100399,-0.010212181136012077,1],[7,-0.09589303284883499,-0.0010335920378565788,-0.9953911304473877,0,-0.9847338199615479,0.14604248106479645,0.0947146937251091,0,0.14527148008346558,0.9892777800559998,-0.015022268518805504,0,0.02222844958305359,-0.0027861015405505896,-0.010212181136012077,1],[7,-0.07126504927873611,0.008662938140332699,-0.9974197745323181,0,-0.9864515066146851,0.14752475917339325,0.07176267355680466,0,0.14776578545570374,0.9890204071998596,-0.0019677907694131136,0,0.01708024926483631,-0.0027297406923025846,-0.009819445200264454,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,-0.9993575811386108,-0.03419242799282074,0.01073656789958477,0,-0.034194398671388626,0.9994152188301086,-2.2132606511404695e-11,0,0.01896691881120205,0.0005232312832958996,-0.0027990643866360188,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,-0.9948249459266663,-0.10103510320186615,0.01073656789958477,0,-0.10104092955589294,0.9948822855949402,-2.213251457106047e-11,0,0.01038399152457714,0.0012213099980726838,-0.0027990643866360188,1]],8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[11,"Skin-0",1398445096,["Root_M","Root_M/Spine1_M","Root_M/Spine1_M/Chest_M","Root_M/Spine1_M/Chest_M/Neck_M","Root_M/Spine1_M/Chest_M/Neck_M/Head_M","Root_M/Spine1_M/Chest_M/Scapula_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R","Root_M/Spine1_M/Chest_M/Scapula_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L","Root_M/Hip_R","Root_M/Hip_R/Knee_R","Root_M/Hip_L","Root_M/Hip_L/Knee_L"],[[[7,-1.6073266766851061e-16,-5.002625820273957e-16,1,0,0.9995050430297852,-0.031458914279937744,1.4491539940461042e-16,0,0.031458914279937744,0.9995050430297852,5.050714527667544e-16,0,-0.019512146711349487,0.0004364966880530119,-3.2884277806782753e-18,1],[7,-1.6051606546202993e-16,-4.955657313953114e-16,1,0,0.9981581568717957,-0.06066583842039108,1.3015651204319428e-16,0,0.06066583842039108,0.9981581568717957,5.043908088540763e-16,0,-0.024823229759931564,0.0011626967461779714,-3.024364845781441e-18,1],[7,-1.6073587051184242e-16,-5.003653906513687e-16,1,0,0.9995249509811401,-0.03081941418349743,1.4523855570887774e-16,0,0.03081941418349743,0.9995249509811401,5.05081511283003e-16,0,-0.02732432447373867,0.0003465543850325048,-1.9691652799332707e-18,1],[7,5.751306066253416e-17,-4.843061753670192e-16,1,0,0.9392595887184143,0.34320753812789917,1.1219782537462701e-16,0,-0.34320753812789917,0.9392595887184143,4.746281357303692e-16,0,-0.02801189385354519,-0.010852459818124771,-9.365741732283693e-18,1],[7,-1.6081226229577292e-16,-5.053215392444312e-16,1,0,1,-2.0489094865183688e-8,1.6081224906088311e-16,0,2.0489094865183688e-8,1,5.053215392444312e-16,0,-0.03196112811565399,0.00012439562124200165,-9.574726432503377e-18,1],[7,-0.9999274015426636,-0.0000014861826684864354,-0.012051843106746674,0,-0.012051843106746674,0.00012334794155322015,0.9999273419380188,0,4.953271126595382e-10,1,-0.00012335690553300083,0,-0.002503913827240467,0.00010892027785303071,-0.028479700908064842,1],[7,-0.0927719995379448,-0.02428782358765602,-0.9953911304473877,0,-0.9907236695289612,-0.09744593501091003,0.0947146937251091,0,-0.09929723292589188,0.9949443936347961,-0.015022268518805504,0,0.027415143325924873,0.00269489549100399,-0.010212181136012077,1],[7,-0.09589303284883499,-0.0010335920378565788,-0.9953911304473877,0,-0.9847338199615479,0.14604248106479645,0.0947146937251091,0,0.14527148008346558,0.9892777800559998,-0.015022268518805504,0,0.02222844958305359,-0.0027861015405505896,-0.010212181136012077,1],[7,-0.07126504927873611,0.008662938140332699,-0.9974197745323181,0,-0.9864515066146851,0.14752475917339325,0.07176267355680466,0,0.14776578545570374,0.9890204071998596,-0.0019677907694131136,0,0.01708024926483631,-0.0027297406923025846,-0.009819445200264454,1],[7,-0.9999274015426636,-0.000001486659016336489,-0.012051837518811226,0,0.0120518384501338,-0.00012334641360212117,-0.9999273419380188,0,-9.146007654567759e-16,-1,0.00012335537758190185,0,0.0028796999249607325,-0.0001089197612600401,0.028484230861067772,1],[7,-0.15891462564468384,-0.016919724643230438,-0.987147331237793,0,0.9815993309020996,0.10451140254735947,-0.1598128229379654,0,0.10587213933467865,-0.9943797588348389,5.446323392277463e-10,0,-0.02677895687520504,-0.0029642386361956596,0.011229886673390865,1],[7,-0.15826688706874847,0.022175027057528496,-0.987147331237793,0,0.977598249912262,-0.13697285950183868,-0.1598128229379654,0,-0.13875624537467957,-0.9903265833854675,5.44632006160839e-10,0,-0.02167670615017414,0.002370338188484311,0.011229886673390865,1],[7,-0.1337725818157196,0.0319434329867363,-0.9904971122741699,0,0.9809468388557434,-0.1378193348646164,-0.13692742586135864,0,-0.14088359475135803,-0.9899421334266663,-0.01289836224168539,0,-0.016554739326238632,0.0023029823787510395,0.010846441611647606,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,-0.9993575811386108,-0.03419242799282074,0.01073656789958477,0,-0.034194398671388626,0.9994152188301086,-2.2132606511404695e-11,0,0.01896691881120205,0.0005232312832958996,-0.0027990643866360188,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,-0.9948249459266663,-0.10103510320186615,0.01073656789958477,0,-0.10104092955589294,0.9948822855949402,-2.213251457106047e-11,0,0.01038399152457714,0.0012213099980726838,-0.0027990643866360188,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,0.9993575811386108,0.03419242799282074,-0.01073656789958477,0,0.034194398671388626,-0.9994152188301086,2.2804104762017604e-15,0,-0.01896691881120205,-0.0005232313415035605,0.0027990643866360188,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,0.9948249459266663,0.10103511065244675,-0.01073656789958477,0,0.10104092955589294,-0.9948822855949402,2.2699371255671978e-15,0,-0.01038399152457714,-0.0012213099980726838,0.0027990643866360188,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[9,".bin",4291740134,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":121536,"length":13656,"count":3414,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":121536,"count":1688,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,5,6,7,8,9]]},"minPosition",8,[1,-0.008162803947925568,-2.770612539393369e-8,-0.0028996625915169716],"maxPosition",8,[1,-0.0003719171218108386,0.019594445824623108,0.004642312414944172]]],-1],0,0,[],[],[]],[[[9,".bin",3923920747,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":53424,"length":5952,"count":1488,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":53424,"count":742,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,5,6,7,8]]},"minPosition",8,[1,0.003725956892594695,0.014783668331801891,-0.0029849016573280096],"maxPosition",8,[1,0.011450743302702904,0.0316593274474144,0.0030465873423963785]]],-1],0,0,[],[],[]],[[[11,"Skin-5",504387730,["Root_M","Root_M/Spine1_M","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R","Root_M/Hip_R","Root_M/Hip_R/Knee_R","Root_M/Hip_R/Knee_R/Ankle_R","Root_M/Hip_R/Knee_R/Ankle_R/Toes_R","Root_M/Hip_L","Root_M/Hip_L/Knee_L","Root_M/Hip_L/Knee_L/Ankle_L","Root_M/Hip_L/Knee_L/Ankle_L/Toes_L"],[[[7,-1.6073266766851061e-16,-5.002625820273957e-16,1,0,0.9995050430297852,-0.031458914279937744,1.4491539940461042e-16,0,0.031458914279937744,0.9995050430297852,5.050714527667544e-16,0,-0.019512146711349487,0.0004364966880530119,-3.2884277806782753e-18,1],[7,-1.6051606546202993e-16,-4.955657313953114e-16,1,0,0.9981581568717957,-0.06066583842039108,1.3015651204319428e-16,0,0.06066583842039108,0.9981581568717957,5.043908088540763e-16,0,-0.024823229759931564,0.0011626967461779714,-3.024364845781441e-18,1],[7,-0.0927719995379448,-0.02428782358765602,-0.9953911304473877,0,-0.9907236695289612,-0.09744593501091003,0.0947146937251091,0,-0.09929723292589188,0.9949443936347961,-0.015022268518805504,0,0.027415143325924873,0.00269489549100399,-0.010212181136012077,1],[7,-0.09589303284883499,-0.0010335920378565788,-0.9953911304473877,0,-0.9847338199615479,0.14604248106479645,0.0947146937251091,0,0.14527148008346558,0.9892777800559998,-0.015022268518805504,0,0.02222844958305359,-0.0027861015405505896,-0.010212181136012077,1],[7,-0.07126504927873611,0.008662938140332699,-0.9974197745323181,0,-0.9864515066146851,0.14752475917339325,0.07176267355680466,0,0.14776578545570374,0.9890204071998596,-0.0019677907694131136,0,0.01708024926483631,-0.0027297406923025846,-0.009819445200264454,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,-0.9993575811386108,-0.03419242799282074,0.01073656789958477,0,-0.034194398671388626,0.9994152188301086,-2.2132606511404695e-11,0,0.01896691881120205,0.0005232312832958996,-0.0027990643866360188,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,-0.9948249459266663,-0.10103510320186615,0.01073656789958477,0,-0.10104092955589294,0.9948822855949402,-2.213251457106047e-11,0,0.01038399152457714,0.0012213099980726838,-0.0027990643866360188,1],[7,-1.8117590760979851e-10,-0.0015915741678327322,-0.9999987483024597,0,-1,-7.552468872518148e-8,3.013794214190568e-10,0,-7.552507241825879e-8,0.9999987483024597,-0.0015915741678327322,0,0.002713743830099702,0.0009506093338131905,-0.0027716041076928377,1],[7,7.942823003759258e-7,6.541559827155652e-8,-1,0,-0.08185373991727829,0.9966443777084351,1.8111570576628822e-10,0,0.9966443777084351,0.08185373991727829,7.96971448835393e-7,0,-0.0015626671956852078,-0.0007490511634387076,-0.0027741852682083845,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,0.9993575811386108,0.03419242799282074,-0.01073656789958477,0,0.034194398671388626,-0.9994152188301086,2.2804104762017604e-15,0,-0.01896691881120205,-0.0005232313415035605,0.0027990643866360188,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,0.9948249459266663,0.10103511065244675,-0.01073656789958477,0,0.10104092955589294,-0.9948822855949402,2.2699371255671978e-15,0,-0.01038399152457714,-0.0012213099980726838,0.0027990643866360188,1],[7,-1.8150986269560576e-10,-0.0015915741678327322,-0.9999987483024597,0,1,7.69743095929698e-8,-3.0402055872791323e-10,0,7.697469328604711e-8,-0.9999987483024597,0.0015915741678327322,0,-0.002713743830099702,-0.0009506093920208514,0.0027716041076928377,1],[7,-7.873639447097958e-7,-6.519635320501038e-8,-1,0,0.08185373991727829,-0.9966443777084351,5.288988691454222e-10,0,-0.9966443777084351,-0.08185373991727829,7.900583796072169e-7,0,0.0015626716194674373,0.0007490515126846731,0.0027741827070713043,1]],8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[11,"Skin-2",4144506546,["Root_M","Root_M/Spine1_M","Root_M/Spine1_M/Chest_M","Root_M/Spine1_M/Chest_M/Neck_M","Root_M/Spine1_M/Chest_M/Neck_M/Head_M","Root_M/Spine1_M/Chest_M/Scapula_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L","Root_M/Hip_L","Root_M/Hip_L/Knee_L"],[[[7,-1.6073266766851061e-16,-5.002625820273957e-16,1,0,0.9995050430297852,-0.031458914279937744,1.4491539940461042e-16,0,0.031458914279937744,0.9995050430297852,5.050714527667544e-16,0,-0.019512146711349487,0.0004364966880530119,-3.2884277806782753e-18,1],[7,-1.6051606546202993e-16,-4.955657313953114e-16,1,0,0.9981581568717957,-0.06066583842039108,1.3015651204319428e-16,0,0.06066583842039108,0.9981581568717957,5.043908088540763e-16,0,-0.024823229759931564,0.0011626967461779714,-3.024364845781441e-18,1],[7,-1.6073587051184242e-16,-5.003653906513687e-16,1,0,0.9995249509811401,-0.03081941418349743,1.4523855570887774e-16,0,0.03081941418349743,0.9995249509811401,5.05081511283003e-16,0,-0.02732432447373867,0.0003465543850325048,-1.9691652799332707e-18,1],[7,5.751306066253416e-17,-4.843061753670192e-16,1,0,0.9392595887184143,0.34320753812789917,1.1219782537462701e-16,0,-0.34320753812789917,0.9392595887184143,4.746281357303692e-16,0,-0.02801189385354519,-0.010852459818124771,-9.365741732283693e-18,1],[7,-1.6081226229577292e-16,-5.053215392444312e-16,1,0,1,-2.0489094865183688e-8,1.6081224906088311e-16,0,2.0489094865183688e-8,1,5.053215392444312e-16,0,-0.03196112811565399,0.00012439562124200165,-9.574726432503377e-18,1],[7,-0.9999274015426636,-0.000001486659016336489,-0.012051837518811226,0,0.0120518384501338,-0.00012334641360212117,-0.9999273419380188,0,-9.146007654567759e-16,-1,0.00012335537758190185,0,0.0028796999249607325,-0.0001089197612600401,0.028484230861067772,1],[7,-0.15891462564468384,-0.016919724643230438,-0.987147331237793,0,0.9815993309020996,0.10451140254735947,-0.1598128229379654,0,0.10587213933467865,-0.9943797588348389,5.446323392277463e-10,0,-0.02677895687520504,-0.0029642386361956596,0.011229886673390865,1],[7,-0.15826688706874847,0.022175027057528496,-0.987147331237793,0,0.977598249912262,-0.13697285950183868,-0.1598128229379654,0,-0.13875624537467957,-0.9903265833854675,5.44632006160839e-10,0,-0.02167670615017414,0.002370338188484311,0.011229886673390865,1],[7,-0.1337725818157196,0.0319434329867363,-0.9904971122741699,0,0.9809468388557434,-0.1378193348646164,-0.13692742586135864,0,-0.14088359475135803,-0.9899421334266663,-0.01289836224168539,0,-0.016554739326238632,0.0023029823787510395,0.010846441611647606,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,0.9993575811386108,0.03419242799282074,-0.01073656789958477,0,0.034194398671388626,-0.9994152188301086,2.2804104762017604e-15,0,-0.01896691881120205,-0.0005232313415035605,0.0027990643866360188,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,0.9948249459266663,0.10103511065244675,-0.01073656789958477,0,0.10104092955589294,-0.9948822855949402,2.2699371255671978e-15,0,-0.01038399152457714,-0.0012213099980726838,0.0027990643866360188,1]],8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[9,".bin",3857417360,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":47016,"length":4344,"count":1086,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":47016,"count":653,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5]]},"minPosition",8,[1,-0.00273256772197783,0.029378218576312065,-0.0009605669765733182],"maxPosition",8,[1,0.00273256772197783,0.034015607088804245,0.003367869183421135]]],-1],0,0,[],[],[]],[[[9,".bin",931528313,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":53424,"length":5952,"count":1488,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":53424,"count":742,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,5,6,7,8]]},"minPosition",8,[1,-0.011450636200606823,0.014783668331801891,-0.0029849016573280096],"maxPosition",8,[1,-0.003725849324837327,0.0316593274474144,0.0030465873423963785]]],-1],0,0,[],[],[]],[[[11,"Skin-3",3669129590,["Root_M","Root_M/Spine1_M","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L","Root_M/Hip_R","Root_M/Hip_R/Knee_R","Root_M/Hip_R/Knee_R/Ankle_R","Root_M/Hip_R/Knee_R/Ankle_R/Toes_R","Root_M/Hip_L","Root_M/Hip_L/Knee_L","Root_M/Hip_L/Knee_L/Ankle_L","Root_M/Hip_L/Knee_L/Ankle_L/Toes_L"],[[[7,-1.6073266766851061e-16,-5.002625820273957e-16,1,0,0.9995050430297852,-0.031458914279937744,1.4491539940461042e-16,0,0.031458914279937744,0.9995050430297852,5.050714527667544e-16,0,-0.019512146711349487,0.0004364966880530119,-3.2884277806782753e-18,1],[7,-1.6051606546202993e-16,-4.955657313953114e-16,1,0,0.9981581568717957,-0.06066583842039108,1.3015651204319428e-16,0,0.06066583842039108,0.9981581568717957,5.043908088540763e-16,0,-0.024823229759931564,0.0011626967461779714,-3.024364845781441e-18,1],[7,-0.15891462564468384,-0.016919724643230438,-0.987147331237793,0,0.9815993309020996,0.10451140254735947,-0.1598128229379654,0,0.10587213933467865,-0.9943797588348389,5.446323392277463e-10,0,-0.02677895687520504,-0.0029642386361956596,0.011229886673390865,1],[7,-0.15826688706874847,0.022175027057528496,-0.987147331237793,0,0.977598249912262,-0.13697285950183868,-0.1598128229379654,0,-0.13875624537467957,-0.9903265833854675,5.44632006160839e-10,0,-0.02167670615017414,0.002370338188484311,0.011229886673390865,1],[7,-0.1337725818157196,0.0319434329867363,-0.9904971122741699,0,0.9809468388557434,-0.1378193348646164,-0.13692742586135864,0,-0.14088359475135803,-0.9899421334266663,-0.01289836224168539,0,-0.016554739326238632,0.0023029823787510395,0.010846441611647606,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,-0.9993575811386108,-0.03419242799282074,0.01073656789958477,0,-0.034194398671388626,0.9994152188301086,-2.2132606511404695e-11,0,0.01896691881120205,0.0005232312832958996,-0.0027990643866360188,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,-0.9948249459266663,-0.10103510320186615,0.01073656789958477,0,-0.10104092955589294,0.9948822855949402,-2.213251457106047e-11,0,0.01038399152457714,0.0012213099980726838,-0.0027990643866360188,1],[7,-1.8117590760979851e-10,-0.0015915741678327322,-0.9999987483024597,0,-1,-7.552468872518148e-8,3.013794214190568e-10,0,-7.552507241825879e-8,0.9999987483024597,-0.0015915741678327322,0,0.002713743830099702,0.0009506093338131905,-0.0027716041076928377,1],[7,7.942823003759258e-7,6.541559827155652e-8,-1,0,-0.08185373991727829,0.9966443777084351,1.8111570576628822e-10,0,0.9966443777084351,0.08185373991727829,7.96971448835393e-7,0,-0.0015626671956852078,-0.0007490511634387076,-0.0027741852682083845,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,0.9993575811386108,0.03419242799282074,-0.01073656789958477,0,0.034194398671388626,-0.9994152188301086,2.2804104762017604e-15,0,-0.01896691881120205,-0.0005232313415035605,0.0027990643866360188,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,0.9948249459266663,0.10103511065244675,-0.01073656789958477,0,0.10104092955589294,-0.9948822855949402,2.2699371255671978e-15,0,-0.01038399152457714,-0.0012213099980726838,0.0027990643866360188,1],[7,-1.8150986269560576e-10,-0.0015915741678327322,-0.9999987483024597,0,1,7.69743095929698e-8,-3.0402055872791323e-10,0,7.697469328604711e-8,-0.9999987483024597,0.0015915741678327322,0,-0.002713743830099702,-0.0009506093920208514,0.0027716041076928377,1],[7,-7.873639447097958e-7,-6.519635320501038e-8,-1,0,0.08185373991727829,-0.9966443777084351,5.288988691454222e-10,0,-0.9966443777084351,-0.08185373991727829,7.900583796072169e-7,0,0.0015626716194674373,0.0007490515126846731,0.0027741827070713043,1]],8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[9,".bin",3090674825,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":171144,"length":20664,"count":5166,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":171144,"count":2377,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,9,13,14,15,16]]},"minPosition",8,[1,-0.005051802843809128,0.016844069585204124,-0.005326585378497839],"maxPosition",8,[1,0.005051802843809128,0.03112988919019699,0.004788977559655905]]],-1],0,0,[],[],[]],[[[11,"Skin-1",2603301272,["Root_M/Spine1_M","Root_M/Spine1_M/Chest_M","Root_M/Spine1_M/Chest_M/Neck_M","Root_M/Spine1_M/Chest_M/Neck_M/Head_M","Root_M/Spine1_M/Chest_M/Scapula_R","Root_M/Spine1_M/Chest_M/Scapula_L"],[[[7,-1.6051606546202993e-16,-4.955657313953114e-16,1,0,0.9981581568717957,-0.06066583842039108,1.3015651204319428e-16,0,0.06066583842039108,0.9981581568717957,5.043908088540763e-16,0,-0.024823229759931564,0.0011626967461779714,-3.024364845781441e-18,1],[7,-1.6073587051184242e-16,-5.003653906513687e-16,1,0,0.9995249509811401,-0.03081941418349743,1.4523855570887774e-16,0,0.03081941418349743,0.9995249509811401,5.05081511283003e-16,0,-0.02732432447373867,0.0003465543850325048,-1.9691652799332707e-18,1],[7,5.751306066253416e-17,-4.843061753670192e-16,1,0,0.9392595887184143,0.34320753812789917,1.1219782537462701e-16,0,-0.34320753812789917,0.9392595887184143,4.746281357303692e-16,0,-0.02801189385354519,-0.010852459818124771,-9.365741732283693e-18,1],[7,-1.6081226229577292e-16,-5.053215392444312e-16,1,0,1,-2.0489094865183688e-8,1.6081224906088311e-16,0,2.0489094865183688e-8,1,5.053215392444312e-16,0,-0.03196112811565399,0.00012439562124200165,-9.574726432503377e-18,1],[7,-0.9999274015426636,-0.0000014861826684864354,-0.012051843106746674,0,-0.012051843106746674,0.00012334794155322015,0.9999273419380188,0,4.953271126595382e-10,1,-0.00012335690553300083,0,-0.002503913827240467,0.00010892027785303071,-0.028479700908064842,1],[7,-0.9999274015426636,-0.000001486659016336489,-0.012051837518811226,0,0.0120518384501338,-0.00012334641360212117,-0.9999273419380188,0,-9.146007654567759e-16,-1,0.00012335537758190185,0,0.0028796999249607325,-0.0001089197612600401,0.028484230861067772,1]],8,8,8,8,8,8]]],0,0,[],[],[]],[[[9,".bin",898411461,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":121536,"length":13656,"count":3414,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":121536,"count":1688,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,5,9,10,11,12]]},"minPosition",8,[1,0.0003719171218108386,-2.770612539393369e-8,-0.0028996625915169716],"maxPosition",8,[1,0.008162803947925568,0.019594445824623108,0.004642312414944172]]],-1],0,0,[],[],[]],[[[38,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true},{},{}],[[[{},"mainColor",8,[4,4294933205]],{},{}],11,0,0]]],0,0,[0],[5],[2]],[[[125,"Evolution","\nEvolution.png\nsize: 512, 512\nformat: RGBA8888\nfilter: Linear, Linear\nrepeat: none\nbang1\n  rotate: false\n  xy: 499, 501\n  size: 11, 9\n  orig: 28, 28\n  offset: 8, 10\n  index: -1\nbang2\n  rotate: false\n  xy: 472, 474\n  size: 16, 13\n  orig: 28, 28\n  offset: 6, 8\n  index: -1\nbang3\n  rotate: true\n  xy: 214, 416\n  size: 22, 18\n  orig: 28, 28\n  offset: 3, 5\n  index: -1\nbang4\n  rotate: false\n  xy: 2, 2\n  size: 24, 20\n  orig: 28, 28\n  offset: 1, 4\n  index: -1\nbang5\n  rotate: false\n  xy: 472, 489\n  size: 25, 21\n  orig: 28, 28\n  offset: 1, 4\n  index: -1\nlight2\n  rotate: false\n  xy: 28, 2\n  size: 20, 20\n  orig: 26, 26\n  offset: 3, 3\n  index: -1\nlighting5_00\n  rotate: false\n  xy: 2, 81\n  size: 48, 50\n  orig: 60, 60\n  offset: 7, 5\n  index: -1\nlighting_32\n  rotate: false\n  xy: 2, 292\n  size: 106, 71\n  orig: 134, 74\n  offset: 3, 2\n  index: -1\nlighting_34\n  rotate: false\n  xy: 2, 438\n  size: 117, 72\n  orig: 134, 74\n  offset: 3, 1\n  index: -1\nlighting_36\n  rotate: false\n  xy: 2, 365\n  size: 117, 71\n  orig: 134, 74\n  offset: 3, 2\n  index: -1\nlighting_38\n  rotate: false\n  xy: 121, 440\n  size: 110, 70\n  orig: 134, 74\n  offset: 3, 2\n  index: -1\nrock_34\n  rotate: false\n  xy: 77, 200\n  size: 12, 21\n  orig: 22, 23\n  offset: 5, 1\n  index: -1\nrock_35\n  rotate: true\n  xy: 80, 223\n  size: 13, 26\n  orig: 25, 29\n  offset: 6, 1\n  index: -1\nwind_35\n  rotate: true\n  xy: 80, 238\n  size: 52, 45\n  orig: 134, 74\n  offset: 18, 26\n  index: -1\nwind_37\n  rotate: false\n  xy: 121, 378\n  size: 91, 60\n  orig: 134, 74\n  offset: 18, 7\n  index: -1\nwind_39\n  rotate: false\n  xy: 233, 449\n  size: 84, 61\n  orig: 134, 74\n  offset: 25, 9\n  index: -1\nwind_41\n  rotate: false\n  xy: 2, 223\n  size: 76, 67\n  orig: 134, 74\n  offset: 29, 3\n  index: -1\nwind_43\n  rotate: false\n  xy: 319, 459\n  size: 73, 51\n  orig: 134, 74\n  offset: 29, 7\n  index: -1\nwind_45\n  rotate: false\n  xy: 2, 176\n  size: 73, 45\n  orig: 134, 74\n  offset: 28, 13\n  index: -1\nwind_47\n  rotate: true\n  xy: 2, 24\n  size: 55, 43\n  orig: 134, 74\n  offset: 45, 15\n  index: -1\nwind_49\n  rotate: false\n  xy: 2, 133\n  size: 62, 41\n  orig: 134, 74\n  offset: 41, 15\n  index: -1\nwind_51\n  rotate: false\n  xy: 394, 473\n  size: 76, 37\n  orig: 134, 74\n  offset: 34, 19\n  index: -1\nwind_53\n  rotate: false\n  xy: 394, 454\n  size: 73, 17\n  orig: 134, 74\n  offset: 36, 29\n  index: -1\n",["Evolution.png"],{"skeleton":{"hash":"taMTqKe017U","spine":"3.8-from-4.0-from-4.1.24","images":"","audio":"C:/Users/dasmonstrum/Desktop/Source Mirror/Mirror/Spine Repack/Fantasy Revelation/Repack/Effect/40015"},"bones":[{"name":"root"},{"name":"1","parent":"root"},{"name":"last","parent":"1"},{"name":"impact02","parent":"last","x":-3.78,"y":39.08},{"name":"01","parent":"last","x":9.32,"y":33.77},{"name":"impact01","parent":"last","x":-3.78,"y":39.08},{"name":"rock1","parent":"last","x":-16.6,"y":24.64},{"name":"rock2","parent":"last","x":-16.6,"y":24.64},{"name":"rock3","parent":"last","x":-16.6,"y":24.64},{"name":"rock4","parent":"last","x":-16.6,"y":24.64},{"name":"rock5","parent":"last","x":-16.6,"y":24.64},{"name":"rock6","parent":"last","x":-16.6,"y":24.64},{"name":"2","parent":"root"},{"name":"wind","parent":"2","length":134.07,"x":-26.01},{"name":"bang","parent":"root","scaleX":4,"scaleY":4},{"name":"bone","parent":"root"}],"slots":[{"name":"lighting5_00","bone":"impact01","blend":"additive"},{"name":"lighting","bone":"01","color":"4aa1ffff","blend":"additive"},{"name":"lighting5_0","bone":"impact02","blend":"additive"},{"name":"rock_34","bone":"rock1"},{"name":"rock_35","bone":"rock2"},{"name":"rock_36","bone":"rock3"},{"name":"rock_37","bone":"rock4"},{"name":"rock_38","bone":"rock5"},{"name":"rock_39","bone":"rock6"},{"name":"wind","bone":"wind","color":"90fcffff","blend":"additive"},{"name":"bang1","bone":"bang","color":"4aa1ffff","blend":"additive"},{"name":"light2","bone":"bone","color":"4aa1ffff","blend":"additive"}],"skins":[{"name":"default","attachments":{"bang1":{"bang1":{"width":140,"height":140},"bang2":{"width":140,"height":140},"bang3":{"width":140,"height":140},"bang4":{"width":140,"height":140},"bang5":{"width":140,"height":140}},"light2":{"light2":{"scaleX":3,"scaleY":3,"width":128,"height":128}},"lighting":{"lighting_32":{"x":-2.6,"y":4.02,"width":672,"height":370},"lighting_34":{"x":-2.6,"y":4.02,"width":672,"height":370},"lighting_36":{"x":-2.6,"y":4.02,"width":672,"height":370},"lighting_38":{"x":-2.6,"y":4.02,"width":672,"height":370}},"lighting5_0":{"lighting5_00":{"width":300,"height":300}},"lighting5_00":{"lighting5_00":{"width":300,"height":300}},"rock_34":{"rock_34":{"width":112,"height":113},"rock_35":{"width":123,"height":145}},"rock_35":{"rock_34":{"width":112,"height":113},"rock_35":{"width":123,"height":145}},"rock_36":{"rock_34":{"width":112,"height":113},"rock_35":{"width":123,"height":145}},"rock_37":{"rock_34":{"width":112,"height":113},"rock_35":{"width":123,"height":145}},"rock_38":{"rock_34":{"width":112,"height":113},"rock_35":{"width":123,"height":145}},"rock_39":{"rock_34":{"width":112,"height":113},"rock_35":{"width":123,"height":145}},"wind":{"wind_35":{"width":672,"height":370},"wind_37":{"width":672,"height":370},"wind_39":{"width":672,"height":370},"wind_41":{"width":672,"height":370},"wind_43":{"width":672,"height":370},"wind_45":{"width":672,"height":370},"wind_47":{"width":672,"height":370},"wind_49":{"width":672,"height":370},"wind_51":{"width":672,"height":370},"wind_53":{"width":672,"height":370}}}}],"animations":{"Evo02":{"slots":{"lighting":{"attachment":[{"time":0.7,"name":"lighting_32"},{"time":0.7667,"name":"lighting_34"},{"time":0.8333,"name":null},{"time":0.9,"name":null}]},"lighting5_00":{"color":[{"time":0.6667,"color":"72e2ffff"}],"attachment":[{"time":0.6667,"name":"lighting5_00"},{"time":0.8,"name":null}]},"wind":{"color":[{"color":"4aa1ffff"}],"attachment":[{"name":"wind_35"},{"time":0.0667,"name":"wind_37"},{"time":0.1333,"name":"wind_39"},{"time":0.2,"name":"wind_41"},{"time":0.2667,"name":"wind_43"},{"time":0.3333,"name":"wind_45"},{"time":0.4,"name":"wind_47"},{"time":0.4667,"name":"wind_49"},{"time":0.5333,"name":"wind_51"},{"time":0.6,"name":"wind_53"},{"time":0.6667,"name":null}]}},"bones":{"wind":{"translate":[{"x":-65.91,"y":-18.27}],"scale":[{"x":3.5,"y":3.5}]},"impact01":{"translate":[{"time":0.6667,"x":3.78,"y":-39.08}],"scale":[{"time":0.6667,"x":6.143,"y":6.143},{"time":0.8,"x":10,"y":10}]},"01":{"translate":[{"time":0.7,"x":-9.32,"y":-33.77}],"scale":[{"time":0.7,"x":2.459,"y":2.459},{"time":0.8333,"x":8,"y":8}]}}}}},[0]]],0,0,[0],[-1],[60]],[[[17,"sfx_lose",".mp3",1.157333],-1],0,0,[],[],[]],[[{"base":"2,2,0,0,2,0","rgbe":false,"mipmaps":[{"front":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@e9a6d","back":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@40c10","left":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@8fd34","right":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@74afd","top":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@bb97f","bottom":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@7d38f"}]}],[17],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[2],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[2],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[2],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[2],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[2],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[2],0,[],[],[]],[[{"name":"default_sprite_splash","rect":{"x":0,"y":0,"width":2,"height":2},"offset":{"x":0,"y":0},"originalSize":{"width":2,"height":2},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[4],0,[0],[13],[61]],[[[17,"Boom Long",".mp3",4.493061],-1],0,0,[],[],[]],[[[59,"Merge FX"],[83,"Merge FX",[-3],[-2],[49,"872CzlWxdOdalxTtqSnFF/",-1,0],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[84,"Cube",1,[-4],[49,"09fUltKsZFvJSq2PnikuMi",1,0]],[104,1,false,false,2,[50,"c7bOimb2dLyq9O1ar9HEBQ"],[[0,null],6,0],[67,[4,4294939182]],[41,3,1,2],[2],[2],[41,3,30,60],[2],[2],[51,3,4.71238898038469],[2],[41,3,0.3,1],[2],[2],[2],[[20,[10,15]]],[107,[19]],[112,true,0,[10,1]],[70,[2],[2],[2],[2]],[53,[2],[2],[2],[10,1]],[54,[2],[2],[2]],[115,true,0.8,[2],[2],[2],[106,1,30,[29,[0,1],[[119,0.04444444444444444,1,1],[74,-0.562962962962963,-0.6074074074074074,1,-0.6074074074074074,1]]]]],[116,true,true,[10,0.7853981633974483],[10,0.7853981633974483],[10,0.8552113334772213]],[73,true,3,3,2,[2],[51,3,1]],[56,[10,1],[2],[19],[19],-5],[123,0,1]],[105,true,true,1,false,false,1.280170500278473,1.280170500278473,6.4008525013923645,1,[50,"dd75xDNvFL5JL1FFRSWiHm"],[[2,null],6,0],[67,[4,4294940784]],[10,8],[10,8],[10,40],[2],[10,3.141592653589793],[2],[10,6.283185307179586],[2],[10,0.5],[2],[10,1],[2],[[20,[2]]],[68,true,[66,1,[109,[[69,0.5]],[[57,0,0.006696428571428571],[57,255,0.5],[57,0,0.9977678571428571]]]]],[113,0,[10,1]],[114,true,true,[2],[31,1,[29,[0,1],[[75,2,1,-0.04735883424408022,1,-0.04735883424408022,1],[76,2,-2.8888888888888875,1,-2.8888888888888875,1]]]],[31,1,[29,[0,1],[[75,2,1,-0.04735883424408022,1,-0.04735883424408022,1],[76,2,-2.8888888888888875,1,-2.8888888888888875,1]]]],[31,1,[29,[0,0.3076923076923077,1],[[120,2,0.4925925925925926,-1.2037037037037035,-1.2037037037037035],[121,2],[55,2,1]]]]],[53,[2],[2],[2],[10,1]],[54,[2],[2],[2]],[71,[2],[2],[2],[2]],[72,[2],[2],[2]],[117,[31,1,[29,[0,1],[[55,2,1],[55,2,1]]]],[2]],[56,[10,1],[2],[19],[19],-6],[124,4,0,3,4]]],0,[0,9,1,0,-1,4,0,-1,2,0,-1,3,0,15,3,0,15,4,0,17,1,6],[0,0,0,0,0],[-1,16,-1,1,16],[62,46,63,64,45]],[[{"name":"logo","rect":{"x":0,"y":0,"width":453,"height":90},"offset":{"x":0,"y":0},"originalSize":{"width":453,"height":90},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[4],0,[0],[13],[65]],[[[25,"1",[{"priority":129,"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true,"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[7,5],[66,2]],[[[11,"Skin-4",1168153290,["Root_M/Hip_L/Knee_L/Ankle_L/Toes_L","Root_M/Hip_L/Knee_L/Ankle_L","Root_M/Hip_L/Knee_L","Root_M/Hip_L","Root_M/Hip_R/Knee_R/Ankle_R/Toes_R","Root_M/Hip_R/Knee_R/Ankle_R","Root_M/Hip_R/Knee_R","Root_M/Hip_R","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L","Root_M/Spine1_M/Chest_M/Scapula_L","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R","Root_M/Spine1_M/Chest_M/Scapula_R","Root_M/Spine1_M/Chest_M/Neck_M/Head_M","Root_M/Spine1_M/Chest_M/Neck_M","Root_M/Spine1_M/Chest_M","Root_M/Spine1_M","Root_M"],[[[7,-7.873639447097958e-7,-6.519635320501038e-8,-1,0,0.08185373991727829,-0.9966443777084351,5.288988691454222e-10,0,-0.9966443777084351,-0.08185373991727829,7.900583796072169e-7,0,0.0015626716194674373,0.0007490515126846731,0.0027741827070713043,1],[7,-1.8150986269560576e-10,-0.0015915741678327322,-0.9999987483024597,0,1,7.69743095929698e-8,-3.0402055872791323e-10,0,7.697469328604711e-8,-0.9999987483024597,0.0015915741678327322,0,-0.002713743830099702,-0.0009506093920208514,0.0027716041076928377,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,0.9948249459266663,0.10103511065244675,-0.01073656789958477,0,0.10104092955589294,-0.9948822855949402,2.2699371255671978e-15,0,-0.01038399152457714,-0.0012213099980726838,0.0027990643866360188,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,0.9993575811386108,0.03419242799282074,-0.01073656789958477,0,0.034194398671388626,-0.9994152188301086,2.2804104762017604e-15,0,-0.01896691881120205,-0.0005232313415035605,0.0027990643866360188,1],[7,7.942823003759258e-7,6.541559827155652e-8,-1,0,-0.08185373991727829,0.9966443777084351,1.8111570576628822e-10,0,0.9966443777084351,0.08185373991727829,7.96971448835393e-7,0,-0.0015626671956852078,-0.0007490511634387076,-0.0027741852682083845,1],[7,-1.8117590760979851e-10,-0.0015915741678327322,-0.9999987483024597,0,-1,-7.552468872518148e-8,3.013794214190568e-10,0,-7.552507241825879e-8,0.9999987483024597,-0.0015915741678327322,0,0.002713743830099702,0.0009506093338131905,-0.0027716041076928377,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,-0.9948249459266663,-0.10103510320186615,0.01073656789958477,0,-0.10104092955589294,0.9948822855949402,-2.213251457106047e-11,0,0.01038399152457714,0.0012213099980726838,-0.0027990643866360188,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,-0.9993575811386108,-0.03419242799282074,0.01073656789958477,0,-0.034194398671388626,0.9994152188301086,-2.2132606511404695e-11,0,0.01896691881120205,0.0005232312832958996,-0.0027990643866360188,1],[7,-0.003217601217329502,0.013486070558428764,-0.9999038577079773,0,0.9900209307670593,-0.14082854986190796,-0.005085205193608999,0,-0.14088359475135803,-0.9899421334266663,-0.01289836224168539,0,-0.01772109419107437,0.0025276578962802887,0.006342135835438967,1],[7,-0.027939576655626297,0.003914658445864916,-0.9996019601821899,0,0.9899323582649231,-0.13870102167129517,-0.02821248769760132,0,-0.13875624537467957,-0.9903265833854675,5.44632006160839e-10,0,-0.022954469546675682,0.0025493649300187826,0.006753850262612104,1],[7,-0.028053926303982735,-0.0029869170393794775,-0.9996019601821899,0,0.9939839243888855,0.10582999885082245,-0.02821248769760132,0,0.10587213933467865,-0.9943797588348389,5.446323392277463e-10,0,-0.028061948716640472,-0.0031008420046418905,0.006753850262612104,1],[7,-0.9999274015426636,-0.000001486659016336489,-0.012051837518811226,0,0.0120518384501338,-0.00012334641360212117,-0.9999273419380188,0,-9.146007654567759e-16,-1,0.00012335537758190185,0,0.0026569380424916744,-0.00010892009595409036,0.02848154492676258,1],[7,-0.003217607969418168,0.013486023992300034,-0.9999038577079773,0,-0.9900209307670593,0.14082854986190796,0.005085205193608999,0,0.14088359475135803,0.9899421334266663,0.01289831567555666,0,0.01772116683423519,-0.0025277347303926945,-0.006337270140647888,1],[7,-0.027939582243561745,0.003914611879736185,-0.9996019601821899,0,-0.9899323582649231,0.13870102167129517,0.02821248769760132,0,0.13875624537467957,0.9903265833854675,-4.755057858574219e-8,0,0.022954663261771202,-0.002549394965171814,-0.00674898736178875,1],[7,-0.028053922578692436,-0.0029869636055082083,-0.9996019601821899,0,-0.9939839243888855,-0.10582999140024185,0.02821248769760132,0,-0.10587213933467865,0.9943797588348389,-4.755057858574219e-8,0,0.028062142431735992,0.0031008596997708082,-0.00674898736178875,1],[7,-0.9999274015426636,-0.0000014861826684864354,-0.012051843106746674,0,-0.012051843106746674,0.00012334794155322015,0.9999273419380188,0,4.953271126595382e-10,1,-0.00012335690553300083,0,-0.0026569380424916744,0.00010892005229834467,-0.02848154492676258,1],[7,-1.6081226229577292e-16,-5.053215392444312e-16,1,0,1,-2.0489094865183688e-8,1.6081224906088311e-16,0,2.0489094865183688e-8,1,5.053215392444312e-16,0,-0.03196112811565399,0.00012439562124200165,-9.574726432503377e-18,1],[7,5.751306066253416e-17,-4.843061753670192e-16,1,0,0.9392595887184143,0.34320753812789917,1.1219782537462701e-16,0,-0.34320753812789917,0.9392595887184143,4.746281357303692e-16,0,-0.02801189385354519,-0.010852459818124771,-9.365741732283693e-18,1],[7,-1.6073587051184242e-16,-5.003653906513687e-16,1,0,0.9995249509811401,-0.03081941418349743,1.4523855570887774e-16,0,0.03081941418349743,0.9995249509811401,5.05081511283003e-16,0,-0.02732432447373867,0.0003465543850325048,-1.9691652799332707e-18,1],[7,-1.6051606546202993e-16,-4.955657313953114e-16,1,0,0.9981581568717957,-0.06066583842039108,1.3015651204319428e-16,0,0.06066583842039108,0.9981581568717957,5.043908088540763e-16,0,-0.024823229759931564,0.0011626967461779714,-3.024364845781441e-18,1],[7,-1.6073266766851061e-16,-5.002625820273957e-16,1,0,0.9995050430297852,-0.031458914279937744,1.4491539940461042e-16,0,0.031458914279937744,0.9995050430297852,5.050714527667544e-16,0,-0.019512146711349487,0.0004364966880530119,-3.2884277806782753e-18,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[9,".bin",2962585139,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":2448,"length":240,"count":60,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":2448,"count":34,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,13]]},"minPosition",8,[1,-0.008023867383599281,0.010855235159397125,-0.0010978318750858307],"maxPosition",8,[1,-0.00751897506415844,0.021163325756788254,0.0007600172539241612]]],-1],0,0,[],[],[]],[[[11,"Skin-0",1168153290,["Root_M/Hip_L/Knee_L/Ankle_L/Toes_L","Root_M/Hip_L/Knee_L/Ankle_L","Root_M/Hip_L/Knee_L","Root_M/Hip_L","Root_M/Hip_R/Knee_R/Ankle_R/Toes_R","Root_M/Hip_R/Knee_R/Ankle_R","Root_M/Hip_R/Knee_R","Root_M/Hip_R","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L","Root_M/Spine1_M/Chest_M/Scapula_L","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R","Root_M/Spine1_M/Chest_M/Scapula_R","Root_M/Spine1_M/Chest_M/Neck_M/Head_M","Root_M/Spine1_M/Chest_M/Neck_M","Root_M/Spine1_M/Chest_M","Root_M/Spine1_M","Root_M"],[[[7,-7.873639447097958e-7,-6.519635320501038e-8,-1,0,0.08185373991727829,-0.9966443777084351,5.288988691454222e-10,0,-0.9966443777084351,-0.08185373991727829,7.900583796072169e-7,0,0.0015626716194674373,0.0007490515126846731,0.0027741827070713043,1],[7,-1.8150986269560576e-10,-0.0015915741678327322,-0.9999987483024597,0,1,7.69743095929698e-8,-3.0402055872791323e-10,0,7.697469328604711e-8,-0.9999987483024597,0.0015915741678327322,0,-0.002713743830099702,-0.0009506093920208514,0.0027716041076928377,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,0.9948249459266663,0.10103511065244675,-0.01073656789958477,0,0.10104092955589294,-0.9948822855949402,2.2699371255671978e-15,0,-0.01038399152457714,-0.0012213099980726838,0.0027990643866360188,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,0.9993575811386108,0.03419242799282074,-0.01073656789958477,0,0.034194398671388626,-0.9994152188301086,2.2804104762017604e-15,0,-0.01896691881120205,-0.0005232313415035605,0.0027990643866360188,1],[7,7.942823003759258e-7,6.541559827155652e-8,-1,0,-0.08185373991727829,0.9966443777084351,1.8111570576628822e-10,0,0.9966443777084351,0.08185373991727829,7.96971448835393e-7,0,-0.0015626671956852078,-0.0007490511634387076,-0.0027741852682083845,1],[7,-1.8117590760979851e-10,-0.0015915741678327322,-0.9999987483024597,0,-1,-7.552468872518148e-8,3.013794214190568e-10,0,-7.552507241825879e-8,0.9999987483024597,-0.0015915741678327322,0,0.002713743830099702,0.0009506093338131905,-0.0027716041076928377,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,-0.9948249459266663,-0.10103510320186615,0.01073656789958477,0,-0.10104092955589294,0.9948822855949402,-2.213251457106047e-11,0,0.01038399152457714,0.0012213099980726838,-0.0027990643866360188,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,-0.9993575811386108,-0.03419242799282074,0.01073656789958477,0,-0.034194398671388626,0.9994152188301086,-2.2132606511404695e-11,0,0.01896691881120205,0.0005232312832958996,-0.0027990643866360188,1],[7,-0.003217601217329502,0.013486070558428764,-0.9999038577079773,0,0.9900209307670593,-0.14082854986190796,-0.005085205193608999,0,-0.14088359475135803,-0.9899421334266663,-0.01289836224168539,0,-0.01772109419107437,0.0025276578962802887,0.006342135835438967,1],[7,-0.027939576655626297,0.003914658445864916,-0.9996019601821899,0,0.9899323582649231,-0.13870102167129517,-0.02821248769760132,0,-0.13875624537467957,-0.9903265833854675,5.44632006160839e-10,0,-0.022954469546675682,0.0025493649300187826,0.006753850262612104,1],[7,-0.028053926303982735,-0.0029869170393794775,-0.9996019601821899,0,0.9939839243888855,0.10582999885082245,-0.02821248769760132,0,0.10587213933467865,-0.9943797588348389,5.446323392277463e-10,0,-0.028061948716640472,-0.0031008420046418905,0.006753850262612104,1],[7,-0.9999274015426636,-0.000001486659016336489,-0.012051837518811226,0,0.0120518384501338,-0.00012334641360212117,-0.9999273419380188,0,-9.146007654567759e-16,-1,0.00012335537758190185,0,0.0026569380424916744,-0.00010892009595409036,0.02848154492676258,1],[7,-0.003217607969418168,0.013486023992300034,-0.9999038577079773,0,-0.9900209307670593,0.14082854986190796,0.005085205193608999,0,0.14088359475135803,0.9899421334266663,0.01289831567555666,0,0.01772116683423519,-0.0025277347303926945,-0.006337270140647888,1],[7,-0.027939582243561745,0.003914611879736185,-0.9996019601821899,0,-0.9899323582649231,0.13870102167129517,0.02821248769760132,0,0.13875624537467957,0.9903265833854675,-4.755057858574219e-8,0,0.022954663261771202,-0.002549394965171814,-0.00674898736178875,1],[7,-0.028053922578692436,-0.0029869636055082083,-0.9996019601821899,0,-0.9939839243888855,-0.10582999140024185,0.02821248769760132,0,-0.10587213933467865,0.9943797588348389,-4.755057858574219e-8,0,0.028062142431735992,0.0031008596997708082,-0.00674898736178875,1],[7,-0.9999274015426636,-0.0000014861826684864354,-0.012051843106746674,0,-0.012051843106746674,0.00012334794155322015,0.9999273419380188,0,4.953271126595382e-10,1,-0.00012335690553300083,0,-0.0026569380424916744,0.00010892005229834467,-0.02848154492676258,1],[7,-1.6081226229577292e-16,-5.053215392444312e-16,1,0,1,-2.0489094865183688e-8,1.6081224906088311e-16,0,2.0489094865183688e-8,1,5.053215392444312e-16,0,-0.03196112811565399,0.00012439562124200165,-9.574726432503377e-18,1],[7,5.751306066253416e-17,-4.843061753670192e-16,1,0,0.9392595887184143,0.34320753812789917,1.1219782537462701e-16,0,-0.34320753812789917,0.9392595887184143,4.746281357303692e-16,0,-0.02801189385354519,-0.010852459818124771,-9.365741732283693e-18,1],[7,-1.6073587051184242e-16,-5.003653906513687e-16,1,0,0.9995249509811401,-0.03081941418349743,1.4523855570887774e-16,0,0.03081941418349743,0.9995249509811401,5.05081511283003e-16,0,-0.02732432447373867,0.0003465543850325048,-1.9691652799332707e-18,1],[7,-1.6051606546202993e-16,-4.955657313953114e-16,1,0,0.9981581568717957,-0.06066583842039108,1.3015651204319428e-16,0,0.06066583842039108,0.9981581568717957,5.043908088540763e-16,0,-0.024823229759931564,0.0011626967461779714,-3.024364845781441e-18,1],[7,-1.6073266766851061e-16,-5.002625820273957e-16,1,0,0.9995050430297852,-0.031458914279937744,1.4491539940461042e-16,0,0.031458914279937744,0.9995050430297852,5.050714527667544e-16,0,-0.019512146711349487,0.0004364966880530119,-3.2884277806782753e-18,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[11,"Skin-5",1168153290,["Root_M/Hip_L/Knee_L/Ankle_L/Toes_L","Root_M/Hip_L/Knee_L/Ankle_L","Root_M/Hip_L/Knee_L","Root_M/Hip_L","Root_M/Hip_R/Knee_R/Ankle_R/Toes_R","Root_M/Hip_R/Knee_R/Ankle_R","Root_M/Hip_R/Knee_R","Root_M/Hip_R","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L","Root_M/Spine1_M/Chest_M/Scapula_L","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R","Root_M/Spine1_M/Chest_M/Scapula_R","Root_M/Spine1_M/Chest_M/Neck_M/Head_M","Root_M/Spine1_M/Chest_M/Neck_M","Root_M/Spine1_M/Chest_M","Root_M/Spine1_M","Root_M"],[[[7,-7.873639447097958e-7,-6.519635320501038e-8,-1,0,0.08185373991727829,-0.9966443777084351,5.288988691454222e-10,0,-0.9966443777084351,-0.08185373991727829,7.900583796072169e-7,0,0.0015626716194674373,0.0007490515126846731,0.0027741827070713043,1],[7,-1.8150986269560576e-10,-0.0015915741678327322,-0.9999987483024597,0,1,7.69743095929698e-8,-3.0402055872791323e-10,0,7.697469328604711e-8,-0.9999987483024597,0.0015915741678327322,0,-0.002713743830099702,-0.0009506093920208514,0.0027716041076928377,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,0.9948249459266663,0.10103511065244675,-0.01073656789958477,0,0.10104092955589294,-0.9948822855949402,2.2699371255671978e-15,0,-0.01038399152457714,-0.0012213099980726838,0.0027990643866360188,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,0.9993575811386108,0.03419242799282074,-0.01073656789958477,0,0.034194398671388626,-0.9994152188301086,2.2804104762017604e-15,0,-0.01896691881120205,-0.0005232313415035605,0.0027990643866360188,1],[7,7.942823003759258e-7,6.541559827155652e-8,-1,0,-0.08185373991727829,0.9966443777084351,1.8111570576628822e-10,0,0.9966443777084351,0.08185373991727829,7.96971448835393e-7,0,-0.0015626671956852078,-0.0007490511634387076,-0.0027741852682083845,1],[7,-1.8117590760979851e-10,-0.0015915741678327322,-0.9999987483024597,0,-1,-7.552468872518148e-8,3.013794214190568e-10,0,-7.552507241825879e-8,0.9999987483024597,-0.0015915741678327322,0,0.002713743830099702,0.0009506093338131905,-0.0027716041076928377,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,-0.9948249459266663,-0.10103510320186615,0.01073656789958477,0,-0.10104092955589294,0.9948822855949402,-2.213251457106047e-11,0,0.01038399152457714,0.0012213099980726838,-0.0027990643866360188,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,-0.9993575811386108,-0.03419242799282074,0.01073656789958477,0,-0.034194398671388626,0.9994152188301086,-2.2132606511404695e-11,0,0.01896691881120205,0.0005232312832958996,-0.0027990643866360188,1],[7,-0.003217601217329502,0.013486070558428764,-0.9999038577079773,0,0.9900209307670593,-0.14082854986190796,-0.005085205193608999,0,-0.14088359475135803,-0.9899421334266663,-0.01289836224168539,0,-0.01772109419107437,0.0025276578962802887,0.006342135835438967,1],[7,-0.027939576655626297,0.003914658445864916,-0.9996019601821899,0,0.9899323582649231,-0.13870102167129517,-0.02821248769760132,0,-0.13875624537467957,-0.9903265833854675,5.44632006160839e-10,0,-0.022954469546675682,0.0025493649300187826,0.006753850262612104,1],[7,-0.028053926303982735,-0.0029869170393794775,-0.9996019601821899,0,0.9939839243888855,0.10582999885082245,-0.02821248769760132,0,0.10587213933467865,-0.9943797588348389,5.446323392277463e-10,0,-0.028061948716640472,-0.0031008420046418905,0.006753850262612104,1],[7,-0.9999274015426636,-0.000001486659016336489,-0.012051837518811226,0,0.0120518384501338,-0.00012334641360212117,-0.9999273419380188,0,-9.146007654567759e-16,-1,0.00012335537758190185,0,0.0026569380424916744,-0.00010892009595409036,0.02848154492676258,1],[7,-0.003217607969418168,0.013486023992300034,-0.9999038577079773,0,-0.9900209307670593,0.14082854986190796,0.005085205193608999,0,0.14088359475135803,0.9899421334266663,0.01289831567555666,0,0.01772116683423519,-0.0025277347303926945,-0.006337270140647888,1],[7,-0.027939582243561745,0.003914611879736185,-0.9996019601821899,0,-0.9899323582649231,0.13870102167129517,0.02821248769760132,0,0.13875624537467957,0.9903265833854675,-4.755057858574219e-8,0,0.022954663261771202,-0.002549394965171814,-0.00674898736178875,1],[7,-0.028053922578692436,-0.0029869636055082083,-0.9996019601821899,0,-0.9939839243888855,-0.10582999140024185,0.02821248769760132,0,-0.10587213933467865,0.9943797588348389,-4.755057858574219e-8,0,0.028062142431735992,0.0031008596997708082,-0.00674898736178875,1],[7,-0.9999274015426636,-0.0000014861826684864354,-0.012051843106746674,0,-0.012051843106746674,0.00012334794155322015,0.9999273419380188,0,4.953271126595382e-10,1,-0.00012335690553300083,0,-0.0026569380424916744,0.00010892005229834467,-0.02848154492676258,1],[7,-1.6081226229577292e-16,-5.053215392444312e-16,1,0,1,-2.0489094865183688e-8,1.6081224906088311e-16,0,2.0489094865183688e-8,1,5.053215392444312e-16,0,-0.03196112811565399,0.00012439562124200165,-9.574726432503377e-18,1],[7,5.751306066253416e-17,-4.843061753670192e-16,1,0,0.9392595887184143,0.34320753812789917,1.1219782537462701e-16,0,-0.34320753812789917,0.9392595887184143,4.746281357303692e-16,0,-0.02801189385354519,-0.010852459818124771,-9.365741732283693e-18,1],[7,-1.6073587051184242e-16,-5.003653906513687e-16,1,0,0.9995249509811401,-0.03081941418349743,1.4523855570887774e-16,0,0.03081941418349743,0.9995249509811401,5.05081511283003e-16,0,-0.02732432447373867,0.0003465543850325048,-1.9691652799332707e-18,1],[7,-1.6051606546202993e-16,-4.955657313953114e-16,1,0,0.9981581568717957,-0.06066583842039108,1.3015651204319428e-16,0,0.06066583842039108,0.9981581568717957,5.043908088540763e-16,0,-0.024823229759931564,0.0011626967461779714,-3.024364845781441e-18,1],[7,-1.6073266766851061e-16,-5.002625820273957e-16,1,0,0.9995050430297852,-0.031458914279937744,1.4491539940461042e-16,0,0.031458914279937744,0.9995050430297852,5.050714527667544e-16,0,-0.019512146711349487,0.0004364966880530119,-3.2884277806782753e-18,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[9,".bin",1211064435,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":2448,"length":240,"count":60,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":2448,"count":34,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,9]]},"minPosition",8,[1,0.00751897506415844,0.010855235159397125,-0.0010978318750858307],"maxPosition",8,[1,0.008023867383599281,0.021163325756788254,0.0007600172539241612]]],-1],0,0,[],[],[]],[[[9,".bin",59570062,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":72936,"length":8244,"count":2061,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":72936,"count":1013,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,8,9,10,11]]},"minPosition",8,[1,0.0035619097761809826,0.015794306993484497,-0.0023642261512577534],"maxPosition",8,[1,0.009521526284515858,0.0326291024684906,0.0016573353204876184]]],-1],0,0,[],[],[]],[[[11,"Skin-2",1168153290,["Root_M/Hip_L/Knee_L/Ankle_L/Toes_L","Root_M/Hip_L/Knee_L/Ankle_L","Root_M/Hip_L/Knee_L","Root_M/Hip_L","Root_M/Hip_R/Knee_R/Ankle_R/Toes_R","Root_M/Hip_R/Knee_R/Ankle_R","Root_M/Hip_R/Knee_R","Root_M/Hip_R","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L","Root_M/Spine1_M/Chest_M/Scapula_L","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R","Root_M/Spine1_M/Chest_M/Scapula_R","Root_M/Spine1_M/Chest_M/Neck_M/Head_M","Root_M/Spine1_M/Chest_M/Neck_M","Root_M/Spine1_M/Chest_M","Root_M/Spine1_M","Root_M"],[[[7,-7.873639447097958e-7,-6.519635320501038e-8,-1,0,0.08185373991727829,-0.9966443777084351,5.288988691454222e-10,0,-0.9966443777084351,-0.08185373991727829,7.900583796072169e-7,0,0.0015626716194674373,0.0007490515126846731,0.0027741827070713043,1],[7,-1.8150986269560576e-10,-0.0015915741678327322,-0.9999987483024597,0,1,7.69743095929698e-8,-3.0402055872791323e-10,0,7.697469328604711e-8,-0.9999987483024597,0.0015915741678327322,0,-0.002713743830099702,-0.0009506093920208514,0.0027716041076928377,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,0.9948249459266663,0.10103511065244675,-0.01073656789958477,0,0.10104092955589294,-0.9948822855949402,2.2699371255671978e-15,0,-0.01038399152457714,-0.0012213099980726838,0.0027990643866360188,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,0.9993575811386108,0.03419242799282074,-0.01073656789958477,0,0.034194398671388626,-0.9994152188301086,2.2804104762017604e-15,0,-0.01896691881120205,-0.0005232313415035605,0.0027990643866360188,1],[7,7.942823003759258e-7,6.541559827155652e-8,-1,0,-0.08185373991727829,0.9966443777084351,1.8111570576628822e-10,0,0.9966443777084351,0.08185373991727829,7.96971448835393e-7,0,-0.0015626671956852078,-0.0007490511634387076,-0.0027741852682083845,1],[7,-1.8117590760979851e-10,-0.0015915741678327322,-0.9999987483024597,0,-1,-7.552468872518148e-8,3.013794214190568e-10,0,-7.552507241825879e-8,0.9999987483024597,-0.0015915741678327322,0,0.002713743830099702,0.0009506093338131905,-0.0027716041076928377,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,-0.9948249459266663,-0.10103510320186615,0.01073656789958477,0,-0.10104092955589294,0.9948822855949402,-2.213251457106047e-11,0,0.01038399152457714,0.0012213099980726838,-0.0027990643866360188,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,-0.9993575811386108,-0.03419242799282074,0.01073656789958477,0,-0.034194398671388626,0.9994152188301086,-2.2132606511404695e-11,0,0.01896691881120205,0.0005232312832958996,-0.0027990643866360188,1],[7,-0.003217601217329502,0.013486070558428764,-0.9999038577079773,0,0.9900209307670593,-0.14082854986190796,-0.005085205193608999,0,-0.14088359475135803,-0.9899421334266663,-0.01289836224168539,0,-0.01772109419107437,0.0025276578962802887,0.006342135835438967,1],[7,-0.027939576655626297,0.003914658445864916,-0.9996019601821899,0,0.9899323582649231,-0.13870102167129517,-0.02821248769760132,0,-0.13875624537467957,-0.9903265833854675,5.44632006160839e-10,0,-0.022954469546675682,0.0025493649300187826,0.006753850262612104,1],[7,-0.028053926303982735,-0.0029869170393794775,-0.9996019601821899,0,0.9939839243888855,0.10582999885082245,-0.02821248769760132,0,0.10587213933467865,-0.9943797588348389,5.446323392277463e-10,0,-0.028061948716640472,-0.0031008420046418905,0.006753850262612104,1],[7,-0.9999274015426636,-0.000001486659016336489,-0.012051837518811226,0,0.0120518384501338,-0.00012334641360212117,-0.9999273419380188,0,-9.146007654567759e-16,-1,0.00012335537758190185,0,0.0026569380424916744,-0.00010892009595409036,0.02848154492676258,1],[7,-0.003217607969418168,0.013486023992300034,-0.9999038577079773,0,-0.9900209307670593,0.14082854986190796,0.005085205193608999,0,0.14088359475135803,0.9899421334266663,0.01289831567555666,0,0.01772116683423519,-0.0025277347303926945,-0.006337270140647888,1],[7,-0.027939582243561745,0.003914611879736185,-0.9996019601821899,0,-0.9899323582649231,0.13870102167129517,0.02821248769760132,0,0.13875624537467957,0.9903265833854675,-4.755057858574219e-8,0,0.022954663261771202,-0.002549394965171814,-0.00674898736178875,1],[7,-0.028053922578692436,-0.0029869636055082083,-0.9996019601821899,0,-0.9939839243888855,-0.10582999140024185,0.02821248769760132,0,-0.10587213933467865,0.9943797588348389,-4.755057858574219e-8,0,0.028062142431735992,0.0031008596997708082,-0.00674898736178875,1],[7,-0.9999274015426636,-0.0000014861826684864354,-0.012051843106746674,0,-0.012051843106746674,0.00012334794155322015,0.9999273419380188,0,4.953271126595382e-10,1,-0.00012335690553300083,0,-0.0026569380424916744,0.00010892005229834467,-0.02848154492676258,1],[7,-1.6081226229577292e-16,-5.053215392444312e-16,1,0,1,-2.0489094865183688e-8,1.6081224906088311e-16,0,2.0489094865183688e-8,1,5.053215392444312e-16,0,-0.03196112811565399,0.00012439562124200165,-9.574726432503377e-18,1],[7,5.751306066253416e-17,-4.843061753670192e-16,1,0,0.9392595887184143,0.34320753812789917,1.1219782537462701e-16,0,-0.34320753812789917,0.9392595887184143,4.746281357303692e-16,0,-0.02801189385354519,-0.010852459818124771,-9.365741732283693e-18,1],[7,-1.6073587051184242e-16,-5.003653906513687e-16,1,0,0.9995249509811401,-0.03081941418349743,1.4523855570887774e-16,0,0.03081941418349743,0.9995249509811401,5.05081511283003e-16,0,-0.02732432447373867,0.0003465543850325048,-1.9691652799332707e-18,1],[7,-1.6051606546202993e-16,-4.955657313953114e-16,1,0,0.9981581568717957,-0.06066583842039108,1.3015651204319428e-16,0,0.06066583842039108,0.9981581568717957,5.043908088540763e-16,0,-0.024823229759931564,0.0011626967461779714,-3.024364845781441e-18,1],[7,-1.6073266766851061e-16,-5.002625820273957e-16,1,0,0.9995050430297852,-0.031458914279937744,1.4491539940461042e-16,0,0.031458914279937744,0.9995050430297852,5.050714527667544e-16,0,-0.019512146711349487,0.0004364966880530119,-3.2884277806782753e-18,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[11,"Skin-6",1168153290,["Root_M/Hip_L/Knee_L/Ankle_L/Toes_L","Root_M/Hip_L/Knee_L/Ankle_L","Root_M/Hip_L/Knee_L","Root_M/Hip_L","Root_M/Hip_R/Knee_R/Ankle_R/Toes_R","Root_M/Hip_R/Knee_R/Ankle_R","Root_M/Hip_R/Knee_R","Root_M/Hip_R","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L","Root_M/Spine1_M/Chest_M/Scapula_L","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R","Root_M/Spine1_M/Chest_M/Scapula_R","Root_M/Spine1_M/Chest_M/Neck_M/Head_M","Root_M/Spine1_M/Chest_M/Neck_M","Root_M/Spine1_M/Chest_M","Root_M/Spine1_M","Root_M"],[[[7,-7.873639447097958e-7,-6.519635320501038e-8,-1,0,0.08185373991727829,-0.9966443777084351,5.288988691454222e-10,0,-0.9966443777084351,-0.08185373991727829,7.900583796072169e-7,0,0.0015626716194674373,0.0007490515126846731,0.0027741827070713043,1],[7,-1.8150986269560576e-10,-0.0015915741678327322,-0.9999987483024597,0,1,7.69743095929698e-8,-3.0402055872791323e-10,0,7.697469328604711e-8,-0.9999987483024597,0.0015915741678327322,0,-0.002713743830099702,-0.0009506093920208514,0.0027716041076928377,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,0.9948249459266663,0.10103511065244675,-0.01073656789958477,0,0.10104092955589294,-0.9948822855949402,2.2699371255671978e-15,0,-0.01038399152457714,-0.0012213099980726838,0.0027990643866360188,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,0.9993575811386108,0.03419242799282074,-0.01073656789958477,0,0.034194398671388626,-0.9994152188301086,2.2804104762017604e-15,0,-0.01896691881120205,-0.0005232313415035605,0.0027990643866360188,1],[7,7.942823003759258e-7,6.541559827155652e-8,-1,0,-0.08185373991727829,0.9966443777084351,1.8111570576628822e-10,0,0.9966443777084351,0.08185373991727829,7.96971448835393e-7,0,-0.0015626671956852078,-0.0007490511634387076,-0.0027741852682083845,1],[7,-1.8117590760979851e-10,-0.0015915741678327322,-0.9999987483024597,0,-1,-7.552468872518148e-8,3.013794214190568e-10,0,-7.552507241825879e-8,0.9999987483024597,-0.0015915741678327322,0,0.002713743830099702,0.0009506093338131905,-0.0027716041076928377,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,-0.9948249459266663,-0.10103510320186615,0.01073656789958477,0,-0.10104092955589294,0.9948822855949402,-2.213251457106047e-11,0,0.01038399152457714,0.0012213099980726838,-0.0027990643866360188,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,-0.9993575811386108,-0.03419242799282074,0.01073656789958477,0,-0.034194398671388626,0.9994152188301086,-2.2132606511404695e-11,0,0.01896691881120205,0.0005232312832958996,-0.0027990643866360188,1],[7,-0.003217601217329502,0.013486070558428764,-0.9999038577079773,0,0.9900209307670593,-0.14082854986190796,-0.005085205193608999,0,-0.14088359475135803,-0.9899421334266663,-0.01289836224168539,0,-0.01772109419107437,0.0025276578962802887,0.006342135835438967,1],[7,-0.027939576655626297,0.003914658445864916,-0.9996019601821899,0,0.9899323582649231,-0.13870102167129517,-0.02821248769760132,0,-0.13875624537467957,-0.9903265833854675,5.44632006160839e-10,0,-0.022954469546675682,0.0025493649300187826,0.006753850262612104,1],[7,-0.028053926303982735,-0.0029869170393794775,-0.9996019601821899,0,0.9939839243888855,0.10582999885082245,-0.02821248769760132,0,0.10587213933467865,-0.9943797588348389,5.446323392277463e-10,0,-0.028061948716640472,-0.0031008420046418905,0.006753850262612104,1],[7,-0.9999274015426636,-0.000001486659016336489,-0.012051837518811226,0,0.0120518384501338,-0.00012334641360212117,-0.9999273419380188,0,-9.146007654567759e-16,-1,0.00012335537758190185,0,0.0026569380424916744,-0.00010892009595409036,0.02848154492676258,1],[7,-0.003217607969418168,0.013486023992300034,-0.9999038577079773,0,-0.9900209307670593,0.14082854986190796,0.005085205193608999,0,0.14088359475135803,0.9899421334266663,0.01289831567555666,0,0.01772116683423519,-0.0025277347303926945,-0.006337270140647888,1],[7,-0.027939582243561745,0.003914611879736185,-0.9996019601821899,0,-0.9899323582649231,0.13870102167129517,0.02821248769760132,0,0.13875624537467957,0.9903265833854675,-4.755057858574219e-8,0,0.022954663261771202,-0.002549394965171814,-0.00674898736178875,1],[7,-0.028053922578692436,-0.0029869636055082083,-0.9996019601821899,0,-0.9939839243888855,-0.10582999140024185,0.02821248769760132,0,-0.10587213933467865,0.9943797588348389,-4.755057858574219e-8,0,0.028062142431735992,0.0031008596997708082,-0.00674898736178875,1],[7,-0.9999274015426636,-0.0000014861826684864354,-0.012051843106746674,0,-0.012051843106746674,0.00012334794155322015,0.9999273419380188,0,4.953271126595382e-10,1,-0.00012335690553300083,0,-0.0026569380424916744,0.00010892005229834467,-0.02848154492676258,1],[7,-1.6081226229577292e-16,-5.053215392444312e-16,1,0,1,-2.0489094865183688e-8,1.6081224906088311e-16,0,2.0489094865183688e-8,1,5.053215392444312e-16,0,-0.03196112811565399,0.00012439562124200165,-9.574726432503377e-18,1],[7,5.751306066253416e-17,-4.843061753670192e-16,1,0,0.9392595887184143,0.34320753812789917,1.1219782537462701e-16,0,-0.34320753812789917,0.9392595887184143,4.746281357303692e-16,0,-0.02801189385354519,-0.010852459818124771,-9.365741732283693e-18,1],[7,-1.6073587051184242e-16,-5.003653906513687e-16,1,0,0.9995249509811401,-0.03081941418349743,1.4523855570887774e-16,0,0.03081941418349743,0.9995249509811401,5.05081511283003e-16,0,-0.02732432447373867,0.0003465543850325048,-1.9691652799332707e-18,1],[7,-1.6051606546202993e-16,-4.955657313953114e-16,1,0,0.9981581568717957,-0.06066583842039108,1.3015651204319428e-16,0,0.06066583842039108,0.9981581568717957,5.043908088540763e-16,0,-0.024823229759931564,0.0011626967461779714,-3.024364845781441e-18,1],[7,-1.6073266766851061e-16,-5.002625820273957e-16,1,0,0.9995050430297852,-0.031458914279937744,1.4491539940461042e-16,0,0.031458914279937744,0.9995050430297852,5.050714527667544e-16,0,-0.019512146711349487,0.0004364966880530119,-3.2884277806782753e-18,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[9,".bin",1802743759,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":86976,"length":10536,"count":2634,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":86976,"count":1208,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,20]]},"minPosition",8,[1,0.0009535561548545957,-7.370608123835609e-9,-0.003799456637352705],"maxPosition",8,[1,0.005842541344463825,0.01962107978761196,0.0028437741566449404]]],-1],0,0,[],[],[]],[[[39,"megatexture5",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.7071067690849304},"mainTexture",6,0]],11]]],0,0,[0,0],[7,5],[67,2]],[[[9,".bin",1285690163,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":85248,"length":10392,"count":2598,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":85248,"count":1184,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,4,5,6,7,20]]},"minPosition",8,[1,-0.00583844818174839,1.8676191149147314e-10,-0.003799456637352705],"maxPosition",8,[1,-0.0009591798298060894,0.019621947780251503,0.0028437667060643435]]],-1],0,0,[],[],[]],[[[9,".bin",2426860453,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":73080,"length":8244,"count":2061,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":73080,"count":1015,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,12,13,14,15]]},"minPosition",8,[1,-0.009528715163469315,0.015794329345226288,-0.002364254789426923],"maxPosition",8,[1,-0.003532211994752288,0.0326291024684906,0.001657308777794242]]],-1],0,0,[],[],[]],[[[9,".bin",2180768408,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":220032,"length":25920,"count":6480,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":220032,"count":3056,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,11,15,16,17,18,19,20]]},"minPosition",8,[1,-0.005659661255776882,0.017558548599481583,-0.007011509500443935],"maxPosition",8,[1,0.005659661255776882,0.031901877373456955,0.004147702362388372]]],-1],0,0,[],[],[]],[[[11,"Skin-3",1168153290,["Root_M/Hip_L/Knee_L/Ankle_L/Toes_L","Root_M/Hip_L/Knee_L/Ankle_L","Root_M/Hip_L/Knee_L","Root_M/Hip_L","Root_M/Hip_R/Knee_R/Ankle_R/Toes_R","Root_M/Hip_R/Knee_R/Ankle_R","Root_M/Hip_R/Knee_R","Root_M/Hip_R","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L","Root_M/Spine1_M/Chest_M/Scapula_L","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R","Root_M/Spine1_M/Chest_M/Scapula_R","Root_M/Spine1_M/Chest_M/Neck_M/Head_M","Root_M/Spine1_M/Chest_M/Neck_M","Root_M/Spine1_M/Chest_M","Root_M/Spine1_M","Root_M"],[[[7,-7.873639447097958e-7,-6.519635320501038e-8,-1,0,0.08185373991727829,-0.9966443777084351,5.288988691454222e-10,0,-0.9966443777084351,-0.08185373991727829,7.900583796072169e-7,0,0.0015626716194674373,0.0007490515126846731,0.0027741827070713043,1],[7,-1.8150986269560576e-10,-0.0015915741678327322,-0.9999987483024597,0,1,7.69743095929698e-8,-3.0402055872791323e-10,0,7.697469328604711e-8,-0.9999987483024597,0.0015915741678327322,0,-0.002713743830099702,-0.0009506093920208514,0.0027716041076928377,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,0.9948249459266663,0.10103511065244675,-0.01073656789958477,0,0.10104092955589294,-0.9948822855949402,2.2699371255671978e-15,0,-0.01038399152457714,-0.0012213099980726838,0.0027990643866360188,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,0.9993575811386108,0.03419242799282074,-0.01073656789958477,0,0.034194398671388626,-0.9994152188301086,2.2804104762017604e-15,0,-0.01896691881120205,-0.0005232313415035605,0.0027990643866360188,1],[7,7.942823003759258e-7,6.541559827155652e-8,-1,0,-0.08185373991727829,0.9966443777084351,1.8111570576628822e-10,0,0.9966443777084351,0.08185373991727829,7.96971448835393e-7,0,-0.0015626671956852078,-0.0007490511634387076,-0.0027741852682083845,1],[7,-1.8117590760979851e-10,-0.0015915741678327322,-0.9999987483024597,0,-1,-7.552468872518148e-8,3.013794214190568e-10,0,-7.552507241825879e-8,0.9999987483024597,-0.0015915741678327322,0,0.002713743830099702,0.0009506093338131905,-0.0027716041076928377,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,-0.9948249459266663,-0.10103510320186615,0.01073656789958477,0,-0.10104092955589294,0.9948822855949402,-2.213251457106047e-11,0,0.01038399152457714,0.0012213099980726838,-0.0027990643866360188,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,-0.9993575811386108,-0.03419242799282074,0.01073656789958477,0,-0.034194398671388626,0.9994152188301086,-2.2132606511404695e-11,0,0.01896691881120205,0.0005232312832958996,-0.0027990643866360188,1],[7,-0.003217601217329502,0.013486070558428764,-0.9999038577079773,0,0.9900209307670593,-0.14082854986190796,-0.005085205193608999,0,-0.14088359475135803,-0.9899421334266663,-0.01289836224168539,0,-0.01772109419107437,0.0025276578962802887,0.006342135835438967,1],[7,-0.027939576655626297,0.003914658445864916,-0.9996019601821899,0,0.9899323582649231,-0.13870102167129517,-0.02821248769760132,0,-0.13875624537467957,-0.9903265833854675,5.44632006160839e-10,0,-0.022954469546675682,0.0025493649300187826,0.006753850262612104,1],[7,-0.028053926303982735,-0.0029869170393794775,-0.9996019601821899,0,0.9939839243888855,0.10582999885082245,-0.02821248769760132,0,0.10587213933467865,-0.9943797588348389,5.446323392277463e-10,0,-0.028061948716640472,-0.0031008420046418905,0.006753850262612104,1],[7,-0.9999274015426636,-0.000001486659016336489,-0.012051837518811226,0,0.0120518384501338,-0.00012334641360212117,-0.9999273419380188,0,-9.146007654567759e-16,-1,0.00012335537758190185,0,0.0026569380424916744,-0.00010892009595409036,0.02848154492676258,1],[7,-0.003217607969418168,0.013486023992300034,-0.9999038577079773,0,-0.9900209307670593,0.14082854986190796,0.005085205193608999,0,0.14088359475135803,0.9899421334266663,0.01289831567555666,0,0.01772116683423519,-0.0025277347303926945,-0.006337270140647888,1],[7,-0.027939582243561745,0.003914611879736185,-0.9996019601821899,0,-0.9899323582649231,0.13870102167129517,0.02821248769760132,0,0.13875624537467957,0.9903265833854675,-4.755057858574219e-8,0,0.022954663261771202,-0.002549394965171814,-0.00674898736178875,1],[7,-0.028053922578692436,-0.0029869636055082083,-0.9996019601821899,0,-0.9939839243888855,-0.10582999140024185,0.02821248769760132,0,-0.10587213933467865,0.9943797588348389,-4.755057858574219e-8,0,0.028062142431735992,0.0031008596997708082,-0.00674898736178875,1],[7,-0.9999274015426636,-0.0000014861826684864354,-0.012051843106746674,0,-0.012051843106746674,0.00012334794155322015,0.9999273419380188,0,4.953271126595382e-10,1,-0.00012335690553300083,0,-0.0026569380424916744,0.00010892005229834467,-0.02848154492676258,1],[7,-1.6081226229577292e-16,-5.053215392444312e-16,1,0,1,-2.0489094865183688e-8,1.6081224906088311e-16,0,2.0489094865183688e-8,1,5.053215392444312e-16,0,-0.03196112811565399,0.00012439562124200165,-9.574726432503377e-18,1],[7,5.751306066253416e-17,-4.843061753670192e-16,1,0,0.9392595887184143,0.34320753812789917,1.1219782537462701e-16,0,-0.34320753812789917,0.9392595887184143,4.746281357303692e-16,0,-0.02801189385354519,-0.010852459818124771,-9.365741732283693e-18,1],[7,-1.6073587051184242e-16,-5.003653906513687e-16,1,0,0.9995249509811401,-0.03081941418349743,1.4523855570887774e-16,0,0.03081941418349743,0.9995249509811401,5.05081511283003e-16,0,-0.02732432447373867,0.0003465543850325048,-1.9691652799332707e-18,1],[7,-1.6051606546202993e-16,-4.955657313953114e-16,1,0,0.9981581568717957,-0.06066583842039108,1.3015651204319428e-16,0,0.06066583842039108,0.9981581568717957,5.043908088540763e-16,0,-0.024823229759931564,0.0011626967461779714,-3.024364845781441e-18,1],[7,-1.6073266766851061e-16,-5.002625820273957e-16,1,0,0.9995050430297852,-0.031458914279937744,1.4491539940461042e-16,0,0.031458914279937744,0.9995050430297852,5.050714527667544e-16,0,-0.019512146711349487,0.0004364966880530119,-3.2884277806782753e-18,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[9,".bin",3021633291,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":130320,"length":14496,"count":3624,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":130320,"count":1810,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,16]]},"minPosition",8,[1,-0.0024110907688736916,0.028656356036663055,-0.0027839902322739363],"maxPosition",8,[1,0.0024110907688736916,0.03437618166208267,0.002181526506319642]]],-1],0,0,[],[],[]],[[[11,"Skin-7",1168153290,["Root_M/Hip_L/Knee_L/Ankle_L/Toes_L","Root_M/Hip_L/Knee_L/Ankle_L","Root_M/Hip_L/Knee_L","Root_M/Hip_L","Root_M/Hip_R/Knee_R/Ankle_R/Toes_R","Root_M/Hip_R/Knee_R/Ankle_R","Root_M/Hip_R/Knee_R","Root_M/Hip_R","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L","Root_M/Spine1_M/Chest_M/Scapula_L","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R","Root_M/Spine1_M/Chest_M/Scapula_R","Root_M/Spine1_M/Chest_M/Neck_M/Head_M","Root_M/Spine1_M/Chest_M/Neck_M","Root_M/Spine1_M/Chest_M","Root_M/Spine1_M","Root_M"],[[[7,-7.873639447097958e-7,-6.519635320501038e-8,-1,0,0.08185373991727829,-0.9966443777084351,5.288988691454222e-10,0,-0.9966443777084351,-0.08185373991727829,7.900583796072169e-7,0,0.0015626716194674373,0.0007490515126846731,0.0027741827070713043,1],[7,-1.8150986269560576e-10,-0.0015915741678327322,-0.9999987483024597,0,1,7.69743095929698e-8,-3.0402055872791323e-10,0,7.697469328604711e-8,-0.9999987483024597,0.0015915741678327322,0,-0.002713743830099702,-0.0009506093920208514,0.0027716041076928377,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,0.9948249459266663,0.10103511065244675,-0.01073656789958477,0,0.10104092955589294,-0.9948822855949402,2.2699371255671978e-15,0,-0.01038399152457714,-0.0012213099980726838,0.0027990643866360188,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,0.9993575811386108,0.03419242799282074,-0.01073656789958477,0,0.034194398671388626,-0.9994152188301086,2.2804104762017604e-15,0,-0.01896691881120205,-0.0005232313415035605,0.0027990643866360188,1],[7,7.942823003759258e-7,6.541559827155652e-8,-1,0,-0.08185373991727829,0.9966443777084351,1.8111570576628822e-10,0,0.9966443777084351,0.08185373991727829,7.96971448835393e-7,0,-0.0015626671956852078,-0.0007490511634387076,-0.0027741852682083845,1],[7,-1.8117590760979851e-10,-0.0015915741678327322,-0.9999987483024597,0,-1,-7.552468872518148e-8,3.013794214190568e-10,0,-7.552507241825879e-8,0.9999987483024597,-0.0015915741678327322,0,0.002713743830099702,0.0009506093338131905,-0.0027716041076928377,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,-0.9948249459266663,-0.10103510320186615,0.01073656789958477,0,-0.10104092955589294,0.9948822855949402,-2.213251457106047e-11,0,0.01038399152457714,0.0012213099980726838,-0.0027990643866360188,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,-0.9993575811386108,-0.03419242799282074,0.01073656789958477,0,-0.034194398671388626,0.9994152188301086,-2.2132606511404695e-11,0,0.01896691881120205,0.0005232312832958996,-0.0027990643866360188,1],[7,-0.003217601217329502,0.013486070558428764,-0.9999038577079773,0,0.9900209307670593,-0.14082854986190796,-0.005085205193608999,0,-0.14088359475135803,-0.9899421334266663,-0.01289836224168539,0,-0.01772109419107437,0.0025276578962802887,0.006342135835438967,1],[7,-0.027939576655626297,0.003914658445864916,-0.9996019601821899,0,0.9899323582649231,-0.13870102167129517,-0.02821248769760132,0,-0.13875624537467957,-0.9903265833854675,5.44632006160839e-10,0,-0.022954469546675682,0.0025493649300187826,0.006753850262612104,1],[7,-0.028053926303982735,-0.0029869170393794775,-0.9996019601821899,0,0.9939839243888855,0.10582999885082245,-0.02821248769760132,0,0.10587213933467865,-0.9943797588348389,5.446323392277463e-10,0,-0.028061948716640472,-0.0031008420046418905,0.006753850262612104,1],[7,-0.9999274015426636,-0.000001486659016336489,-0.012051837518811226,0,0.0120518384501338,-0.00012334641360212117,-0.9999273419380188,0,-9.146007654567759e-16,-1,0.00012335537758190185,0,0.0026569380424916744,-0.00010892009595409036,0.02848154492676258,1],[7,-0.003217607969418168,0.013486023992300034,-0.9999038577079773,0,-0.9900209307670593,0.14082854986190796,0.005085205193608999,0,0.14088359475135803,0.9899421334266663,0.01289831567555666,0,0.01772116683423519,-0.0025277347303926945,-0.006337270140647888,1],[7,-0.027939582243561745,0.003914611879736185,-0.9996019601821899,0,-0.9899323582649231,0.13870102167129517,0.02821248769760132,0,0.13875624537467957,0.9903265833854675,-4.755057858574219e-8,0,0.022954663261771202,-0.002549394965171814,-0.00674898736178875,1],[7,-0.028053922578692436,-0.0029869636055082083,-0.9996019601821899,0,-0.9939839243888855,-0.10582999140024185,0.02821248769760132,0,-0.10587213933467865,0.9943797588348389,-4.755057858574219e-8,0,0.028062142431735992,0.0031008596997708082,-0.00674898736178875,1],[7,-0.9999274015426636,-0.0000014861826684864354,-0.012051843106746674,0,-0.012051843106746674,0.00012334794155322015,0.9999273419380188,0,4.953271126595382e-10,1,-0.00012335690553300083,0,-0.0026569380424916744,0.00010892005229834467,-0.02848154492676258,1],[7,-1.6081226229577292e-16,-5.053215392444312e-16,1,0,1,-2.0489094865183688e-8,1.6081224906088311e-16,0,2.0489094865183688e-8,1,5.053215392444312e-16,0,-0.03196112811565399,0.00012439562124200165,-9.574726432503377e-18,1],[7,5.751306066253416e-17,-4.843061753670192e-16,1,0,0.9392595887184143,0.34320753812789917,1.1219782537462701e-16,0,-0.34320753812789917,0.9392595887184143,4.746281357303692e-16,0,-0.02801189385354519,-0.010852459818124771,-9.365741732283693e-18,1],[7,-1.6073587051184242e-16,-5.003653906513687e-16,1,0,0.9995249509811401,-0.03081941418349743,1.4523855570887774e-16,0,0.03081941418349743,0.9995249509811401,5.05081511283003e-16,0,-0.02732432447373867,0.0003465543850325048,-1.9691652799332707e-18,1],[7,-1.6051606546202993e-16,-4.955657313953114e-16,1,0,0.9981581568717957,-0.06066583842039108,1.3015651204319428e-16,0,0.06066583842039108,0.9981581568717957,5.043908088540763e-16,0,-0.024823229759931564,0.0011626967461779714,-3.024364845781441e-18,1],[7,-1.6073266766851061e-16,-5.002625820273957e-16,1,0,0.9995050430297852,-0.031458914279937744,1.4491539940461042e-16,0,0.031458914279937744,0.9995050430297852,5.050714527667544e-16,0,-0.019512146711349487,0.0004364966880530119,-3.2884277806782753e-18,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[11,"Skin-1",1168153290,["Root_M/Hip_L/Knee_L/Ankle_L/Toes_L","Root_M/Hip_L/Knee_L/Ankle_L","Root_M/Hip_L/Knee_L","Root_M/Hip_L","Root_M/Hip_R/Knee_R/Ankle_R/Toes_R","Root_M/Hip_R/Knee_R/Ankle_R","Root_M/Hip_R/Knee_R","Root_M/Hip_R","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L","Root_M/Spine1_M/Chest_M/Scapula_L/Shoulder_L","Root_M/Spine1_M/Chest_M/Scapula_L","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R","Root_M/Spine1_M/Chest_M/Scapula_R/Shoulder_R","Root_M/Spine1_M/Chest_M/Scapula_R","Root_M/Spine1_M/Chest_M/Neck_M/Head_M","Root_M/Spine1_M/Chest_M/Neck_M","Root_M/Spine1_M/Chest_M","Root_M/Spine1_M","Root_M"],[[[7,-7.873639447097958e-7,-6.519635320501038e-8,-1,0,0.08185373991727829,-0.9966443777084351,5.288988691454222e-10,0,-0.9966443777084351,-0.08185373991727829,7.900583796072169e-7,0,0.0015626716194674373,0.0007490515126846731,0.0027741827070713043,1],[7,-1.8150986269560576e-10,-0.0015915741678327322,-0.9999987483024597,0,1,7.69743095929698e-8,-3.0402055872791323e-10,0,7.697469328604711e-8,-0.9999987483024597,0.0015915741678327322,0,-0.002713743830099702,-0.0009506093920208514,0.0027716041076928377,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,0.9948249459266663,0.10103511065244675,-0.01073656789958477,0,0.10104092955589294,-0.9948822855949402,2.2699371255671978e-15,0,-0.01038399152457714,-0.0012213099980726838,0.0027990643866360188,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,0.9993575811386108,0.03419242799282074,-0.01073656789958477,0,0.034194398671388626,-0.9994152188301086,2.2804104762017604e-15,0,-0.01896691881120205,-0.0005232313415035605,0.0027990643866360188,1],[7,7.942823003759258e-7,6.541559827155652e-8,-1,0,-0.08185373991727829,0.9966443777084351,1.8111570576628822e-10,0,0.9966443777084351,0.08185373991727829,7.96971448835393e-7,0,-0.0015626671956852078,-0.0007490511634387076,-0.0027741852682083845,1],[7,-1.8117590760979851e-10,-0.0015915741678327322,-0.9999987483024597,0,-1,-7.552468872518148e-8,3.013794214190568e-10,0,-7.552507241825879e-8,0.9999987483024597,-0.0015915741678327322,0,0.002713743830099702,0.0009506093338131905,-0.0027716041076928377,1],[7,-0.010681620799005032,-0.0010848328238353133,-0.9999423623085022,0,-0.9948249459266663,-0.10103510320186615,0.01073656789958477,0,-0.10104092955589294,0.9948822855949402,-2.213251457106047e-11,0,0.01038399152457714,0.0012213099980726838,-0.0027990643866360188,1],[7,-0.010730288922786713,-0.0003671304730232805,-0.9999423623085022,0,-0.9993575811386108,-0.03419242799282074,0.01073656789958477,0,-0.034194398671388626,0.9994152188301086,-2.2132606511404695e-11,0,0.01896691881120205,0.0005232312832958996,-0.0027990643866360188,1],[7,-0.003217601217329502,0.013486070558428764,-0.9999038577079773,0,0.9900209307670593,-0.14082854986190796,-0.005085205193608999,0,-0.14088359475135803,-0.9899421334266663,-0.01289836224168539,0,-0.01772109419107437,0.0025276578962802887,0.006342135835438967,1],[7,-0.027939576655626297,0.003914658445864916,-0.9996019601821899,0,0.9899323582649231,-0.13870102167129517,-0.02821248769760132,0,-0.13875624537467957,-0.9903265833854675,5.44632006160839e-10,0,-0.022954469546675682,0.0025493649300187826,0.006753850262612104,1],[7,-0.028053926303982735,-0.0029869170393794775,-0.9996019601821899,0,0.9939839243888855,0.10582999885082245,-0.02821248769760132,0,0.10587213933467865,-0.9943797588348389,5.446323392277463e-10,0,-0.028061948716640472,-0.0031008420046418905,0.006753850262612104,1],[7,-0.9999274015426636,-0.000001486659016336489,-0.012051837518811226,0,0.0120518384501338,-0.00012334641360212117,-0.9999273419380188,0,-9.146007654567759e-16,-1,0.00012335537758190185,0,0.0026569380424916744,-0.00010892009595409036,0.02848154492676258,1],[7,-0.003217607969418168,0.013486023992300034,-0.9999038577079773,0,-0.9900209307670593,0.14082854986190796,0.005085205193608999,0,0.14088359475135803,0.9899421334266663,0.01289831567555666,0,0.01772116683423519,-0.0025277347303926945,-0.006337270140647888,1],[7,-0.027939582243561745,0.003914611879736185,-0.9996019601821899,0,-0.9899323582649231,0.13870102167129517,0.02821248769760132,0,0.13875624537467957,0.9903265833854675,-4.755057858574219e-8,0,0.022954663261771202,-0.002549394965171814,-0.00674898736178875,1],[7,-0.028053922578692436,-0.0029869636055082083,-0.9996019601821899,0,-0.9939839243888855,-0.10582999140024185,0.02821248769760132,0,-0.10587213933467865,0.9943797588348389,-4.755057858574219e-8,0,0.028062142431735992,0.0031008596997708082,-0.00674898736178875,1],[7,-0.9999274015426636,-0.0000014861826684864354,-0.012051843106746674,0,-0.012051843106746674,0.00012334794155322015,0.9999273419380188,0,4.953271126595382e-10,1,-0.00012335690553300083,0,-0.0026569380424916744,0.00010892005229834467,-0.02848154492676258,1],[7,-1.6081226229577292e-16,-5.053215392444312e-16,1,0,1,-2.0489094865183688e-8,1.6081224906088311e-16,0,2.0489094865183688e-8,1,5.053215392444312e-16,0,-0.03196112811565399,0.00012439562124200165,-9.574726432503377e-18,1],[7,5.751306066253416e-17,-4.843061753670192e-16,1,0,0.9392595887184143,0.34320753812789917,1.1219782537462701e-16,0,-0.34320753812789917,0.9392595887184143,4.746281357303692e-16,0,-0.02801189385354519,-0.010852459818124771,-9.365741732283693e-18,1],[7,-1.6073587051184242e-16,-5.003653906513687e-16,1,0,0.9995249509811401,-0.03081941418349743,1.4523855570887774e-16,0,0.03081941418349743,0.9995249509811401,5.05081511283003e-16,0,-0.02732432447373867,0.0003465543850325048,-1.9691652799332707e-18,1],[7,-1.6051606546202993e-16,-4.955657313953114e-16,1,0,0.9981581568717957,-0.06066583842039108,1.3015651204319428e-16,0,0.06066583842039108,0.9981581568717957,5.043908088540763e-16,0,-0.024823229759931564,0.0011626967461779714,-3.024364845781441e-18,1],[7,-1.6073266766851061e-16,-5.002625820273957e-16,1,0,0.9995050430297852,-0.031458914279937744,1.4491539940461042e-16,0,0.031458914279937744,0.9995050430297852,5.050714527667544e-16,0,-0.019512146711349487,0.0004364966880530119,-3.2884277806782753e-18,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[17,"sfx_newchar",".mp3",1.109333],-1],0,0,[],[],[]],[[{"name":"TryAgain","rect":{"x":0,"y":0,"width":442,"height":148},"offset":{"x":0,"y":0},"originalSize":{"width":442,"height":148},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[4],0,[0],[13],[68]],[[[81,[{},{},{}],[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true},{},{}]]],0,0,[0],[5],[2]],[[[39,"arena_border",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{},"albedoScale",8,[1,0.5660377740859985,0.41064441204071045,0.3070487976074219]]],11]]],0,0,[0],[5],[2]],[[[9,".bin",3006973197,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":24192,"length":3024,"count":756,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":24192,"count":504,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-8.98915958404541,-11.478874206542969,-23.47831153869629],"maxPosition",8,[1,10.22496509552002,1.7585704326629639,-13.126023292541504]]],-1],0,0,[],[],[]],[[[9,".bin",2088782557,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1728,"length":408,"count":102,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1728,"count":36,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-2.9037060737609863,5.820766091346741e-11,-4.7448225021362305],"maxPosition",8,[1,2.9037065505981445,0.0000014305696822702885,4.707498550415039]]],-1],0,0,[],[],[]],[[[9,".bin",63720426,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":5808,"length":2400,"count":600,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":5808,"count":121,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-5,-1.1102230246251565e-16,-5],"maxPosition",8,[1,5,1.1102230246251565e-16,5]]],-1],0,0,[],[],[]],[[[9,".bin",2774053404,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6912,"length":864,"count":216,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":6912,"count":144,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-8.895931243896484,-11.478854179382324,-11.702766418457031],"maxPosition",8,[1,9.400227546691895,-0.5476887226104736,-1.0350635051727295]]],-1],0,0,[],[],[]],[[[9,".bin",1545483753,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":32256,"length":4032,"count":1008,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":32256,"count":672,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-9.181829452514648,-11.478874206542969,0.8526481986045837],"maxPosition",8,[1,10.83174991607666,1.7585704326629639,22.491722106933594]]],-1],0,0,[],[],[]],[[[39,"Fog_2",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{},"albedoScale",8,[1,0.9433962106704712,0.7119660377502441,0.44944819808006287]]],11]]],0,0,[0],[5],[2]],[[[9,".bin",2123467134,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":16032,"length":2544,"count":636,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":16032,"count":334,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-2.959693431854248,-11.41193962097168,-4.772816181182861],"maxPosition",8,[1,2.959693431854248,0.14929866790771484,4.772815704345703]]],-1],0,0,[],[],[]],[[[39,"arena_floor",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{}],[[[{},"albedoScale",8,[1,0.6784313917160034,0.6470588445663452,0.6196078658103943]]],11]]],0,0,[0],[5],[2]],[[{"base":"2,2,0,0,2,0","rgbe":false,"mipmaps":[{"front":"c172d72a-5bad-4317-a35e-665f07eb4b7e@b47c0@e9a6d","back":"c172d72a-5bad-4317-a35e-665f07eb4b7e@b47c0@40c10","left":"c172d72a-5bad-4317-a35e-665f07eb4b7e@b47c0@8fd34","right":"c172d72a-5bad-4317-a35e-665f07eb4b7e@b47c0@74afd","top":"c172d72a-5bad-4317-a35e-665f07eb4b7e@b47c0@bb97f","bottom":"c172d72a-5bad-4317-a35e-665f07eb4b7e@b47c0@7d38f"}]}],[17],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[2],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[2],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[2],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[2],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[2],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[2],0,[],[],[]],[[{"name":"Tap To Fight","rect":{"x":0,"y":0,"width":768,"height":128},"offset":{"x":0,"y":0},"originalSize":{"width":768,"height":128},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[4],0,[0],[13],[69]],[[[77,"builtin-particle",[{"hash":2554907268,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\n  uniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":52,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":40}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]},{"hash":1720952533,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\n  uniform vec4 tintColor;\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = multiply(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":52,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":40}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]},{"hash":1759026248,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture2D(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = addSmooth(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":52,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":39}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]},{"hash":3775475229,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture2D(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = premultiplied(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":52,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":39}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]}],[{"name":"add","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"alpha-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-multiply","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":7,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":3}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-smooth","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]},{"name":"premultiply-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]}]]],0,0,[],[],[]],[[[126,"Dino"],[47,"Robo_2",8388608,[-8,-9,-10],[[32,true,-1,[181,182,183,184],185],[42,-2,[1,0,0.01,0],[1,0.02,0.02,0.02]],[33,8,2,-3],[129,-7,-6,-5,-4]]],[100,"Robo_Boss",8388608,[-15,-16,-17],[[[127,true,-11,[209,210,211]],-12,[42,-13,[1,0,0.005,0],[1,0.02,0.01,0.02]],[33,4,2,-14]],4,1,4,4],[1,0,-0.392,0],[3,0,0.7071067811865475,0,0.7071067811865476],[1,550,550,550],[1,0,90,0]],[47,"Robo_2",8388608,[-21,-22],[[32,true,-18,[120,121],122],[42,-19,[1,0,0.02,0],[1,0.02,0.04,0.01]],[33,8,2,-20]]],[47,"Robo_2",8388608,[-26,-27],[[32,true,-23,[152,153],154],[42,-24,[1,0,0.02,0],[1,0.02,0.04,0.01]],[33,8,2,-25]]],[63,"Robo_1",8388608,[-29,-30,-31,-32,-33],[[32,true,-28,[47,48],49]],[1,-0.5,-12.9,10.44],[3,0,0.8660254037844386,0,0.5000000000000001],[1,30,30,30],[1,0,119.99999999999999,0]],[63,"Robo_2",8388608,[-35,-36,-37,-38,-39],[[32,true,-34,[75,76],77]],[1,0.527,-12.9,10.434],[3,0,-0.8660254037844386,0,0.5000000000000001],[1,30,30,30],[1,0,-119.99999999999999,0]],[91,"Canvas2D",33554432,[-44,-45,-46,-47,-48,-49,-50],[[16,-40,[5,320,480]],[131,-42,-41],[132,45,2.842170943040401e-14,2.842170943040401e-14,-43]],[1,160,240.00000000000003,0]],[85,"AudioManager","43S0d/FAdIIa0438iJAqd+",[-52,-53,-54,-55,-56,-57,-58,-59],[-51]],[92,"Robo_3",false,8388608,[-61,-62],[[128,-60]],[1,-0.047,-12.018,10.4],[1,30,30,30]],[15,"melee_10",8388608,3,[-63,-64,-65,-66,-67,-68,-69,-70]],[15,"melee_10",8388608,4,[-71,-72,-73,-74,-75,-76,-77,-78]],[15,"melee_10",8388608,1,[-79,-80,-81,-82,-83,-84,-85,-86]],[18,"Map1",8388608,[-87,-88,-89,-90,-91,-92,-93,-94],[1,0,3.936,-0.1],[3,6.123234262925839e-17,1,6.123234262925839e-17,-6.123234262925839e-17],[1,-7.0167096047110005e-15,-180,7.0167096047110005e-15]],[133,"Dino",[-115,-116,-117,-118,8,-119,-120],[102,"e7973f3c-cbce-4a8a-9dbb-89db64b73708",[[24,["_trailModule","_particleSystem"],-102,[0,["997SBNaQNCWKIt4cMMbVIk"]],-101,[0,["997SBNaQNCWKIt4cMMbVIk"]]],[24,["_trailModule","_particleSystem"],-104,[0,["997SBNaQNCWKIt4cMMbVIk"]],-103,[0,["997SBNaQNCWKIt4cMMbVIk"]]],[24,["_trailModule","_particleSystem"],-106,[0,["997SBNaQNCWKIt4cMMbVIk"]],-105,[0,["997SBNaQNCWKIt4cMMbVIk"]]],[24,["_trailModule","_particleSystem"],-108,[0,["dd75xDNvFL5JL1FFRSWiHm"]],-107,[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[24,["_trailModule","_particleSystem"],-110,[0,["c7bOimb2dLyq9O1ar9HEBQ"]],-109,[0,["c7bOimb2dLyq9O1ar9HEBQ"]]],[24,["_trailModule","_particleSystem"],-112,[0,["c7bOimb2dLyq9O1ar9HEBQ"]],-111,[0,["c7bOimb2dLyq9O1ar9HEBQ"]]],[24,["_trailModule","_particleSystem"],-114,[0,["dd75xDNvFL5JL1FFRSWiHm"]],-113,[0,["dd75xDNvFL5JL1FFRSWiHm"]]]],[-95,-96,-97,-98,-99,-100]],[134,[135,0.5208,[2,1,1,1,0.520833125],[2,1,1,1,1],[2,0.519964,0.630786,0.905039,0.5208],[2,0.519544,0.630484,0.905069,0]],[136,1,true,2,0.05,0.4,0.2,5,10,2000,10,1,[4,4283190348],[0,2048,2048]],[137,true,233,234],[138],[139]]],[15,"melee_02",8388608,2,[-121,-122,-123,-124,-125,-126,-127]],[93,"CTA",false,33554432,7,[-130,-131,-132,-133],[[43,-128],[34,true,-129,[15],16]]],[86,"Details",8388608,[-134,-135,-136,-137,-138],[1,0,0,-1.45]],[15,"melee_07",8388608,5,[-139,-140,-141,-142,-143,-144]],[44,0,{},5,[28,"872CzlWxdOdalxTtqSnFF/",-149,[140,"2bWcSTTxZMDr9S2PdxGz/1",null,[[4,"MergeFX",["_name"],[0,["872CzlWxdOdalxTtqSnFF/"]]],[13,["_lpos"],[0,["872CzlWxdOdalxTtqSnFF/"]],[1,0,-0.007,0]],[13,["_lrot"],[0,["872CzlWxdOdalxTtqSnFF/"]],[3,0.7071067811865475,0,0,0.7071067811865476]],[13,["_euler"],[0,["872CzlWxdOdalxTtqSnFF/"]],[1,90,0,0]],[4,true,["loop"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[13,["startColor","color"],[0,["dd75xDNvFL5JL1FFRSWiHm"]],[4,4294938211]],[4,0,["scaleSpace"],[0,["c7bOimb2dLyq9O1ar9HEBQ"]]],[4,0,["renderer","_alignSpace"],[0,["c7bOimb2dLyq9O1ar9HEBQ"]]],[12,true,["loop"],-145],[13,["_lscale"],[0,["09fUltKsZFvJSq2PnikuMi"]],[1,0.05,0.05,0.05]],[4,0,["_simulationSpace"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[13,["_lscale"],[0,["872CzlWxdOdalxTtqSnFF/"]],[1,0.2,0.2,0.2]],[4,false,["playOnAwake"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,8388608,["_layer"],[0,["872CzlWxdOdalxTtqSnFF/"]]],[4,8388608,["_layer"],[0,["09fUltKsZFvJSq2PnikuMi"]]],[4,0,["startRotationZ","constant"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,3.141592653589793,["startRotationX","constant"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,3,["bursts","length"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[30,["bursts","1"],[0,["dd75xDNvFL5JL1FFRSWiHm"]],[20,[2]]],[30,["bursts","2"],[0,["dd75xDNvFL5JL1FFRSWiHm"]],[20,[2]]],[4,true,["_dataCulling"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,false,["_shapeModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,true,["_velocityOvertimeModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,true,["_forceOvertimeModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,true,["_rotationOvertimeModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,false,["_textureAnimationModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,false,["_limitVelocityOvertimeModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,false,["_trailModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[12,500,["_capacity"],-146],[14,["startColor","color"],-147,[4,4294932992]],[12,0,["startRotationY","constant"],-148]]],40]],[15,"melee_07",8388608,6,[-150,-151,-152,-153,-154,-155]],[44,0,{},6,[28,"872CzlWxdOdalxTtqSnFF/",-158,[35,"c6qqirQrBGtJIF1qJTG2iQ",[[4,"MergeFX",["_name"],[0,["872CzlWxdOdalxTtqSnFF/"]]],[13,["_lpos"],[0,["872CzlWxdOdalxTtqSnFF/"]],[1,0,-0.007,0]],[13,["_lrot"],[0,["872CzlWxdOdalxTtqSnFF/"]],[3,0.7071067811865475,0,0,0.7071067811865476]],[13,["_euler"],[0,["872CzlWxdOdalxTtqSnFF/"]],[1,90,0,0]],[4,true,["loop"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[13,["startColor","color"],[0,["dd75xDNvFL5JL1FFRSWiHm"]],[4,4294938211]],[4,0,["scaleSpace"],[0,["c7bOimb2dLyq9O1ar9HEBQ"]]],[4,0,["renderer","_alignSpace"],[0,["c7bOimb2dLyq9O1ar9HEBQ"]]],[12,true,["loop"],-156],[13,["_lscale"],[0,["09fUltKsZFvJSq2PnikuMi"]],[1,0.05,0.05,0.05]],[4,0,["_simulationSpace"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[13,["_lscale"],[0,["872CzlWxdOdalxTtqSnFF/"]],[1,0.2,0.2,0.2]],[4,false,["playOnAwake"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,8388608,["_layer"],[0,["872CzlWxdOdalxTtqSnFF/"]]],[4,8388608,["_layer"],[0,["09fUltKsZFvJSq2PnikuMi"]]],[4,0,["startRotationZ","constant"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,3.141592653589793,["startRotationX","constant"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,3,["bursts","length"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[30,["bursts","1"],[0,["dd75xDNvFL5JL1FFRSWiHm"]],[20,[2]]],[30,["bursts","2"],[0,["dd75xDNvFL5JL1FFRSWiHm"]],[20,[2]]],[4,true,["_dataCulling"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,false,["_shapeModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,true,["_velocityOvertimeModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,true,["_forceOvertimeModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,true,["_rotationOvertimeModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,false,["_textureAnimationModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,false,["_limitVelocityOvertimeModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,false,["_trailModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,500,["_capacity"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[14,["startColor","color"],-157,[4,4294932992]]]],68]],[15,"melee_07",8388608,9,[-159,-160,-161,-162,-163,-164]],[141,8],[0,["0dZngw4XVG4L0NExqeSESL"]],[0,["0dZngw4XVG4L0NExqeSESL"]],[0,["0dZngw4XVG4L0NExqeSESL"]],[142,7,17],[101,"Camera_3D",[-168],[[-165,[78,-166,[231],232],[143,-167]],1,4,4],[1,0,-11,12],[3,-0.13052619222005157,0,0,0.9914448613738104],[1,-15,0,0]],[5,"HideMask",33554432,7,[[16,-169,[5,5000,5000]],[36,0,-170,[4,16777215],0],[78,-171,[1],2]]],[94,"Points",33554432,7,[-173,-174,-175],[[43,-172]]],[45,0,{},[28,"0dZngw4XVG4L0NExqeSESL",-178,[35,"5ahjZcCklA8IRJ6XyAjIi5",[[12,"FireBall_1",["_name"],24],[14,["_lpos"],24,[1,0,-11,10.285]],[14,["_lrot"],24,[3,0.7071067811865475,0,0,0.7071067811865476]],[14,["_euler"],24,[1,89.99999999999999,0,0]],[12,false,["loop"],-176],[12,8388608,["_layer"],24],[12,false,["playOnAwake"],-177],[14,["_lscale"],24,[1,0.8,0.8,0.8]]]],19]],[45,0,{},[28,"0dZngw4XVG4L0NExqeSESL",-181,[35,"31x4TnDZ9OxLdlRX0Gej12",[[12,"FireBall_2",["_name"],25],[14,["_lpos"],25,[1,-0.4,-11.22,9.616]],[14,["_lrot"],25,[3,0.7071067811865475,0,0,0.7071067811865476]],[14,["_euler"],25,[1,89.99999999999999,0,0]],[12,false,["loop"],-179],[12,8388608,["_layer"],25],[14,["_lscale"],25,[1,0.65,0.65,0.65]],[12,false,["playOnAwake"],-180]]],20]],[45,0,{},[28,"0dZngw4XVG4L0NExqeSESL",-184,[35,"08D3JVik5O25+afFfS3nRG",[[12,"FireBall_3",["_name"],26],[14,["_lpos"],26,[1,0.45,-11.22,9.616]],[14,["_lrot"],26,[3,0.7071067811865475,0,0,0.7071067811865476]],[14,["_euler"],26,[1,89.99999999999999,0,0]],[12,false,["loop"],-182],[12,8388608,["_layer"],26],[14,["_lscale"],26,[1,0.65,0.65,0.65]],[12,false,["playOnAwake"],-183]]],21]],[60,"3D",8388608,[-185,17,28]],[95,"GamePlay","74v0Gx9cVDhbRRRgISqK/C",14,[7,34],[[144,-188,27,-187,23,-186]]],[96,"hand-001",33554432,[[130,-189,[5,201,257],[0,0.5,0]],[79,-190,6],[34,true,-191,[7],8]],[1,-47,-164,0],[1,0.5,0.5,1]],[15,"FX",8388608,17,[31,32,33]],[15,"Robo_Step1",8388608,17,[5,6,9]],[1,"Root_M",8388608,5,[-192,-193,-194],[1,3.7055132352355554e-19,0.019516220316290855,0.00017755031876731664],[3,0.507803838505377,0.49207241499519655,0.507803838505377,0.49207241499519655],[1,180,-90,88.1972372917958]],[18,"Chest_M",8388608,[-195,-196,-197],[1,0.0024785464629530907,4.5796701585585055e-18,-1.2831691984992892e-18],[3,-9.49830208270153e-33,7.54892463334064e-18,-0.01493885351669035,0.9998884091015391],[1,1.2928521800077017e-17,8.653327432571688e-16,-1.711930193624262]],[1,"Root_M",8388608,6,[-198,-199,-200],[1,3.7055132352355554e-19,0.019516220316290855,0.00017755031876731664],[3,0.507803838505377,0.49207241499519655,0.507803838505377,0.49207241499519655],[1,180,-90,88.1972372917958]],[18,"Chest_M",8388608,[-201,-202,-203],[1,0.0024785464629530907,4.5796701585585055e-18,-1.2831691984992892e-18],[3,-9.49830208270153e-33,7.54892463334064e-18,-0.01493885351669035,0.9998884091015391],[1,1.2928521800077017e-17,8.653327432571688e-16,-1.711930193624262]],[1,"Root_M",8388608,9,[-204,-205,-206],[1,3.7055132352355554e-19,0.019516220316290855,0.00017755031876731664],[3,0.507803838505377,0.49207241499519655,0.507803838505377,0.49207241499519655],[1,180,-90,88.1972372917958]],[18,"Chest_M",8388608,[-207,-208,-209],[1,0.0024785464629530907,4.5796701585585055e-18,-1.2831691984992892e-18],[3,-9.49830208270153e-33,7.54892463334064e-18,-0.01493885351669035,0.9998884091015391],[1,1.2928521800077017e-17,8.653327432571688e-16,-1.711930193624262]],[87,"Optimus_1",false,8388608,[3,-210,-211],[1,-0.5,-12.9,10.44],[3,0,0.8660254037844386,0,0.5000000000000001],[1,35,35,35],[1,0,120,0]],[1,"Root_M",8388608,3,[-212,-213,-214],[1,3.7055132352355554e-19,0.019516220316290855,0.00017755031876731664],[3,0.507803838505377,0.49207241499519655,0.507803838505377,0.49207241499519655],[1,180,-90,88.1972372917958]],[18,"Chest_M",8388608,[-215,-216,-217],[1,0.0024785464629530907,4.5796701585585055e-18,-1.2831691984992892e-18],[3,-9.49830208270153e-33,7.54892463334064e-18,-0.01493885351669035,0.9998884091015391],[1,1.2928521800077017e-17,8.653327432571688e-16,-1.711930193624262]],[1,"Root_M",8388608,4,[-218,-219,-220],[1,3.7055132352355554e-19,0.019516220316290855,0.00017755031876731664],[3,0.507803838505377,0.49207241499519655,0.507803838505377,0.49207241499519655],[1,180,-90,88.1972372917958]],[18,"Chest_M",8388608,[-221,-222,-223],[1,0.0024785464629530907,4.5796701585585055e-18,-1.2831691984992892e-18],[3,-9.49830208270153e-33,7.54892463334064e-18,-0.01493885351669035,0.9998884091015391],[1,1.2928521800077017e-17,8.653327432571688e-16,-1.711930193624262]],[1,"Root_M",8388608,1,[-224,-225,-226],[1,3.7055132352355554e-19,0.019516220316290855,0.00017755031876731664],[3,0.507803838505377,0.49207241499519655,0.507803838505377,0.49207241499519655],[1,180,-90,88.1972372917958]],[18,"Chest_M",8388608,[-227,-228,-229],[1,0.0024785464629530907,4.5796701585585055e-18,-1.2831691984992892e-18],[3,-9.49830208270153e-33,7.54892463334064e-18,-0.01493885351669035,0.9998884091015391],[1,1.2928521800077017e-17,8.653327432571688e-16,-1.711930193624262]],[1,"Root_M",8388608,2,[-230,-231,-232],[1,3.7055132352355554e-19,0.019516220316290855,0.00017755031876731664],[3,0.507803838505377,0.49207241499519655,0.507803838505377,0.49207241499519655],[1,180,-90,88.1972372917958]],[18,"Chest_M",8388608,[-233,-234,-235],[1,0.0024785464629530907,4.5796701585585055e-18,-1.2831691984992892e-18],[3,-9.49830208270153e-33,7.54892463334064e-18,-0.01493885351669035,0.9998884091015391],[1,1.2928521800077017e-17,8.653327432571688e-16,-1.711930193624262]],[27,"Collider_Ground",8388608,13,[[145,-236,[224],[3]],[146,-237],[33,2,2,-238]],[1,0.002,0.038,-0.037],[1,4,4,4]],[23,"Point_1",33554432,30,[[16,-239,[5,100,200]],[36,0,-240,[4,16777215],3]],[1,-80,0,0]],[23,"Point_2",33554432,30,[[16,-241,[5,100,200]],[36,0,-242,[4,16777215],4]],[1,80,0,0]],[5,"MovingPoint",33554432,30,[[16,-243,[5,10,10]],[36,0,-244,[4,16777215],5]]],[97,"Hint",33554432,7,[36],[[43,-245]],[1,0,-24,0]],[98,"spine_Flash",false,33554432,7,[[43,-246],[147,false,0,"default","Evo02",-247,9]],[1,0.3,0.3,1]],[27,"text_Tap",33554432,7,[[16,-248,[5,768,128]],[79,-249,10]],[1,0,-204,0],[1,0.3,0.3,1]],[5,"Overlay",33554432,16,[[16,-250,[5,5000,5000]],[36,0,-251,[4,0],11]]],[5,"icon_legacy",33554432,16,[[16,-252,[5,192,192]],[58,-253,[4,16777215],12]]],[27,"logo",33554432,16,[[16,-254,[5,453,90]],[58,-255,[4,16777215],13]],[1,0,180,0],[1,0.6,0.6,1]],[27,"TryAgain",33554432,16,[[16,-256,[5,442,148]],[58,-257,[4,16777215],14]],[1,0,-180,0],[1,0.5,0.5,1]],[148,23],[40,"Arrown",false,8388608,5,[[21,"Quad<ModelComponent>",-258,[41],[3],42],[34,true,-259,[43],44]],[1,0,0.043,0],[3,0,-0.8660254037844386,0,0.5000000000000001],[1,0.01,0.01,0.03],[1,0,-120,0]],[40,"Arrown",false,8388608,6,[[21,"Quad<ModelComponent>",-260,[69],[3],70],[34,true,-261,[71],72]],[1,0,0.043,0],[3,0,0.8660254037844386,0,0.5000000000000001],[1,0.01,0.01,0.03],[1,0,120,0]],[15,"Robo_Step2",8388608,17,[45,-262]],[44,0,{},45,[28,"872CzlWxdOdalxTtqSnFF/",-267,[35,"e2g6N7W7tByYrZne5Kb/q2",[[4,"MergeFX",["_name"],[0,["872CzlWxdOdalxTtqSnFF/"]]],[13,["_lpos"],[0,["872CzlWxdOdalxTtqSnFF/"]],[1,0,-0.007,0]],[13,["_lrot"],[0,["872CzlWxdOdalxTtqSnFF/"]],[3,0.7071067811865475,0,0,0.7071067811865476]],[13,["_euler"],[0,["872CzlWxdOdalxTtqSnFF/"]],[1,90,0,0]],[4,true,["loop"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[13,["startColor","color"],[0,["dd75xDNvFL5JL1FFRSWiHm"]],[4,4294938211]],[4,0,["scaleSpace"],[0,["c7bOimb2dLyq9O1ar9HEBQ"]]],[4,0,["renderer","_alignSpace"],[0,["c7bOimb2dLyq9O1ar9HEBQ"]]],[12,true,["loop"],-263],[13,["_lscale"],[0,["09fUltKsZFvJSq2PnikuMi"]],[1,0.05,0.05,0.05]],[4,0,["_simulationSpace"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[13,["_lscale"],[0,["872CzlWxdOdalxTtqSnFF/"]],[1,0.2,0.2,0.2]],[4,false,["playOnAwake"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,8388608,["_layer"],[0,["872CzlWxdOdalxTtqSnFF/"]]],[4,8388608,["_layer"],[0,["09fUltKsZFvJSq2PnikuMi"]]],[4,0,["startRotationZ","constant"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,3.141592653589793,["startRotationX","constant"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,3,["bursts","length"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[30,["bursts","1"],[0,["dd75xDNvFL5JL1FFRSWiHm"]],[20,[2]]],[30,["bursts","2"],[0,["dd75xDNvFL5JL1FFRSWiHm"]],[20,[2]]],[4,true,["_dataCulling"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,false,["_shapeModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,true,["_velocityOvertimeModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,true,["_forceOvertimeModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,true,["_rotationOvertimeModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,false,["_textureAnimationModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,false,["_limitVelocityOvertimeModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[4,false,["_trailModule","_enable"],[0,["dd75xDNvFL5JL1FFRSWiHm"]]],[12,500,["_capacity"],-264],[14,["startColor","color"],-265,[4,4294932992]],[12,0,["startRotationY","constant"],-266]]],123]],[40,"Arrown",false,8388608,45,[[21,"Quad<ModelComponent>",-268,[124],[3],125],[34,true,-269,[126],127]],[1,0,0.043,0],[3,0,-0.8660254037844386,0,0.5000000000000001],[1,0.01,0.01,0.03],[1,0,-120,0]],[27,"Level",8388608,1,[[21,"Quad<ModelComponent>",-270,[179],[3],180]],[1,0.010000000000000002,0.024999999999999967,0.014000000000000033],[1,0.005084000000000001,0.007500000000000001,1]],[88,"Map",8388608,34,[-271,-272],[1,0,-15.5,3.718]],[60,"Map5",8388608,[13,-273]],[46,"NodesController","8a/xFpmgpJurZJj8YB7OHC",14,[27]],[149,"Camera<CameraComponent>",2,60,60,14,8388608,28,[4,4286356144]],[89,"Camera",7,[-274],[1,0,0,1000]],[150,0,3,240.00000000000003,2000,6,33554432,76,[4,4278190080]],[46,"GameController","e4w/NEXQNKr7VqS/zyMP8D",14,[65]],[26,"BgSound",8,[-275]],[151,true,false,79],[26,"AttackSound",8,[-276]],[37,false,81],[26,"MergeSound",8,[-277]],[37,false,83],[26,"LoseSound",8,[-278]],[37,false,85],[64,"FightSound",8,[[80,false,-279,17]]],[64,"ScreamSound",8,[[80,false,-280,18]]],[26,"ChooseSound",8,[-281]],[37,false,89],[26,"ExplosionSound",8,[-282]],[37,false,91],[152,2],[90,"Boss",8388608,17,[2],[1,0,-12.89,8.051],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,0.12,0.12,0.12],[1,0,-90,0]],[0,["997SBNaQNCWKIt4cMMbVIk"]],[0,["997SBNaQNCWKIt4cMMbVIk"]],[0,["997SBNaQNCWKIt4cMMbVIk"]],[1,"Spine1_M",8388608,39,[40],[1,0.005334464367479086,-1.734723475976807e-18,4.299679912665751e-19],[3,2.1271160548415487e-31,-7.387287067052785e-18,0.014618982679226592,0.999893136962858],[1,1.2380563880610636e-17,-8.467922240252193e-16,1.6752716918878972]],[1,"Neck_M",8388608,40,[-283],[1,0.002714349888265133,-9.57567355430475e-18,8.572243914273824e-18],[3,2.334849548498401e-33,1.210279147626834e-32,-0.18942549962218294,0.9818950962770342],[1,5.66041439480744e-31,1.5216497485115417e-30,-21.83851784031204]],[8,"Head_M",8388608,99,[[7,"HeadEnd_M",8388608,-284,[1,0.002823290415108204,5.377642816887133e-19,2.8810669715948983e-19]]],[1,0.002050594659522176,-1.1102230411687688e-17,-1.1397885028539148e-18],[3,1.3712628330747433e-33,-7.748182116840672e-33,0.17427049577586698,0.9846978187759095],[1,3.2947363714137558e-31,-9.59983646203496e-31,20.07241655059164]],[1,"Scapula_R",8388608,40,[-285],[1,0.0011061389232054353,-0.0006425591418519616,-0.0028469646349549294],[3,0.011006418236851384,0.7112698310246427,-0.010875604672522158,0.7027487513007612],[1,1.7730415728863935,90.69020757969066,0.021281444783464887]],[1,"Shoulder_R",8388608,101,[-286],[1,0.0047096810303628445,2.9599587517625207e-16,0],[3,-0.027689870881989053,0.6677426800740703,-0.04203639618045591,0.7426883098946666],[1,0.8642729059348379,83.95977552661904,-5.705732022271162]],[1,"Elbow_R",8388608,102,[-287],[1,0.005175452213734388,-5.773159516292577e-17,-2.2204459996194763e-18],[3,1.736215335978658e-18,-6.995885153988026e-18,0.12233098131469163,0.9924893606535964],[1,3.046483873894846e-16,-8.45285960744512e-16,14.053298599928233]],[8,"Wrist_R",8388608,103,[[7,"Cup_R",8388608,-288,[1,0.0033151672687381506,5.329070399086743e-17,-2.2204459996194763e-18]]],[1,0.005389300640672445,-6.328271160954053e-17,-6.661337998858429e-18],[3,-0.004768474014740153,0.012352902409124579,0.0011546335850644365,0.999911663237771],[1,-0.5480227017072393,1.4161918210299922,0.12554971732357223]],[1,"Scapula_L",8388608,40,[-289],[1,0.0011061389232054353,-0.0006425591418519616,0.0032227779738605022],[3,0.7112698310319335,-0.011006417305641662,-0.7027487513079647,-0.010875604672633637],[1,-178.2269585021126,89.30979241912084,-0.021281368875969202]],[1,"Shoulder_L",8388608,105,[-290],[1,-0.0035574783105403185,1.713056474450525e-9,0.000013887167369830422],[3,-0.03416188434654197,0.6426382066489487,-0.04061436654192732,0.7643294932444482],[1,-0.0012206380677393302,80.11329981341834,-6.08437942527354]],[1,"Elbow_L",8388608,106,[-291],[1,-0.005175452213734388,2.5535130029599743e-17,0],[3,-2.4193042033980414e-18,-3.69900388416738e-17,0.12233098131469163,0.9924893606535964],[1,2.5088938608155047e-16,-4.301746631616259e-15,14.053298599928233]],[8,"Wrist_L",8388608,107,[[7,"Cup_L",8388608,-292,[1,-0.0033151672687381506,-1.412758841187159e-16,0]]],[1,-0.005389300640672445,5.1625371042116473e-17,1.776356799695581e-17],[3,-0.004768474014740153,0.012352902409124579,0.0011546335850644365,0.999911663237771],[1,-0.5480227017072393,1.4161918210299922,0.12554971732357223]],[1,"Hip_R",8388608,39,[-293],[1,-0.0005149218486621976,-0.000035732064134208485,-0.0025951904244720936],[3,-0.0013684586941045457,0.9999846538917857,-0.00017622552207276294,0.0053654679472844545],[1,0.019352340864127352,179.38518562853085,-0.1569199549416445]],[1,"Knee_R",8388608,109,[-294],[1,0.008524451404809952,1.2628998541375225e-11,-1.1102229998097382e-18],[3,3.403632747743931e-20,-9.107188358042246e-19,-0.03350002364301262,0.9994387166884808],[1,4.029053682243933e-19,-1.0440579512036528e-16,-3.839538319810826]],[1,"Ankle_R",8388608,110,[-295],[1,0.007810377050191164,1.1571134675425476e-11,-8.311684436687009e-15],[3,0.0005231972268350271,0.005401740730554813,0.05058017697477186,0.998705258401568],[1,0.028714477331547906,0.6183360190684839,5.79877519893503]],[8,"Toes_R",8388608,111,[[7,"ToesEnd_R",8388608,-296,[1,0.0019366915803402662,-1.9886869822718998e-16,3.063116871260263e-9]]],[1,0.002095116302371025,0.002573760924860835,-1.1551194029069123e-11],[3,-0.0005855765799607817,0.0005394552157793537,0.6775491861260131,0.7354770332703235],[1,-1.1144865141882583,1.1107462304259765,85.3039958375585]],[1,"Hip_L",8388608,39,[-297],[1,-0.0005149218486621976,-0.000035732064134208485,0.0025951904244720936],[3,0.9999846538908325,0.0013684593925951528,-0.00536546794727934,-0.00017622550752068012],[1,-179.9806476612328,0.6148143714585114,0.15692003497274723]],[1,"Knee_L",8388608,113,[-298],[1,-0.008524451404809952,-1.2628998541375225e-11,4.6312953641644995e-15],[3,4.9250421584690475e-20,1.2367185778725194e-18,-0.03350002364301262,0.9994387166884808],[1,1.0411423292578889e-17,1.42146077062345e-16,-3.839538319810826]],[1,"Ankle_L",8388608,114,[-299],[1,-0.007810377050191164,-1.1571218809514061e-11,1.2550515978587175e-14],[3,0.0005231972268350271,0.005401740730554813,0.05058017697477186,0.998705258401568],[1,0.028714477331547906,0.6183360190684839,5.79877519893503]],[8,"Toes_L",8388608,115,[[7,"ToesEnd_L",8388608,-300,[1,-0.0019366915803402662,2.7755574995243454e-19,1.6754419032705137e-11]]],[1,-0.002095116302371025,-0.002573760924860835,8.517709974842358e-12],[3,-0.0005849927574888355,0.0005389178429919117,0.6775491865538494,0.7354770337347383],[1,-1.1133760861696482,1.1096395693191319,85.30399759925989]],[5,"melee_07_body",8388608,18,[[6,1,-301,[22],[3],5,23,24]]],[5,"melee_07_head",8388608,18,[[6,1,-302,[25],[3],5,26,27]]],[5,"melee_07_arm_L",8388608,18,[[6,1,-303,[28],[3],5,29,30]]],[5,"melee_07_leg_L",8388608,18,[[6,1,-304,[31],[3],5,32,33]]],[5,"melee_07_arm_R",8388608,18,[[6,1,-305,[34],[3],5,35,36]]],[5,"melee_07_leg_R",8388608,18,[[6,1,-306,[37],[3],5,38,39]]],[0,["c7bOimb2dLyq9O1ar9HEBQ"]],[0,["dd75xDNvFL5JL1FFRSWiHm"]],[48,"Level",8388608,5,[[21,"Quad<ModelComponent>",-307,[45],[3],46]],[1,0.012,0.036,0.004],[3,0,-0.8660254037844386,0,0.5000000000000001],[1,0.010169,0.0125,1],[1,0,-120,0]],[1,"Spine1_M",8388608,41,[42],[1,0.005334464367479086,-1.734723475976807e-18,4.299679912665751e-19],[3,2.1271160548415487e-31,-7.387287067052785e-18,0.014618982679226592,0.999893136962858],[1,1.2380563880610636e-17,-8.467922240252193e-16,1.6752716918878972]],[1,"Neck_M",8388608,42,[-308],[1,0.002714349888265133,-9.57567355430475e-18,8.572243914273824e-18],[3,2.334849548498401e-33,1.210279147626834e-32,-0.18942549962218294,0.9818950962770342],[1,5.66041439480744e-31,1.5216497485115417e-30,-21.83851784031204]],[8,"Head_M",8388608,127,[[7,"HeadEnd_M",8388608,-309,[1,0.002823290415108204,5.377642816887133e-19,2.8810669715948983e-19]]],[1,0.002050594659522176,-1.1102230411687688e-17,-1.1397885028539148e-18],[3,1.3712628330747433e-33,-7.748182116840672e-33,0.17427049577586698,0.9846978187759095],[1,3.2947363714137558e-31,-9.59983646203496e-31,20.07241655059164]],[1,"Scapula_R",8388608,42,[-310],[1,0.0011061389232054353,-0.0006425591418519616,-0.0028469646349549294],[3,0.011006418236851384,0.7112698310246427,-0.010875604672522158,0.7027487513007612],[1,1.7730415728863935,90.69020757969066,0.021281444783464887]],[1,"Shoulder_R",8388608,129,[-311],[1,0.0047096810303628445,2.9599587517625207e-16,0],[3,-0.027689870881989053,0.6677426800740703,-0.04203639618045591,0.7426883098946666],[1,0.8642729059348379,83.95977552661904,-5.705732022271162]],[1,"Elbow_R",8388608,130,[-312],[1,0.005175452213734388,-5.773159516292577e-17,-2.2204459996194763e-18],[3,1.736215335978658e-18,-6.995885153988026e-18,0.12233098131469163,0.9924893606535964],[1,3.046483873894846e-16,-8.45285960744512e-16,14.053298599928233]],[8,"Wrist_R",8388608,131,[[7,"Cup_R",8388608,-313,[1,0.0033151672687381506,5.329070399086743e-17,-2.2204459996194763e-18]]],[1,0.005389300640672445,-6.328271160954053e-17,-6.661337998858429e-18],[3,-0.004768474014740153,0.012352902409124579,0.0011546335850644365,0.999911663237771],[1,-0.5480227017072393,1.4161918210299922,0.12554971732357223]],[1,"Scapula_L",8388608,42,[-314],[1,0.0011061389232054353,-0.0006425591418519616,0.0032227779738605022],[3,0.7112698310319335,-0.011006417305641662,-0.7027487513079647,-0.010875604672633637],[1,-178.2269585021126,89.30979241912084,-0.021281368875969202]],[1,"Shoulder_L",8388608,133,[-315],[1,-0.0035574783105403185,1.713056474450525e-9,0.000013887167369830422],[3,-0.03416188434654197,0.6426382066489487,-0.04061436654192732,0.7643294932444482],[1,-0.0012206380677393302,80.11329981341834,-6.08437942527354]],[1,"Elbow_L",8388608,134,[-316],[1,-0.005175452213734388,2.5535130029599743e-17,0],[3,-2.4193042033980414e-18,-3.69900388416738e-17,0.12233098131469163,0.9924893606535964],[1,2.5088938608155047e-16,-4.301746631616259e-15,14.053298599928233]],[8,"Wrist_L",8388608,135,[[7,"Cup_L",8388608,-317,[1,-0.0033151672687381506,-1.412758841187159e-16,0]]],[1,-0.005389300640672445,5.1625371042116473e-17,1.776356799695581e-17],[3,-0.004768474014740153,0.012352902409124579,0.0011546335850644365,0.999911663237771],[1,-0.5480227017072393,1.4161918210299922,0.12554971732357223]],[1,"Hip_R",8388608,41,[-318],[1,-0.0005149218486621976,-0.000035732064134208485,-0.0025951904244720936],[3,-0.0013684586941045457,0.9999846538917857,-0.00017622552207276294,0.0053654679472844545],[1,0.019352340864127352,179.38518562853085,-0.1569199549416445]],[1,"Knee_R",8388608,137,[-319],[1,0.008524451404809952,1.2628998541375225e-11,-1.1102229998097382e-18],[3,3.403632747743931e-20,-9.107188358042246e-19,-0.03350002364301262,0.9994387166884808],[1,4.029053682243933e-19,-1.0440579512036528e-16,-3.839538319810826]],[1,"Ankle_R",8388608,138,[-320],[1,0.007810377050191164,1.1571134675425476e-11,-8.311684436687009e-15],[3,0.0005231972268350271,0.005401740730554813,0.05058017697477186,0.998705258401568],[1,0.028714477331547906,0.6183360190684839,5.79877519893503]],[8,"Toes_R",8388608,139,[[7,"ToesEnd_R",8388608,-321,[1,0.0019366915803402662,-1.9886869822718998e-16,3.063116871260263e-9]]],[1,0.002095116302371025,0.002573760924860835,-1.1551194029069123e-11],[3,-0.0005855765799607817,0.0005394552157793537,0.6775491861260131,0.7354770332703235],[1,-1.1144865141882583,1.1107462304259765,85.3039958375585]],[1,"Hip_L",8388608,41,[-322],[1,-0.0005149218486621976,-0.000035732064134208485,0.0025951904244720936],[3,0.9999846538908325,0.0013684593925951528,-0.00536546794727934,-0.00017622550752068012],[1,-179.9806476612328,0.6148143714585114,0.15692003497274723]],[1,"Knee_L",8388608,141,[-323],[1,-0.008524451404809952,-1.2628998541375225e-11,4.6312953641644995e-15],[3,4.9250421584690475e-20,1.2367185778725194e-18,-0.03350002364301262,0.9994387166884808],[1,1.0411423292578889e-17,1.42146077062345e-16,-3.839538319810826]],[1,"Ankle_L",8388608,142,[-324],[1,-0.007810377050191164,-1.1571218809514061e-11,1.2550515978587175e-14],[3,0.0005231972268350271,0.005401740730554813,0.05058017697477186,0.998705258401568],[1,0.028714477331547906,0.6183360190684839,5.79877519893503]],[8,"Toes_L",8388608,143,[[7,"ToesEnd_L",8388608,-325,[1,-0.0019366915803402662,2.7755574995243454e-19,1.6754419032705137e-11]]],[1,-0.002095116302371025,-0.002573760924860835,8.517709974842358e-12],[3,-0.0005849927574888355,0.0005389178429919117,0.6775491865538494,0.7354770337347383],[1,-1.1133760861696482,1.1096395693191319,85.30399759925989]],[5,"melee_07_body",8388608,20,[[6,1,-326,[50],[3],6,51,52]]],[5,"melee_07_head",8388608,20,[[6,1,-327,[53],[3],6,54,55]]],[5,"melee_07_arm_L",8388608,20,[[6,1,-328,[56],[3],6,57,58]]],[5,"melee_07_leg_L",8388608,20,[[6,1,-329,[59],[3],6,60,61]]],[5,"melee_07_arm_R",8388608,20,[[6,1,-330,[62],[3],6,63,64]]],[5,"melee_07_leg_R",8388608,20,[[6,1,-331,[65],[3],6,66,67]]],[0,["c7bOimb2dLyq9O1ar9HEBQ"]],[48,"Level",8388608,6,[[21,"Quad<ModelComponent>",-332,[73],[3],74]],[1,-0.01,0.036,0.006],[3,0,-0.8660254037844387,0,-0.4999999999999998],[1,0.010169,0.0125,1],[1,0,-240,0]],[1,"Spine1_M",8388608,43,[44],[1,0.005334464367479086,-1.734723475976807e-18,4.299679912665751e-19],[3,2.1271160548415487e-31,-7.387287067052785e-18,0.014618982679226592,0.999893136962858],[1,1.2380563880610636e-17,-8.467922240252193e-16,1.6752716918878972]],[1,"Neck_M",8388608,44,[-333],[1,0.002714349888265133,-9.57567355430475e-18,8.572243914273824e-18],[3,2.334849548498401e-33,1.210279147626834e-32,-0.18942549962218294,0.9818950962770342],[1,5.66041439480744e-31,1.5216497485115417e-30,-21.83851784031204]],[8,"Head_M",8388608,154,[[7,"HeadEnd_M",8388608,-334,[1,0.002823290415108204,5.377642816887133e-19,2.8810669715948983e-19]]],[1,0.002050594659522176,-1.1102230411687688e-17,-1.1397885028539148e-18],[3,1.3712628330747433e-33,-7.748182116840672e-33,0.17427049577586698,0.9846978187759095],[1,3.2947363714137558e-31,-9.59983646203496e-31,20.07241655059164]],[1,"Scapula_R",8388608,44,[-335],[1,0.0011061389232054353,-0.0006425591418519616,-0.0028469646349549294],[3,0.011006418236851384,0.7112698310246427,-0.010875604672522158,0.7027487513007612],[1,1.7730415728863935,90.69020757969066,0.021281444783464887]],[1,"Shoulder_R",8388608,156,[-336],[1,0.0047096810303628445,2.9599587517625207e-16,0],[3,-0.027689870881989053,0.6677426800740703,-0.04203639618045591,0.7426883098946666],[1,0.8642729059348379,83.95977552661904,-5.705732022271162]],[1,"Elbow_R",8388608,157,[-337],[1,0.005175452213734388,-5.773159516292577e-17,-2.2204459996194763e-18],[3,1.736215335978658e-18,-6.995885153988026e-18,0.12233098131469163,0.9924893606535964],[1,3.046483873894846e-16,-8.45285960744512e-16,14.053298599928233]],[8,"Wrist_R",8388608,158,[[7,"Cup_R",8388608,-338,[1,0.0033151672687381506,5.329070399086743e-17,-2.2204459996194763e-18]]],[1,0.005389300640672445,-6.328271160954053e-17,-6.661337998858429e-18],[3,-0.004768474014740153,0.012352902409124579,0.0011546335850644365,0.999911663237771],[1,-0.5480227017072393,1.4161918210299922,0.12554971732357223]],[1,"Scapula_L",8388608,44,[-339],[1,0.0011061389232054353,-0.0006425591418519616,0.0032227779738605022],[3,0.7112698310319335,-0.011006417305641662,-0.7027487513079647,-0.010875604672633637],[1,-178.2269585021126,89.30979241912084,-0.021281368875969202]],[1,"Shoulder_L",8388608,160,[-340],[1,-0.0035574783105403185,1.713056474450525e-9,0.000013887167369830422],[3,-0.03416188434654197,0.6426382066489487,-0.04061436654192732,0.7643294932444482],[1,-0.0012206380677393302,80.11329981341834,-6.08437942527354]],[1,"Elbow_L",8388608,161,[-341],[1,-0.005175452213734388,2.5535130029599743e-17,0],[3,-2.4193042033980414e-18,-3.69900388416738e-17,0.12233098131469163,0.9924893606535964],[1,2.5088938608155047e-16,-4.301746631616259e-15,14.053298599928233]],[8,"Wrist_L",8388608,162,[[7,"Cup_L",8388608,-342,[1,-0.0033151672687381506,-1.412758841187159e-16,0]]],[1,-0.005389300640672445,5.1625371042116473e-17,1.776356799695581e-17],[3,-0.004768474014740153,0.012352902409124579,0.0011546335850644365,0.999911663237771],[1,-0.5480227017072393,1.4161918210299922,0.12554971732357223]],[1,"Hip_R",8388608,43,[-343],[1,-0.0005149218486621976,-0.000035732064134208485,-0.0025951904244720936],[3,-0.0013684586941045457,0.9999846538917857,-0.00017622552207276294,0.0053654679472844545],[1,0.019352340864127352,179.38518562853085,-0.1569199549416445]],[1,"Knee_R",8388608,164,[-344],[1,0.008524451404809952,1.2628998541375225e-11,-1.1102229998097382e-18],[3,3.403632747743931e-20,-9.107188358042246e-19,-0.03350002364301262,0.9994387166884808],[1,4.029053682243933e-19,-1.0440579512036528e-16,-3.839538319810826]],[1,"Ankle_R",8388608,165,[-345],[1,0.007810377050191164,1.1571134675425476e-11,-8.311684436687009e-15],[3,0.0005231972268350271,0.005401740730554813,0.05058017697477186,0.998705258401568],[1,0.028714477331547906,0.6183360190684839,5.79877519893503]],[8,"Toes_R",8388608,166,[[7,"ToesEnd_R",8388608,-346,[1,0.0019366915803402662,-1.9886869822718998e-16,3.063116871260263e-9]]],[1,0.002095116302371025,0.002573760924860835,-1.1551194029069123e-11],[3,-0.0005855765799607817,0.0005394552157793537,0.6775491861260131,0.7354770332703235],[1,-1.1144865141882583,1.1107462304259765,85.3039958375585]],[1,"Hip_L",8388608,43,[-347],[1,-0.0005149218486621976,-0.000035732064134208485,0.0025951904244720936],[3,0.9999846538908325,0.0013684593925951528,-0.00536546794727934,-0.00017622550752068012],[1,-179.9806476612328,0.6148143714585114,0.15692003497274723]],[1,"Knee_L",8388608,168,[-348],[1,-0.008524451404809952,-1.2628998541375225e-11,4.6312953641644995e-15],[3,4.9250421584690475e-20,1.2367185778725194e-18,-0.03350002364301262,0.9994387166884808],[1,1.0411423292578889e-17,1.42146077062345e-16,-3.839538319810826]],[1,"Ankle_L",8388608,169,[-349],[1,-0.007810377050191164,-1.1571218809514061e-11,1.2550515978587175e-14],[3,0.0005231972268350271,0.005401740730554813,0.05058017697477186,0.998705258401568],[1,0.028714477331547906,0.6183360190684839,5.79877519893503]],[8,"Toes_L",8388608,170,[[7,"ToesEnd_L",8388608,-350,[1,-0.0019366915803402662,2.7755574995243454e-19,1.6754419032705137e-11]]],[1,-0.002095116302371025,-0.002573760924860835,8.517709974842358e-12],[3,-0.0005849927574888355,0.0005389178429919117,0.6775491865538494,0.7354770337347383],[1,-1.1133760861696482,1.1096395693191319,85.30399759925989]],[5,"melee_07_body",8388608,22,[[6,1,-351,[78],[3],9,79,80]]],[5,"melee_07_head",8388608,22,[[6,1,-352,[81],[3],9,82,83]]],[5,"melee_07_arm_L",8388608,22,[[6,1,-353,[84],[3],9,85,86]]],[5,"melee_07_leg_L",8388608,22,[[6,1,-354,[87],[3],9,88,89]]],[5,"melee_07_arm_R",8388608,22,[[6,1,-355,[90],[3],9,91,92]]],[5,"melee_07_leg_R",8388608,22,[[6,1,-356,[93],[3],9,94,95]]],[1,"Spine1_M",8388608,46,[47],[1,0.005334464367479086,-1.734723475976807e-18,4.299679912665751e-19],[3,2.1271160548415487e-31,-7.387287067052785e-18,0.014618982679226592,0.999893136962858],[1,1.2380563880610636e-17,-8.467922240252193e-16,1.6752716918878972]],[1,"Neck_M",8388608,47,[-357],[1,0.002714349888265133,-9.57567355430475e-18,8.572243914273824e-18],[3,2.334849548498401e-33,1.210279147626834e-32,-0.18942549962218294,0.9818950962770342],[1,5.66041439480744e-31,1.5216497485115417e-30,-21.83851784031204]],[8,"Head_M",8388608,179,[[7,"HeadEnd_M",8388608,-358,[1,0.002823290415108204,5.377642816887133e-19,2.8810669715948983e-19]]],[1,0.002050594659522176,-1.1102230411687688e-17,-1.1397885028539148e-18],[3,1.3712628330747433e-33,-7.748182116840672e-33,0.17427049577586698,0.9846978187759095],[1,3.2947363714137558e-31,-9.59983646203496e-31,20.07241655059164]],[1,"Scapula_R",8388608,47,[-359],[1,0.0011061389232054353,-0.0006425591418519616,-0.003000000026077032],[3,0.011006418236851384,0.7112698310246427,-0.010875604672522158,0.7027487513007612],[1,1.7730415728863935,90.69020757969066,0.021281444783464887]],[1,"Shoulder_R",8388608,181,[-360],[1,0.002950000111013651,2.9599587517625207e-16,4.440891999238953e-18],[3,-0.036766301506691725,0.6917510565886625,-0.038273904125047865,0.7201831871440867],[1,-0.0002833286279134703,87.69276567497838,-6.0844785186711885]],[1,"Elbow_R",8388608,182,[-361],[1,0.005175452213734388,-5.828670614584276e-17,-2.2204459996194763e-18],[3,-7.709045863072825e-19,8.488711171147105e-19,0.12233098131469163,0.9924893606535964],[1,-1.0264744435556117e-16,1.1066156643491841e-16,14.053298599928233]],[8,"Wrist_R",8388608,183,[[7,"Cup_R",8388608,-362,[1,0.0033151672687381506,5.218048202503346e-17,-2.2204459996194763e-18]]],[1,0.005389300640672445,-6.272760062662355e-17,-7.77156120546332e-18],[3,-0.004768474014740153,0.012352902409124579,0.0011546335850644365,0.999911663237771],[1,-0.5480227017072393,1.4161918210299922,0.12554971732357223]],[1,"Scapula_L",8388608,47,[-363],[1,0.0011061389232054353,-0.0006425591418519616,0.003000000026077032],[3,0.7112698310319335,-0.011006417305641662,-0.7027487513079647,-0.010875604672633637],[1,-178.2269585021126,89.30979241912084,-0.021281368875969202]],[1,"Shoulder_L",8388608,185,[-364],[1,-0.0029548665042966604,2.608999682962576e-9,4.440891999238953e-18],[3,-0.03676631640867874,0.6917510566042027,-0.03827388922474663,0.7201831871602655],[1,-0.0002857532309027007,87.69276554611803,-6.084478470121346]],[1,"Elbow_L",8388608,186,[-365],[1,-0.005175452213734388,2.609024101251673e-17,0],[3,-7.639352792941652e-19,-7.668803008362496e-19,0.12233098131469163,0.9924893606535964],[1,-7.848178543085077e-17,-7.886961667845593e-17,14.053298599928233]],[8,"Wrist_L",8388608,187,[[7,"Cup_L",8388608,-366,[1,-0.0033151672687381506,-1.4099832200981251e-16,1.1102229998097382e-18]]],[1,-0.005389300640672445,5.107026005919949e-17,1.6653346031121838e-17],[3,-0.004768474014740153,0.012352902409124579,0.0011546335850644365,0.999911663237771],[1,-0.5480227017072393,1.4161918210299922,0.12554971732357223]],[1,"Hip_R",8388608,46,[-367],[1,-0.0005149218486621976,-0.000035732064134208485,-0.0025951904244720936],[3,-0.0013684586941045457,0.9999846538917857,-0.00017622552207276294,0.0053654679472844545],[1,0.019352340864127352,179.38518562853085,-0.1569199549416445]],[1,"Knee_R",8388608,189,[-368],[1,0.008524451404809952,1.2628998541375225e-11,-1.1102229998097382e-18],[3,3.403632747743931e-20,-9.107188358042246e-19,-0.03350002364301262,0.9994387166884808],[1,4.029053682243933e-19,-1.0440579512036528e-16,-3.839538319810826]],[1,"Ankle_R",8388608,190,[-369],[1,0.007810377050191164,1.1571134675425476e-11,-8.311684436687009e-15],[3,0.0005231972268350271,0.005401740730554813,0.05058017697477186,0.998705258401568],[1,0.028714477331547906,0.6183360190684839,5.79877519893503]],[8,"Toes_R",8388608,191,[[7,"ToesEnd_R",8388608,-370,[1,0.0019366915803402662,-1.9886869822718998e-16,3.063116871260263e-9]]],[1,0.002095116302371025,0.002573760924860835,-1.1551194029069123e-11],[3,-0.0005855765799607817,0.0005394552157793537,0.6775491861260131,0.7354770332703235],[1,-1.1144865141882583,1.1107462304259765,85.3039958375585]],[1,"Hip_L",8388608,46,[-371],[1,-0.0005149218486621976,-0.000035732064134208485,0.0025951904244720936],[3,0.9999846538908325,0.0013684593925951528,-0.00536546794727934,-0.00017622550752068012],[1,-179.9806476612328,0.6148143714585114,0.15692003497274723]],[1,"Knee_L",8388608,193,[-372],[1,-0.008524451404809952,-1.2628998541375225e-11,4.6312953641644995e-15],[3,4.9250421584690475e-20,1.2367185778725194e-18,-0.03350002364301262,0.9994387166884808],[1,1.0411423292578889e-17,1.42146077062345e-16,-3.839538319810826]],[1,"Ankle_L",8388608,194,[-373],[1,-0.007810377050191164,-1.1571218809514061e-11,1.2550515978587175e-14],[3,0.0005231972268350271,0.005401740730554813,0.05058017697477186,0.998705258401568],[1,0.028714477331547906,0.6183360190684839,5.79877519893503]],[8,"Toes_L",8388608,195,[[7,"ToesEnd_L",8388608,-374,[1,-0.0019366915803402662,2.7755574995243454e-19,1.6754419032705137e-11]]],[1,-0.002095116302371025,-0.002573760924860835,8.517709974842358e-12],[3,-0.0005849927574888355,0.0005389178429919117,0.6775491865538494,0.7354770337347383],[1,-1.1133760861696482,1.1096395693191319,85.30399759925989]],[5,"melee_10_body",8388608,10,[[6,1,-375,[96],[3],3,97,98]]],[5,"melee_10_head",8388608,10,[[6,1,-376,[99],[3],3,100,101]]],[5,"melee_10_leg_L",8388608,10,[[6,1,-377,[102],[3],3,103,104]]],[5,"melee_10_leg_R",8388608,10,[[6,1,-378,[105],[3],3,106,107]]],[5,"melee_10_arm_L",8388608,10,[[6,1,-379,[108],[3],3,109,110]]],[5,"melee_10_arm_R",8388608,10,[[6,1,-380,[111],[3],3,112,113]]],[5,"melee_10_blade_L",8388608,10,[[6,1,-381,[114],[3],3,115,116]]],[5,"melee_10_blade_R",8388608,10,[[6,1,-382,[117],[3],3,118,119]]],[0,["c7bOimb2dLyq9O1ar9HEBQ"]],[0,["dd75xDNvFL5JL1FFRSWiHm"]],[61,"Optimus_2",false,8388608,68,[4],[1,0.5,-12.9,10.37],[3,0,-0.8660254037844386,0,0.5000000000000001],[1,35,35,35],[1,0,-120,0]],[1,"Spine1_M",8388608,48,[49],[1,0.005334464367479086,-1.734723475976807e-18,4.299679912665751e-19],[3,2.1271160548415487e-31,-7.387287067052785e-18,0.014618982679226592,0.999893136962858],[1,1.2380563880610636e-17,-8.467922240252193e-16,1.6752716918878972]],[1,"Neck_M",8388608,49,[-383],[1,0.002714349888265133,-9.57567355430475e-18,8.572243914273824e-18],[3,2.334849548498401e-33,1.210279147626834e-32,-0.18942549962218294,0.9818950962770342],[1,5.66041439480744e-31,1.5216497485115417e-30,-21.83851784031204]],[8,"Head_M",8388608,209,[[7,"HeadEnd_M",8388608,-384,[1,0.002823290415108204,5.377642816887133e-19,2.8810669715948983e-19]]],[1,0.002050594659522176,-1.1102230411687688e-17,-1.1397885028539148e-18],[3,1.3712628330747433e-33,-7.748182116840672e-33,0.17427049577586698,0.9846978187759095],[1,3.2947363714137558e-31,-9.59983646203496e-31,20.07241655059164]],[1,"Scapula_R",8388608,49,[-385],[1,0.0011061389232054353,-0.0006425591418519616,-0.003000000026077032],[3,0.011006418236851384,0.7112698310246427,-0.010875604672522158,0.7027487513007612],[1,1.7730415728863935,90.69020757969066,0.021281444783464887]],[1,"Shoulder_R",8388608,211,[-386],[1,0.002950000111013651,2.9599587517625207e-16,4.440891999238953e-18],[3,-0.036766301506691725,0.6917510565886625,-0.038273904125047865,0.7201831871440867],[1,-0.0002833286279134703,87.69276567497838,-6.0844785186711885]],[1,"Elbow_R",8388608,212,[-387],[1,0.005175452213734388,-5.828670614584276e-17,-2.2204459996194763e-18],[3,-7.709045863072825e-19,8.488711171147105e-19,0.12233098131469163,0.9924893606535964],[1,-1.0264744435556117e-16,1.1066156643491841e-16,14.053298599928233]],[8,"Wrist_R",8388608,213,[[7,"Cup_R",8388608,-388,[1,0.0033151672687381506,5.218048202503346e-17,-2.2204459996194763e-18]]],[1,0.005389300640672445,-6.272760062662355e-17,-7.77156120546332e-18],[3,-0.004768474014740153,0.012352902409124579,0.0011546335850644365,0.999911663237771],[1,-0.5480227017072393,1.4161918210299922,0.12554971732357223]],[1,"Scapula_L",8388608,49,[-389],[1,0.0011061389232054353,-0.0006425591418519616,0.003000000026077032],[3,0.7112698310319335,-0.011006417305641662,-0.7027487513079647,-0.010875604672633637],[1,-178.2269585021126,89.30979241912084,-0.021281368875969202]],[1,"Shoulder_L",8388608,215,[-390],[1,-0.0029548665042966604,2.608999682962576e-9,4.440891999238953e-18],[3,-0.03676631640867874,0.6917510566042027,-0.03827388922474663,0.7201831871602655],[1,-0.0002857532309027007,87.69276554611803,-6.084478470121346]],[1,"Elbow_L",8388608,216,[-391],[1,-0.005175452213734388,2.609024101251673e-17,0],[3,-7.639352792941652e-19,-7.668803008362496e-19,0.12233098131469163,0.9924893606535964],[1,-7.848178543085077e-17,-7.886961667845593e-17,14.053298599928233]],[8,"Wrist_L",8388608,217,[[7,"Cup_L",8388608,-392,[1,-0.0033151672687381506,-1.4099832200981251e-16,1.1102229998097382e-18]]],[1,-0.005389300640672445,5.107026005919949e-17,1.6653346031121838e-17],[3,-0.004768474014740153,0.012352902409124579,0.0011546335850644365,0.999911663237771],[1,-0.5480227017072393,1.4161918210299922,0.12554971732357223]],[1,"Hip_R",8388608,48,[-393],[1,-0.0005149218486621976,-0.000035732064134208485,-0.0025951904244720936],[3,-0.0013684586941045457,0.9999846538917857,-0.00017622552207276294,0.0053654679472844545],[1,0.019352340864127352,179.38518562853085,-0.1569199549416445]],[1,"Knee_R",8388608,219,[-394],[1,0.008524451404809952,1.2628998541375225e-11,-1.1102229998097382e-18],[3,3.403632747743931e-20,-9.107188358042246e-19,-0.03350002364301262,0.9994387166884808],[1,4.029053682243933e-19,-1.0440579512036528e-16,-3.839538319810826]],[1,"Ankle_R",8388608,220,[-395],[1,0.007810377050191164,1.1571134675425476e-11,-8.311684436687009e-15],[3,0.0005231972268350271,0.005401740730554813,0.05058017697477186,0.998705258401568],[1,0.028714477331547906,0.6183360190684839,5.79877519893503]],[8,"Toes_R",8388608,221,[[7,"ToesEnd_R",8388608,-396,[1,0.0019366915803402662,-1.9886869822718998e-16,3.063116871260263e-9]]],[1,0.002095116302371025,0.002573760924860835,-1.1551194029069123e-11],[3,-0.0005855765799607817,0.0005394552157793537,0.6775491861260131,0.7354770332703235],[1,-1.1144865141882583,1.1107462304259765,85.3039958375585]],[1,"Hip_L",8388608,48,[-397],[1,-0.0005149218486621976,-0.000035732064134208485,0.0025951904244720936],[3,0.9999846538908325,0.0013684593925951528,-0.00536546794727934,-0.00017622550752068012],[1,-179.9806476612328,0.6148143714585114,0.15692003497274723]],[1,"Knee_L",8388608,223,[-398],[1,-0.008524451404809952,-1.2628998541375225e-11,4.6312953641644995e-15],[3,4.9250421584690475e-20,1.2367185778725194e-18,-0.03350002364301262,0.9994387166884808],[1,1.0411423292578889e-17,1.42146077062345e-16,-3.839538319810826]],[1,"Ankle_L",8388608,224,[-399],[1,-0.007810377050191164,-1.1571218809514061e-11,1.2550515978587175e-14],[3,0.0005231972268350271,0.005401740730554813,0.05058017697477186,0.998705258401568],[1,0.028714477331547906,0.6183360190684839,5.79877519893503]],[8,"Toes_L",8388608,225,[[7,"ToesEnd_L",8388608,-400,[1,-0.0019366915803402662,2.7755574995243454e-19,1.6754419032705137e-11]]],[1,-0.002095116302371025,-0.002573760924860835,8.517709974842358e-12],[3,-0.0005849927574888355,0.0005389178429919117,0.6775491865538494,0.7354770337347383],[1,-1.1133760861696482,1.1096395693191319,85.30399759925989]],[5,"melee_10_body",8388608,11,[[6,1,-401,[128],[3],4,129,130]]],[5,"melee_10_head",8388608,11,[[6,1,-402,[131],[3],4,132,133]]],[5,"melee_10_leg_L",8388608,11,[[6,1,-403,[134],[3],4,135,136]]],[5,"melee_10_leg_R",8388608,11,[[6,1,-404,[137],[3],4,138,139]]],[5,"melee_10_arm_L",8388608,11,[[6,1,-405,[140],[3],4,141,142]]],[5,"melee_10_arm_R",8388608,11,[[6,1,-406,[143],[3],4,144,145]]],[5,"melee_10_blade_L",8388608,11,[[6,1,-407,[146],[3],4,147,148]]],[5,"melee_10_blade_R",8388608,11,[[6,1,-408,[149],[3],4,150,151]]],[61,"Optimus_Step1",false,8388608,17,[1],[1,-0.047,-12.932,10.4],[3,-0.21643961393810288,0,0,0.9762960071199334],[1,50,50,50],[1,-25,0,0]],[1,"Spine1_M",8388608,50,[51],[1,0.005334464367479086,-1.734723475976807e-18,4.299679912665751e-19],[3,2.1271160548415487e-31,-7.387287067052785e-18,0.014618982679226592,0.999893136962858],[1,1.2380563880610636e-17,-8.467922240252193e-16,1.6752716918878972]],[1,"Neck_M",8388608,51,[-409],[1,0.002714349888265133,-9.57567355430475e-18,8.572243914273824e-18],[3,2.334849548498401e-33,1.210279147626834e-32,-0.18942549962218294,0.9818950962770342],[1,5.66041439480744e-31,1.5216497485115417e-30,-21.83851784031204]],[8,"Head_M",8388608,237,[[7,"HeadEnd_M",8388608,-410,[1,0.002823290415108204,5.377642816887133e-19,2.8810669715948983e-19]]],[1,0.002050594659522176,-1.1102230411687688e-17,-1.1397885028539148e-18],[3,1.3712628330747433e-33,-7.748182116840672e-33,0.17427049577586698,0.9846978187759095],[1,3.2947363714137558e-31,-9.59983646203496e-31,20.07241655059164]],[1,"Scapula_R",8388608,51,[-411],[1,0.0011061389232054353,-0.0006425591418519616,-0.003000000026077032],[3,0.011006418236851384,0.7112698310246427,-0.010875604672522158,0.7027487513007612],[1,1.7730415728863935,90.69020757969066,0.021281444783464887]],[1,"Shoulder_R",8388608,239,[-412],[1,0.002950000111013651,2.9599587517625207e-16,4.440891999238953e-18],[3,-0.036766301506691725,0.6917510565886625,-0.038273904125047865,0.7201831871440867],[1,-0.0002833286279134703,87.69276567497838,-6.0844785186711885]],[1,"Elbow_R",8388608,240,[-413],[1,0.005175452213734388,-5.828670614584276e-17,-2.2204459996194763e-18],[3,-7.709045863072825e-19,8.488711171147105e-19,0.12233098131469163,0.9924893606535964],[1,-1.0264744435556117e-16,1.1066156643491841e-16,14.053298599928233]],[8,"Wrist_R",8388608,241,[[7,"Cup_R",8388608,-414,[1,0.0033151672687381506,5.218048202503346e-17,-2.2204459996194763e-18]]],[1,0.005389300640672445,-6.272760062662355e-17,-7.77156120546332e-18],[3,-0.004768474014740153,0.012352902409124579,0.0011546335850644365,0.999911663237771],[1,-0.5480227017072393,1.4161918210299922,0.12554971732357223]],[1,"Scapula_L",8388608,51,[-415],[1,0.0011061389232054353,-0.0006425591418519616,0.003000000026077032],[3,0.7112698310319335,-0.011006417305641662,-0.7027487513079647,-0.010875604672633637],[1,-178.2269585021126,89.30979241912084,-0.021281368875969202]],[1,"Shoulder_L",8388608,243,[-416],[1,-0.0029548665042966604,2.608999682962576e-9,4.440891999238953e-18],[3,-0.03676631640867874,0.6917510566042027,-0.03827388922474663,0.7201831871602655],[1,-0.0002857532309027007,87.69276554611803,-6.084478470121346]],[1,"Elbow_L",8388608,244,[-417],[1,-0.005175452213734388,2.609024101251673e-17,0],[3,-7.639352792941652e-19,-7.668803008362496e-19,0.12233098131469163,0.9924893606535964],[1,-7.848178543085077e-17,-7.886961667845593e-17,14.053298599928233]],[8,"Wrist_L",8388608,245,[[7,"Cup_L",8388608,-418,[1,-0.0033151672687381506,-1.4099832200981251e-16,1.1102229998097382e-18]]],[1,-0.005389300640672445,5.107026005919949e-17,1.6653346031121838e-17],[3,-0.004768474014740153,0.012352902409124579,0.0011546335850644365,0.999911663237771],[1,-0.5480227017072393,1.4161918210299922,0.12554971732357223]],[1,"Hip_R",8388608,50,[-419],[1,-0.0005149218486621976,-0.000035732064134208485,-0.0025951904244720936],[3,-0.0013684586941045457,0.9999846538917857,-0.00017622552207276294,0.0053654679472844545],[1,0.019352340864127352,179.38518562853085,-0.1569199549416445]],[1,"Knee_R",8388608,247,[-420],[1,0.008524451404809952,1.2628998541375225e-11,-1.1102229998097382e-18],[3,3.403632747743931e-20,-9.107188358042246e-19,-0.03350002364301262,0.9994387166884808],[1,4.029053682243933e-19,-1.0440579512036528e-16,-3.839538319810826]],[1,"Ankle_R",8388608,248,[-421],[1,0.007810377050191164,1.1571134675425476e-11,-8.311684436687009e-15],[3,0.0005231972268350271,0.005401740730554813,0.05058017697477186,0.998705258401568],[1,0.028714477331547906,0.6183360190684839,5.79877519893503]],[8,"Toes_R",8388608,249,[[7,"ToesEnd_R",8388608,-422,[1,0.0019366915803402662,-1.9886869822718998e-16,3.063116871260263e-9]]],[1,0.002095116302371025,0.002573760924860835,-1.1551194029069123e-11],[3,-0.0005855765799607817,0.0005394552157793537,0.6775491861260131,0.7354770332703235],[1,-1.1144865141882583,1.1107462304259765,85.3039958375585]],[1,"Hip_L",8388608,50,[-423],[1,-0.0005149218486621976,-0.000035732064134208485,0.0025951904244720936],[3,0.9999846538908325,0.0013684593925951528,-0.00536546794727934,-0.00017622550752068012],[1,-179.9806476612328,0.6148143714585114,0.15692003497274723]],[1,"Knee_L",8388608,251,[-424],[1,-0.008524451404809952,-1.2628998541375225e-11,4.6312953641644995e-15],[3,4.9250421584690475e-20,1.2367185778725194e-18,-0.03350002364301262,0.9994387166884808],[1,1.0411423292578889e-17,1.42146077062345e-16,-3.839538319810826]],[1,"Ankle_L",8388608,252,[-425],[1,-0.007810377050191164,-1.1571218809514061e-11,1.2550515978587175e-14],[3,0.0005231972268350271,0.005401740730554813,0.05058017697477186,0.998705258401568],[1,0.028714477331547906,0.6183360190684839,5.79877519893503]],[8,"Toes_L",8388608,253,[[7,"ToesEnd_L",8388608,-426,[1,-0.0019366915803402662,2.7755574995243454e-19,1.6754419032705137e-11]]],[1,-0.002095116302371025,-0.002573760924860835,8.517709974842358e-12],[3,-0.0005849927574888355,0.0005389178429919117,0.6775491865538494,0.7354770337347383],[1,-1.1133760861696482,1.1096395693191319,85.30399759925989]],[5,"melee_10_body",8388608,12,[[6,1,-427,[155],[3],1,156,157]]],[5,"melee_10_head",8388608,12,[[6,1,-428,[158],[3],1,159,160]]],[5,"melee_10_leg_L",8388608,12,[[6,1,-429,[161],[3],1,162,163]]],[5,"melee_10_leg_R",8388608,12,[[6,1,-430,[164],[3],1,165,166]]],[5,"melee_10_arm_L",8388608,12,[[6,1,-431,[167],[3],1,168,169]]],[5,"melee_10_arm_R",8388608,12,[[6,1,-432,[170],[3],1,171,172]]],[5,"melee_10_blade_L",8388608,12,[[6,1,-433,[173],[3],1,174,175]]],[5,"melee_10_blade_R",8388608,12,[[6,1,-434,[176],[3],1,177,178]]],[1,"Spine1_M",8388608,52,[53],[1,0.005334464367479086,-1.734723475976807e-18,4.299679912665751e-19],[3,2.1271160548415487e-31,-7.387287067052785e-18,0.014618982679226592,0.999893136962858],[1,1.2380563880610636e-17,-8.467922240252193e-16,1.6752716918878972]],[1,"Neck_M",8388608,53,[-435],[1,0.002714349888265133,-9.57567355430475e-18,8.572243914273824e-18],[3,2.334849548498401e-33,1.210279147626834e-32,-0.18942549962218294,0.9818950962770342],[1,5.66041439480744e-31,1.5216497485115417e-30,-21.83851784031204]],[8,"Head_M",8388608,264,[[7,"HeadEnd_M",8388608,-436,[1,0.002823290415108204,5.377642816887133e-19,2.8810669715948983e-19]]],[1,0.002050594659522176,-1.1102230411687688e-17,-1.1397885028539148e-18],[3,1.3712628330747433e-33,-7.748182116840672e-33,0.17427049577586698,0.9846978187759095],[1,3.2947363714137558e-31,-9.59983646203496e-31,20.07241655059164]],[1,"Scapula_R",8388608,53,[-437],[1,0.0011061389232054353,-0.0006425591418519616,-0.003000000026077032],[3,0.011006418236851384,0.7112698310246427,-0.010875604672522158,0.7027487513007612],[1,1.7730415728863935,90.69020757969066,0.021281444783464887]],[1,"Shoulder_R",8388608,266,[-438],[1,0.002950000111013651,2.9599587517625207e-16,4.440891999238953e-18],[3,-0.036766301506691725,0.6917510565886625,-0.038273904125047865,0.7201831871440867],[1,-0.0002833286279134703,87.69276567497838,-6.0844785186711885]],[1,"Elbow_R",8388608,267,[-439],[1,0.005175452213734388,-5.828670614584276e-17,-2.2204459996194763e-18],[3,-7.709045863072825e-19,8.488711171147105e-19,0.12233098131469163,0.9924893606535964],[1,-1.0264744435556117e-16,1.1066156643491841e-16,14.053298599928233]],[8,"Wrist_R",8388608,268,[[7,"Cup_R",8388608,-440,[1,0.0033151672687381506,5.218048202503346e-17,-2.2204459996194763e-18]]],[1,0.005389300640672445,-6.272760062662355e-17,-7.77156120546332e-18],[3,-0.004768474014740153,0.012352902409124579,0.0011546335850644365,0.999911663237771],[1,-0.5480227017072393,1.4161918210299922,0.12554971732357223]],[1,"Scapula_L",8388608,53,[-441],[1,0.0011061389232054353,-0.0006425591418519616,0.003000000026077032],[3,0.7112698310319335,-0.011006417305641662,-0.7027487513079647,-0.010875604672633637],[1,-178.2269585021126,89.30979241912084,-0.021281368875969202]],[1,"Shoulder_L",8388608,270,[-442],[1,-0.0029548665042966604,2.608999682962576e-9,0.000021150273823877797],[3,-0.03882624986063326,0.6508737856280458,-0.03618252307268142,0.7573286357507361],[1,-0.6745852782266888,81.31811907479812,-6.047107114000744]],[1,"Elbow_L",8388608,271,[-443],[1,-0.005175452213734388,2.609024101251673e-17,0],[3,3.278061266432535e-19,1.8611321017625682e-17,0.12233098131469163,0.9924893606535964],[1,-2.305128209301622e-16,2.17725170284255e-15,14.053298599928233]],[8,"Wrist_L",8388608,272,[[7,"Cup_L",8388608,-444,[1,-0.0033151672687381506,-1.415534329927295e-16,0]]],[1,-0.005389300640672445,5.134781555065798e-17,1.6653346031121838e-17],[3,-0.004768474014740153,0.012352902409124579,0.0011546335850644365,0.999911663237771],[1,-0.5480227017072393,1.4161918210299922,0.12554971732357223]],[1,"Hip_R",8388608,52,[-445],[1,-0.0005149218486621976,-0.000035732064134208485,-0.0025951904244720936],[3,-0.0013684586941045457,0.9999846538917857,-0.00017622552207276294,0.0053654679472844545],[1,0.019352340864127352,179.38518562853085,-0.1569199549416445]],[1,"Knee_R",8388608,274,[-446],[1,0.008524451404809952,1.2628998541375225e-11,-1.1102229998097382e-18],[3,3.403632747743931e-20,-9.107188358042246e-19,-0.03350002364301262,0.9994387166884808],[1,4.029053682243933e-19,-1.0440579512036528e-16,-3.839538319810826]],[1,"Ankle_R",8388608,275,[-447],[1,0.007810377050191164,1.1571134675425476e-11,-8.311684436687009e-15],[3,0.0005231972268350271,0.005401740730554813,0.05058017697477186,0.998705258401568],[1,0.028714477331547906,0.6183360190684839,5.79877519893503]],[8,"Toes_R",8388608,276,[[7,"ToesEnd_R",8388608,-448,[1,0.0019366915803402662,-1.9886869822718998e-16,3.063116871260263e-9]]],[1,0.002095116302371025,0.002573760924860835,-1.1551194029069123e-11],[3,-0.0005855765799607817,0.0005394552157793537,0.6775491861260131,0.7354770332703235],[1,-1.1144865141882583,1.1107462304259765,85.3039958375585]],[1,"Hip_L",8388608,52,[-449],[1,-0.0005149218486621976,-0.000035732064134208485,0.0025951904244720936],[3,0.9999846538908325,0.0013684593925951528,-0.00536546794727934,-0.00017622550752068012],[1,-179.9806476612328,0.6148143714585114,0.15692003497274723]],[1,"Knee_L",8388608,278,[-450],[1,-0.008524451404809952,-1.2628998541375225e-11,4.6312953641644995e-15],[3,4.9250421584690475e-20,1.2367185778725194e-18,-0.03350002364301262,0.9994387166884808],[1,1.0411423292578889e-17,1.42146077062345e-16,-3.839538319810826]],[1,"Ankle_L",8388608,279,[-451],[1,-0.007810377050191164,-1.1571218809514061e-11,1.2550515978587175e-14],[3,0.0005231972268350271,0.005401740730554813,0.05058017697477186,0.998705258401568],[1,0.028714477331547906,0.6183360190684839,5.79877519893503]],[8,"Toes_L",8388608,280,[[7,"ToesEnd_L",8388608,-452,[1,-0.0019366915803402662,2.7755574995243454e-19,1.6754419032705137e-11]]],[1,-0.002095116302371025,-0.002573760924860835,8.517709974842358e-12],[3,-0.0005849927574888355,0.0005389178429919117,0.6775491865538494,0.7354770337347383],[1,-1.1133760861696482,1.1096395693191319,85.30399759925989]],[5,"melee_02_body",8388608,15,[[6,1,-453,[186],[3],2,187,188]]],[5,"melee_02_wing",8388608,15,[[6,1,-454,[189],[3],2,190,191]]],[5,"melee_02_head",8388608,15,[[6,1,-455,[192],[3],2,193,194]]],[5,"melee_02_arm_L",8388608,15,[[6,1,-456,[195],[3],2,196,197]]],[5,"melee_02_leg_R",8388608,15,[[6,1,-457,[198],[3],2,199,200]]],[5,"melee_02_leg_L",8388608,15,[[6,1,-458,[201],[3],2,202,203]]],[5,"melee_02_arm_R",8388608,15,[[6,1,-459,[204],[3],2,205,206]]],[27,"Level",8388608,2,[[21,"Quad<ModelComponent>",-460,[207],[3],208]],[1,0,0.039,-0.011],[1,0.0125,0.009259,1]],[62,"Node",8388608,72,[-461],[1,0,2.191,3.527],[1,0.2,0.2,0.2]],[48,"Field_Line",8388608,290,[[21,"Quad<ModelComponent>",-462,[212],[3],213]],[1,0,1.8,4.885],[3,-0.7071067811865475,0,0,0.7071067811865476],[1,17.09375,0.5,0.5],[1,-90,0,0]],[62,"Map5",8388608,72,[73],[1,-0.096,-0.599,5.111],[1,0.8,0.8,0.8]],[23,"building_bg_01_bot",8388608,13,[[22,-463,[214],[3],215]],[1,0,1.7100000381469727,0]],[23,"building_bg_01_mid",8388608,13,[[22,-464,[216],[3],217]],[1,0,1.340000033378601,0]],[23,"building_bg_01_top",8388608,13,[[22,-465,[218],[3],219]],[1,0,0.75,0]],[5,"platform_01",8388608,13,[[22,-466,[220],[3],221]]],[5,"platform_floor_01",8388608,13,[[22,-467,[222],[3],223]]],[23,"building_bg_01_bot-001",8388608,13,[[22,-468,[225],[3],226]],[1,20.14,1.71,0]],[23,"building_bg_01_bot-002",8388608,13,[[22,-469,[227],[3],228]],[1,-21.283,1.71,0]],[40,"Fog",false,8388608,73,[[22,-470,[229],[3],230]],[1,0,0.41999998688697815,-0.03999999910593033],[3,0.03786456151175037,0,0,0.9992828803604727],[1,100,100,100],[1,4.33999661734952,0,0]],[99,"Directional Light",28,[[153,15000,100000,2.604166666666667,-471,[154]]],[3,-0.16212140625488797,0.24437949980110402,-0.20879181975309916,0.9329529922322395],[1,-13.117,26.078,-27.958]],[65,"Responisve","0dLV1lXMxAorRkyZzhNv/a",14,[[155,-472,27]]],[65,"TouchAreaController","cbdS8PWC5K/7ZHW8F95fDM",14,[[156,-474,-473,23,27,65]]],[157,23],[46,"IronSource","c0HBwLvpVGZIfoccaEg+GP",14,[304]]],0,[0,0,1,0,0,1,0,0,1,0,18,71,0,19,27,0,20,23,0,0,1,0,-1,50,0,-2,12,0,-3,71,0,0,2,0,-2,93,0,0,2,0,0,2,0,-1,52,0,-2,15,0,-3,289,0,0,3,0,0,3,0,0,3,0,-1,46,0,-2,10,0,0,4,0,0,4,0,0,4,0,-1,48,0,-2,11,0,0,5,0,-1,39,0,-2,18,0,-3,19,0,-4,66,0,-5,125,0,0,6,0,-1,41,0,-2,20,0,-3,21,0,-4,67,0,-5,152,0,0,7,0,21,77,0,0,7,0,0,7,0,-1,76,0,-2,29,0,-3,30,0,-4,58,0,-5,59,0,-6,60,0,-7,16,0,-1,23,0,-1,79,0,-2,81,0,-3,83,0,-4,85,0,-5,87,0,-6,88,0,-7,89,0,-8,91,0,0,9,0,-1,43,0,-2,22,0,-1,197,0,-2,198,0,-3,199,0,-4,200,0,-5,201,0,-6,202,0,-7,203,0,-8,204,0,-1,227,0,-2,228,0,-3,229,0,-4,230,0,-5,231,0,-6,232,0,-7,233,0,-8,234,0,-1,255,0,-2,256,0,-3,257,0,-4,258,0,-5,259,0,-6,260,0,-7,261,0,-8,262,0,-1,293,0,-2,294,0,-3,295,0,-4,296,0,-5,297,0,-6,54,0,-7,298,0,-8,299,0,-1,31,0,-2,32,0,-3,33,0,-4,19,0,-5,21,0,-6,69,0,11,31,0,12,31,0,11,32,0,12,32,0,11,33,0,12,33,0,11,19,0,12,19,0,11,19,0,12,19,0,11,21,0,12,21,0,11,21,0,12,21,0,-1,74,0,-2,35,0,-3,302,0,-4,78,0,-6,303,0,-7,305,0,-1,282,0,-2,283,0,-3,284,0,-4,285,0,-5,286,0,-6,287,0,-7,288,0,0,16,0,0,16,0,-1,61,0,-2,62,0,-3,63,0,-4,64,0,-1,94,0,-2,37,0,-3,38,0,-4,68,0,-5,235,0,-1,117,0,-2,118,0,-3,119,0,-4,120,0,-5,121,0,-6,122,0,4,123,0,4,124,0,4,123,0,4,124,0,9,19,0,-1,145,0,-2,146,0,-3,147,0,-4,148,0,-5,149,0,-6,150,0,4,151,0,4,151,0,9,21,0,-1,172,0,-2,173,0,-3,174,0,-4,175,0,-5,176,0,-6,177,0,-1,75,0,0,28,0,0,28,0,-1,301,0,0,29,0,0,29,0,0,29,0,0,30,0,-1,55,0,-2,56,0,-3,57,0,4,95,0,4,95,0,9,31,0,4,96,0,4,96,0,9,32,0,4,97,0,4,97,0,9,33,0,-1,72,0,22,93,0,23,65,0,0,35,0,0,36,0,0,36,0,0,36,0,-1,98,0,-2,109,0,-3,113,0,-1,99,0,-2,101,0,-3,105,0,-1,126,0,-2,137,0,-3,141,0,-1,127,0,-2,129,0,-3,133,0,-1,153,0,-2,164,0,-3,168,0,-1,154,0,-2,156,0,-3,160,0,-2,69,0,-3,70,0,-1,178,0,-2,189,0,-3,193,0,-1,179,0,-2,181,0,-3,185,0,-1,208,0,-2,219,0,-3,223,0,-1,209,0,-2,211,0,-3,215,0,-1,236,0,-2,247,0,-3,251,0,-1,237,0,-2,239,0,-3,243,0,-1,263,0,-2,274,0,-3,278,0,-1,264,0,-2,266,0,-3,270,0,0,54,0,0,54,0,0,54,0,0,55,0,0,55,0,0,56,0,0,56,0,0,57,0,0,57,0,0,58,0,0,59,0,0,59,0,0,60,0,0,60,0,0,61,0,0,61,0,0,62,0,0,62,0,0,63,0,0,63,0,0,64,0,0,64,0,0,66,0,0,66,0,0,67,0,0,67,0,-2,207,0,4,205,0,4,206,0,4,205,0,4,206,0,9,69,0,0,70,0,0,70,0,0,71,0,-1,290,0,-2,292,0,-2,300,0,-1,77,0,-1,80,0,-1,82,0,-1,84,0,-1,86,0,0,87,0,0,88,0,-1,90,0,-1,92,0,-1,100,0,2,100,0,-1,102,0,-1,103,0,-1,104,0,2,104,0,-1,106,0,-1,107,0,-1,108,0,2,108,0,-1,110,0,-1,111,0,-1,112,0,2,112,0,-1,114,0,-1,115,0,-1,116,0,2,116,0,0,117,0,0,118,0,0,119,0,0,120,0,0,121,0,0,122,0,0,125,0,-1,128,0,2,128,0,-1,130,0,-1,131,0,-1,132,0,2,132,0,-1,134,0,-1,135,0,-1,136,0,2,136,0,-1,138,0,-1,139,0,-1,140,0,2,140,0,-1,142,0,-1,143,0,-1,144,0,2,144,0,0,145,0,0,146,0,0,147,0,0,148,0,0,149,0,0,150,0,0,152,0,-1,155,0,2,155,0,-1,157,0,-1,158,0,-1,159,0,2,159,0,-1,161,0,-1,162,0,-1,163,0,2,163,0,-1,165,0,-1,166,0,-1,167,0,2,167,0,-1,169,0,-1,170,0,-1,171,0,2,171,0,0,172,0,0,173,0,0,174,0,0,175,0,0,176,0,0,177,0,-1,180,0,2,180,0,-1,182,0,-1,183,0,-1,184,0,2,184,0,-1,186,0,-1,187,0,-1,188,0,2,188,0,-1,190,0,-1,191,0,-1,192,0,2,192,0,-1,194,0,-1,195,0,-1,196,0,2,196,0,0,197,0,0,198,0,0,199,0,0,200,0,0,201,0,0,202,0,0,203,0,0,204,0,-1,210,0,2,210,0,-1,212,0,-1,213,0,-1,214,0,2,214,0,-1,216,0,-1,217,0,-1,218,0,2,218,0,-1,220,0,-1,221,0,-1,222,0,2,222,0,-1,224,0,-1,225,0,-1,226,0,2,226,0,0,227,0,0,228,0,0,229,0,0,230,0,0,231,0,0,232,0,0,233,0,0,234,0,-1,238,0,2,238,0,-1,240,0,-1,241,0,-1,242,0,2,242,0,-1,244,0,-1,245,0,-1,246,0,2,246,0,-1,248,0,-1,249,0,-1,250,0,2,250,0,-1,252,0,-1,253,0,-1,254,0,2,254,0,0,255,0,0,256,0,0,257,0,0,258,0,0,259,0,0,260,0,0,261,0,0,262,0,-1,265,0,2,265,0,-1,267,0,-1,268,0,-1,269,0,2,269,0,-1,271,0,-1,272,0,-1,273,0,2,273,0,-1,275,0,-1,276,0,-1,277,0,2,277,0,-1,279,0,-1,280,0,-1,281,0,2,281,0,0,282,0,0,283,0,0,284,0,0,285,0,0,286,0,0,287,0,0,288,0,0,289,0,-1,291,0,0,291,0,0,293,0,0,294,0,0,295,0,0,296,0,0,297,0,0,298,0,0,299,0,0,300,0,0,301,0,0,302,0,24,304,0,0,303,0,25,14,1,2,235,2,2,94,3,2,45,4,2,207,5,2,38,6,2,38,7,2,35,8,2,14,9,2,38,13,2,73,17,2,34,23,26,86,23,27,82,23,28,90,23,29,92,23,30,84,23,31,80,27,32,29,27,33,75,27,0,74,28,2,34,31,2,37,32,2,37,33,2,37,34,2,35,36,2,58,40,2,98,42,2,126,44,2,153,45,2,68,47,2,178,49,2,208,51,2,236,53,2,263,65,0,78,73,2,292,304,0,305,474],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,80,82,84,86,90,92],[8,-1,6,8,8,8,8,-1,6,34,8,8,8,8,8,-1,6,10,10,14,14,14,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,14,-1,1,-1,6,-1,1,-1,-2,6,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,14,-1,1,-1,6,-1,1,-1,-2,6,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,-2,6,14,-1,1,-1,6,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,-2,6,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,-1,-2,-3,-4,6,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,3,-1,1,-1,-2,-3,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,6,35,36,10,10,10,10,10,10],[6,47,47,6,6,6,70,48,48,71,72,6,73,74,75,49,49,76,77,12,12,12,0,13,14,0,15,16,0,17,18,0,19,20,0,21,22,0,23,24,25,26,3,4,4,50,3,5,9,9,0,13,14,0,15,16,0,17,18,0,19,20,0,21,22,0,23,24,25,26,3,4,4,50,3,5,9,9,0,13,14,0,15,16,0,17,18,0,19,20,0,21,22,0,23,24,1,27,28,1,29,30,1,31,32,1,33,34,1,35,36,1,37,38,1,39,40,1,41,42,7,5,5,25,26,3,4,4,1,27,28,1,29,30,1,31,32,1,33,34,1,35,36,1,37,38,1,39,40,1,41,42,7,5,5,1,27,28,1,29,30,1,31,32,1,33,34,1,35,36,1,37,38,1,39,40,1,41,42,78,3,7,51,79,80,7,0,81,82,0,83,84,0,85,86,0,87,88,0,89,90,0,91,92,0,93,94,95,3,7,96,51,97,3,8,43,8,98,8,99,100,101,102,103,104,8,43,8,43,105,106,52,52,107,108,109,110,111,112,113,114]],[[[17,"sfx_win",".mp3",2.069333],-1],0,0,[],[],[]],[[[17,"bg_main(1)",".mp3",19.56],-1],0,0,[],[],[]],[[[17,"sfx_rocket1(1)",".mp3",0.893333],-1],0,0,[],[],[]],[[[38,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true,"USE_ALBEDO_MAP":true,"USE_METALLIC_ROUGHNESS_MAP":true,"USE_OCCLUSION_MAP":true,"USE_EMISSIVE_MAP":true},{},{}],[[[{"roughness":0.15,"metallic":0.65},"albedoScale",8,[1,1.5,1.5,1.5],"mainTexture",6,0,"metallicRoughnessMap",6,1,"occlusionMap",6,2,"emissiveMap",6,3],{},{}],11,0,0]]],0,0,[0,0,0,0,0],[7,37,38,39,5],[10,10,10,10,2]]]]
