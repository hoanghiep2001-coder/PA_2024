[1,["28x68I08tKwqUgRgqSZY3u","306efPA0VAepWohoSyWEXL","adFj3JcEZNabOAtAOTI+9s@6c48a","dekWuT619A/q1w1/RRuOyC","12Y9dMgWdJKJGmTiZyQR9H@a804a","3dQRl9999Ln48uZMmJUNbH","1brw/JvvpFnIvdrxpFCgMZ","327Eau3p1KoI1OILp375fz","58JCT6TCdMAZnc4TCE6hoW","d6mOIqaoFHxJ2MWdGyABjA","18jY5QeThPTa7dCH0bZGAc","daTD5QLjlE2IHqyf/C+AaJ","4bZDSSVblK26WEVRzRq3tn@0c841","f52GR0Ib5KFa+bCO4gUjbh","d1NGQ2rJZCcbhjH0/erZWw","5ctFLl/cJMRIhD5/iGUcCB@80c75","5ctFLl/cJMRIhD5/iGUcCB@ff8ed","12Y9dMgWdJKJGmTiZyQR9H@fc873","e1Vxu1v81BcKrpoGMd64qf","86GjebjoVLmYXNs9a9pg/O@b3a4e","86GjebjoVLmYXNs9a9pg/O@a936f","86GjebjoVLmYXNs9a9pg/O@abcf7","86GjebjoVLmYXNs9a9pg/O@0eef8","86GjebjoVLmYXNs9a9pg/O@3b708","86GjebjoVLmYXNs9a9pg/O@bb92a","86GjebjoVLmYXNs9a9pg/O@dde5c","86GjebjoVLmYXNs9a9pg/O@13853","86GjebjoVLmYXNs9a9pg/O@94a35","86GjebjoVLmYXNs9a9pg/O@f78f3","86GjebjoVLmYXNs9a9pg/O@ac63e","86GjebjoVLmYXNs9a9pg/O@b13bd","86GjebjoVLmYXNs9a9pg/O@ff196","86GjebjoVLmYXNs9a9pg/O@8921a","86GjebjoVLmYXNs9a9pg/O@39332","86GjebjoVLmYXNs9a9pg/O@c3c84","86GjebjoVLmYXNs9a9pg/O@b0e2d","86GjebjoVLmYXNs9a9pg/O@5e7fd","86GjebjoVLmYXNs9a9pg/O@8b436","86GjebjoVLmYXNs9a9pg/O@7076d","86GjebjoVLmYXNs9a9pg/O@0f747","86GjebjoVLmYXNs9a9pg/O@1142d","86GjebjoVLmYXNs9a9pg/O@c228e","86GjebjoVLmYXNs9a9pg/O@de95e","214ncfEupO/ZqevD3MdL4v@6c48a","52vf0vl2VCIIG7oj5WyUi9@6c48a","6caxowAWhAT4A/zNPB/TVA","386D/5q0hHBrKpe8g95ETV@ffa6a","a1mEBg+QlDZrAolqiT5z8D","6cSzmCVxZAK6tMfJs2Oyd4@29327","377R8c85FK4Kq8wHfX+ut/","e5z0AfRGFPrpIsh8yybzCP@c2762","4bZDSSVblK26WEVRzRq3tn@6da96","4e0J8yuxRGY7Q9IsdtqBVE","30MEMp/qFOKaiMB7fkbBaw","4fpjdKWEtMxJ/UDDkkfnP7@5369c","4fpjdKWEtMxJ/UDDkkfnP7@e9151","4fpjdKWEtMxJ/UDDkkfnP7@ac9ae","15odNLxHZNOL3O0SEMXCEB@d0e86","15odNLxHZNOL3O0SEMXCEB@30732","204urOeBBFb6okeRgZ/Mqp@52d44","78XW5GxOhAd6p2lnTVeP4d@f9941","2eEaZj+GpA3445jGNIbTJG@f9941","5eqcFo77ZHoqnCyByekAus","2aXH9TKYJA2rjYSsF90buD@f9941","7dj5uJT9FMn6OrOOx83tfK@f9941","dcCTiT2PVBO4UvIzXQfNk9@f9941","4ddd7ZHC5HvIu9o+AIJWFx","78QsGkwjtJmbbd8ilB3p7E","484fWGDNhJA7rUhXk5l1nK@59b9b","b2MxkzZKxHeq7NsiMjm/Lr@6c48a","3fqRnCheBLuYh8+9JsK5Ci","41AtY+9wlBh5iT+l3zm8Ft","c6q4qImG9J8qs7j3XMkTZj@6c48a","b7wS4ssk9NqbyI19bmAGNP@6c48a","6d2oscZpdLZbAdfTnJcCOn","12Y9dMgWdJKJGmTiZyQR9H@2e76e","a4f1KGfAZNxJ7dF4dvQejD@9177b","36MImJPctK5pVk4bS1fEWB","2cnB0UpNBL4LoEkPi7fmB4@18cc7","2cnB0UpNBL4LoEkPi7fmB4@96715","a851jW/G9IdKpbyUeIH3i8","cdzWAOlmZAyIeWQtE22GQN","dbhkAO1P1C9aUAmP7m6RoS","06byByTIZOqY5vs86dF7G1@08bc7","42N/vGm0NP3KS6FHmo0EzW","06byByTIZOqY5vs86dF7G1@0f51f","06byByTIZOqY5vs86dF7G1@c1428","0bo60bkUtBP6/C1hjInHgv@557f6","0bo60bkUtBP6/C1hjInHgv@f1394","0bo60bkUtBP6/C1hjInHgv@a8d51","0bo60bkUtBP6/C1hjInHgv@75ee4","0bo60bkUtBP6/C1hjInHgv@38cc2","0bo60bkUtBP6/C1hjInHgv@a72ab","c4i/KZ0wFOaYQ6r7JW0KxI@61b85","5dbVvn+olAg4I5LaULAS+p@f9941","5aYelt7SZIzat2vnJTRi7a@f9941","e71uS35VpPpbPKtBCx7x94@f9941","41czDe+hJIArQqaw4XZ+L6@f9941","bdlD1yPolAV6FO+5ND3N7x@f9941","50LQlrSVNMD70mm+01Hc0E@f9941","322PyWMu1CPbla5d4dpwqk@d91b1","322PyWMu1CPbla5d4dpwqk@30732","322PyWMu1CPbla5d4dpwqk@6a552","322PyWMu1CPbla5d4dpwqk@f1394","322PyWMu1CPbla5d4dpwqk@76091","322PyWMu1CPbla5d4dpwqk@75ee4","322PyWMu1CPbla5d4dpwqk@09abd","322PyWMu1CPbla5d4dpwqk@a72ab","b2WwVSEcZMWI7j8RUhp6bq","322PyWMu1CPbla5d4dpwqk@42489","983/v+dBZMAJUGpWhi6J2q","acf33jIc1KVokpcWfkvBFY@7c4de","36nibey9NCiqHe9PmCzwij@414d7","d0MqyYBeFAkIi762QNy1/B@b47c0","6fAc9/gb9Kfr1dCvwZaWSA@b47c0","08CNDfqHdHH5fS72QJAIIb","f0uSF7Rv9MiZ12Eh2FR58Z","1f6yUxR0BADJeOdFSL/fW6","b74CgMjsZAXZw09YGFU9Xt","a8Qca+HRJD9oTrrFFJbLq7","6dSU56YQFEk76qms+2+GrU","11J76iKIJI4rl2cdSiENoe","00pj48/lFKA4Kmttu3DnSi","f81y4yLaFHCocibYs7JUiD","2aXH9TKYJA2rjYSsF90buD@6c48a","2eEaZj+GpA3445jGNIbTJG@6c48a","4cvCa1mgxPlLhFCZMoZz6x@6c48a","82YlGVG2lAU43r3KX6/SUr","41czDe+hJIArQqaw4XZ+L6@6c48a","96ISdYN/pKSK1CQW/sEPvF@6c48a","50LQlrSVNMD70mm+01Hc0E@6c48a","acRkRdhndJooQl+r58DQxS@6c48a","5aYelt7SZIzat2vnJTRi7a@6c48a","5dbVvn+olAg4I5LaULAS+p@6c48a","65K0Btu8BBKa488G4VTYhg@6c48a","78XW5GxOhAd6p2lnTVeP4d@6c48a","7dj5uJT9FMn6OrOOx83tfK@6c48a","8fzCJGh7xEKrfC7z4lTGoe@6c48a","edGoT/hLNPK7dChjeBJYcx@6c48a","322PyWMu1CPbla5d4dpwqk@36c77","bdlD1yPolAV6FO+5ND3N7x@6c48a","62BflQnDlPi4iyJvQocT+3@6c48a","dcCTiT2PVBO4UvIzXQfNk9@6c48a","deaoOX0RFK54zvVtz/nhBo@6c48a","8cLFThm8JK4aFUZOzrno2S@6c48a","65K0Btu8BBKa488G4VTYhg@f9941","deaoOX0RFK54zvVtz/nhBo@f9941","e71uS35VpPpbPKtBCx7x94@6c48a"],["node","_mesh","_parent","_particleSystem","_mainTexture","_spriteFrame","_effectAsset","mainTexture","_skeleton","target","_clip","_textureSource","_defaultClip","source","value","targetInfo","root","_cameraComponent","vision","fakeCat","Game","AudioManager","scene","clockSound","eatSound","loseSound","winSound","electric2Sound","electricSound","catAngrySound","bgSound","CTA_Download","HideMask","camera","title","text","icon","GameController","JoyStickComponent","asset","_normalSprite","_envmapHDR","_envmapLDR","data"],["cc.ImageAsset","cc.Texture2D",["cc.Node",["_name","_id","_active","_objFlags","__editorExtras__","_parent","_children","_lpos","_lrot","_euler","_components","_lscale","_prefab"],-2,1,2,5,5,5,2,5,4],["cc.Node",["_name","_layer","_active","_id","_components","_parent","_lpos","_lscale","_children","_lrot","_euler"],-1,9,1,5,5,2,5,5],"cc.SpriteFrame",["cc.CurveRange",["mode","constantMin","constantMax","constant","multiplier","spline"],-2,4],["cc.RealKeyframeValue",["interpolationMode","rightTangent","leftTangent","rightTangentWeight","leftTangentWeight","value","tangentWeightMode"],-4],["cc.RigidBody",["_group","_mass","_enabled","_type","node","_angularFactor","_linearFactor"],-1,1,5,5],["cc.MeshRenderer",["_shadowCastingMode","_name","node","_materials","lightmapSettings","_mesh"],1,1,3,4,6],["cc.Node",["_name","_children","_lpos","_lrot","_euler","_components","_lscale","_parent"],2,12,5,5,5,9,5,1],["cc.ParticleSystem",["duration","loop","playOnAwake","_simulationSpace","node","_materials","startColor","startSizeX","startSizeY","startSizeZ","startSpeed","startRotationX","startRotationY","startRotationZ","startDelay","startLifetime","gravityModifier","rateOverTime","rateOverDistance","bursts","_colorOverLifetimeModule","_shapeModule","_sizeOvertimeModule","_velocityOvertimeModule","_forceOvertimeModule","_limitVelocityOvertimeModule","_rotationOvertimeModule","_textureAnimationModule","_trailModule","renderer","__prefab"],-1,1,3,4,4,4,4,4,4,4,4,4,4,4,4,4,9,4,4,4,4,4,4,4,4,4,4,4],["cc.ColorKey",["time","color"],2,5],["cc.ShapeModule",["_shapeType","_enable","radius","emitFrom","radiusThickness","arcSpeed"],-2,4],["cc.TextureAnimationModule",["_numTilesX","_numTilesY","_enable","cycleCount","frameOverTime","startFrame"],-1,4,4],["cc.BoxCollider",["node","_center","_size"],3,1,5,5],["cc.Sprite",["_sizeMode","node","_spriteFrame","_color"],2,1,6,5],["cc.Material",["_states","_defines","_techIdx","_name","_props"],-1,12],["cc.GradientRange",["_mode","color","gradient"],2,5,4],["cc.ParticleSystemRenderer",["_renderMode","_velocityScale","_mainTexture"],1,6],["cc.UITransform",["node","_contentSize","_anchorPoint"],3,1,5,5],["cc.SkeletalAnimation",["playOnLoad","node","_clips","_sockets","_defaultClip"],2,1,3,9,6],["cc.ModelLightmapSettings",["_castShadow","_receiveShadow"],1],"cc.TextureCube",["cc.Node",["_name","_layer","_components","_lpos","_children","_lrot","_lscale","_euler","_parent"],1,12,5,2,5,5,5,1],["cc.Node",["_name","_parent","_children","_lpos","_lrot","_euler"],2,1,9,5,5,5],["cc.PrefabInfo",["fileId","root","asset","targetOverrides","nestedPrefabInstanceRoots"],2,1,1,9,2],["cc.Gradient",["colorKeys","alphaKeys"],3,9,9],["cc.SizeOvertimeModule",["_enable","size","x","y","z"],2,4,4,4,4],["cc.LimitVelocityOvertimeModule",["_enable","dampen","limitX","limitY","limitZ","limit"],1,4,4,4,4],["cc.AlphaKey",["alpha","time"],1],["cc.Animation",["playOnLoad","node","_clips","_defaultClip"],2,1,3,6],["cc.Camera",["_priority","_visibility","_name","_projection","_orthoHeight","_far","_clearFlags","node","_color"],-4,1,5],["cc.SkinnedMeshRenderer",["_shadowCastingMode","node","_materials","lightmapSettings","_skinningRoot","_mesh","_skeleton"],2,1,3,4,1,6,6],["cc.AudioSource",["_playOnAwake","_loop","node"],1,1],["RenderQueueDesc",["stages","isTransparent","sortMode"],0],["cc.AudioClip",["_name","_native","_duration"],0],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.Skeleton",["_name","_hash","_joints","_bindposes"],0,12],["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.Prefab",["_name"],2],["cc.PrefabInfo",["fileId","root","instance","asset"],2,1,4,6],["cc.CompPrefabInfo",["fileId"],2],["cc.Burst",["count"],3,4],["cc.ColorOvertimeModule",["_enable","color"],2,4],["cc.RealCurve",["_times","_values"],2,9],["cc.VelocityOvertimeModule",["x","y","z","speedModifier"],3,4,4,4,4],["cc.ForceOvertimeModule",["x","y","z"],3,4,4,4],["cc.RotationOvertimeModule",["x","y","z"],3,4,4,4],["cc.TrailModule",["lifeTime","widthRatio","colorOverTrail","colorOvertime","_particleSystem"],3,4,4,4,4,1],["cc.SceneAsset",["_name"],2],["cc.TargetInfo",["localID"],2],["cc.Canvas",["node","_cameraComponent"],3,1,1],["cc.Widget",["_alignFlags","_top","_bottom","node"],0,1],["cc.SkeletalAnimation.Socket",["path","target"],2,1],["d3eadinT6dHdY+UphBQAWhj",["node","AudioManager","Game","fakeCat","vision"],3,1,1,1,1,1],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides"],1,9],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,6],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,6],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,4],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.TargetOverrideInfo",["propertyPath","source","sourceInfo","target","targetInfo"],2,1,4,1,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog","octree"],3,4,4,4,4,4],["cc.AmbientInfo",["_skyIllumLDR","_skyColorHDR","_groundAlbedoHDR","_skyColorLDR","_groundAlbedoLDR"],2,5,5,5,5],["cc.ShadowsInfo",["_type","_enabled","_pcf","_bias","_normalBias","_near","_shadowDistance","_invisibleOcclusionRange","_orthoSize","_saturation","_shadowColor","_size"],-7,5,5],["cc.SkyboxInfo",["_enabled","_envmapHDR","_envmapLDR"],2,6,6],["cc.FogInfo",[],3],["cc.OctreeInfo",[],3],["d948b2gMqdAD6CRzTBJFAiN",["node"],3,1],["cc.UIOpacity",["_opacity","node"],2,1],["cc.Button",["_transition","_zoomScale","node","_normalSprite"],1,1,6],["ab7fdcqdMJBlbVEI/I8YoiE",["node","AudioManager","Cat","canvas2D","navigate","joyStick","CTA","CTA_tryBtn"],3,1,1,1,1,1,1,1,1],["cc.PlaneCollider",["node"],3,1],["c3658qOQadEYZt80EqPpq5n",["node","AudioManager","Game","controlCubeBox","stick","fakeBg"],3,1,1,1,1,1,1],["cc.DirectionalLight",["_illuminanceHDR","_illuminanceLDR","node","_staticSettings"],1,1,4],["cc.StaticLightSettings",[],3],["50226TeMLNKEqzuYMFQBSOm",["node","AudioManager","GamePlay","Door1","joyStick"],3,1,1,1,1,1],["cf8e1aetmhO9Ixn3ulRoUSJ",["AudioManager"],3,1],["a31f86fp3JJCbWTGM9ai5co",["node","AudioManager","CatController","wallLaser_1","wallLaser_2","Laser","LaserBtn_Red","LaserBtn_Blue","wallLaserBtn_Red","wallLaserBtn_Blue","Fx_Lightning"],3,1,1,1,1,1,1,1,1,1,1,2],["9d69fA7YXNFdJ3sO7cec90s",["node","Cubes"],3,1,2],["2fa136ZOf9Fl5lXghH8qCrM",["node","Gradient","Game"],3,1,1,1],["ForwardPipeline",["_flows"],3,9],["ShadowFlow",["_name","_stages"],2,9],["ShadowStage",["_name"],2],["ForwardFlow",["_name","_priority","_stages"],1,9],["ForwardStage",["_name","renderQueues"],2,9]],[[5,1],[21,1],[5,3,2],[8,0,2,3,4,5,2],[3,0,5,4,6,2],[14,0,2,1],[7,0,4,2],[2,0,5,6,7,8,9,2],[50,0,2],[17,1],[56,0,1,2,3],[36,0,1,2,3],[5,0,1,2,4],[11,0,1,2],[2,0,5,7,2],[5,0,5,2],[44,0,1,2],[61,0,1,2,3],[3,0,5,4,2],[24,0,1,2,3,4,5,2],[17,0,2,2],[42,0,1],[43,0,1,2],[45,0,1,2,3,1],[46,0,1,2,1],[47,0,1,2,1],[48,0,1,2,3,4,1],[14,0,1,2,1],[26,0,1],[27,1,2,3,4,1],[6,1,3,2,4,5],[6,5,1,3,2,4,6],[19,0,1,1],[7,0,3,4,3],[8,1,0,2,3,4,5,3],[3,0,1,5,4,6,7,3],[2,0,6,2],[28,2,3,4,5,1],[18,2,1],[11,1],[2,0,5,10,8,9,2],[3,0,5,4,6,9,7,10,2],[10,0,1,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3],[12,0,5,2],[13,2,0,1,3,4,5,5],[14,0,1],[64,0,1,2,3,4,2],[16,0,1,4,3],[2,0,5,10,2],[32,0,1,2,3,4,5,6,2],[2,0,5,6,7,8,11,9,2],[2,0,5,6,2],[7,0,1,4,6,5,3],[15,1,2,1],[2,0,5,2],[2,0,5,6,7,2],[3,0,4,6,2],[57,0,1,2,2],[21,0,2],[33,0,2,2],[11,1,1],[28,0,1,2,3,4,5,3],[2,0,5,7,8,9,2],[2,0,5,6,10,7,8,11,9,2],[2,0,5,6,7,11,2],[10,0,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3],[12,1,0,2,4,5,5],[13,0,1,3,4,5,4],[18,0,2,2],[5,0,2,3],[6,0,5,3],[15,1,3,2,1],[35,0,1,2,4],[37,0,1,2,3,4],[16,2,0,1,4,4],[3,0,5,4,6,9,10,2],[24,0,1,2,2],[59,0,1,2,2],[8,2,3,4,5,1],[15,0,1,3,2,2],[2,0,6,7,8,9,2],[3,0,5,4,6,7,2],[3,0,3,5,4,3],[53,0,1,2],[30,0,1,2,3,2],[58,0,1,2,2],[62,0,1,2,2],[8,1,2,3,4,5,2],[3,0,1,5,4,3],[19,0,1],[2,0,1,6,10,3],[3,0,1,5,8,4,3],[3,0,5,8,4,6,7,2],[3,0,2,5,4,3],[9,0,7,1,2,3,4,2],[9,0,1,2,3,4,2],[11,0,2],[29,0,1,3],[72,0,1,2],[33,1,0,2,3],[3,0,1,5,4,6,3],[3,0,1,5,4,6,9,7,10,3],[25,0,1,2,2],[41,0,2],[19,0,1,2,1],[30,1,2,3,1],[15,0,1,2,2],[38,0,1,2,4],[2,0,6,11,2],[2,3,4,12,3],[2,0,2,6,7,8,11,9,3],[2,0,2,5,6,7,8,11,9,3],[2,0,5,10,7,2],[2,0,1,5,10,3],[3,0,1,8,4,6,3],[3,0,5,8,4,6,9,7,10,2],[3,0,5,4,7,2],[3,0,1,5,4,7,3],[3,0,5,8,4,6,2],[9,0,1,5,2,3,6,4,2],[9,0,1,2],[23,0,4,2,3,5,6,7,2],[23,0,1,8,2,3,3],[25,0,3,4,2],[40,0,1,2,3,2],[10,0,1,2,4,30,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,4],[26,0,1,1],[12,3,5,2],[27,0,1,2,3,4,2],[6,0,1,2,4],[13,4,5,1],[29,0,2],[49,0,2],[51,0,1,1],[52,0,1,2,3,4],[20,0,1,2,3,4,2],[20,1,2,3,4,1],[20,1,1],[14,0,1,1],[7,1,4,5,2],[7,2,0,1,4,5,4],[54,0,1,2,3,4,1],[55,0,1,2,3],[60,0,1,2,2],[63,0,1,2,3,2],[65,0,1,2,3,4,1],[66,0,1,2,3,4,2],[67,0,1,2,3,4,5,6,7,8,9,10,11,11],[68,0,1,2,2],[69,1],[70,1],[71,0,1],[8,2,3,4,1],[21,1,2],[73,0,1,2,3,3],[74,0,1,2,3,4,5,6,7,1],[31,2,0,1,7,8,4],[31,3,0,4,5,6,1,7,8,7],[75,0,1],[32,1,2,3,4,5,6,1],[76,0,1,2,3,4,5,1],[77,0,1,2,3,3],[78,1],[79,0,1,2,3,4,1],[80,0,1],[81,0,1,2,3,4,5,6,7,8,9,10,1],[82,0,1,1],[83,0,1,2,1],[16,3,0,1,4,4],[39,0,2],[2,0,6,10,12,8,9,2],[2,0,5,10,12,2],[2,0,5,10,12,8,9,2],[3,0,2,1,5,8,4,6,7,4],[10,0,1,2,3,4,30,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,5],[17,1,1],[5,0,1,3],[5,0,1,2,4,5],[12,1,0,2,5,4],[6,0,6,1,3,2,4,7],[6,0,6,5,3,4,6],[13,2,0,1,4,5,4],[18,0,1,2,3],[84,0,1],[85,0,1,2],[86,0,2],[87,0,1,2,3],[88,0,1,2],[34,0,2],[34,1,2,0,4]],[[[[72,"clock",".mp3",6.347755],-1],0,0,[],[],[]],[[[11,".bin",2583196069,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":36960,"length":5040,"count":1260,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":36960,"count":770,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0018714733887463808,-2.382876118645072e-10,-0.0029920602682977915],"maxPosition",8,[1,0.001871500862762332,0.013806384056806564,0.0010497719049453735]]],-1],0,0,[],[],[]],[[[11,".bin",4186905938,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2016,"length":432,"count":108,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":2016,"count":42,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0009921710006892681,-0.005100779701024294,-0.018094662576913834],"maxPosition",8,[1,0.0009921706514433026,0.005100778304040432,0.018094660714268684]]],-1],0,0,[],[],[]],[[[11,".bin",2086787151,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":36960,"length":5040,"count":1260,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":36960,"count":770,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0018714733887463808,-2.382876118645072e-10,-0.0010497719049453735],"maxPosition",8,[1,0.001871500862762332,0.013806384056806564,0.0029920602682977915]]],-1],0,0,[],[],[]],[[[72,"bg",".mp3",16.039184],-1],0,0,[],[],[]],[[[11,".bin",3207112674,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":161208,"length":44880,"count":11220,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":161208,"count":2239,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,9]]},"minPosition",8,[1,-0.026734385639429092,0.013588538393378258,-0.007585999555885792],"maxPosition",8,[1,0.026734385639429092,0.04761594161391258,0.02982490323483944]]],-1],0,0,[],[],[]],[[[11,".bin",4066060713,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":9760,"length":2256,"count":564,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":9760,"count":122,"stride":80},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}],"jointMaps":[[0,3]]},"minPosition",8,[1,-0.0063070273026824,0.009103348478674889,0.0007674169610254467],"maxPosition",8,[1,0.00630607083439827,0.02008635550737381,0.014694511890411377]]],-1],0,0,[],[],[]],[[[73,"Skin-2",3437976317,["Root_M/Tail0_M/Tail1_M/Tail2_M","Root_M/Tail0_M/Tail1_M/Tail2_M/Tail3_M","Root_M/Tail0_M/Tail1_M/Tail2_M/Tail3_M/Tail4_M","Root_M/Tail0_M/Tail1_M/Tail2_M/Tail3_M/Tail4_M/Tail5_M","Root_M/Tail0_M/Tail1_M/Tail2_M/Tail3_M/Tail4_M/Tail5_M/Tail6_M"],[[[7,1.2148433370384737e-8,8.13854938996883e-9,-1,0,0.8024290204048157,-0.5967479944229126,4.891589355793258e-9,0,-0.5967479944229126,-0.8024290204048157,-1.378015479502892e-8,0,-0.023963989689946175,0.0021665298845618963,-1.0021385110636771e-10,1],[7,8.824710739929742e-9,1.1659502696659274e-8,-1,0,0.953311026096344,-0.30199098587036133,4.891627103376095e-9,0,-0.30199098587036133,-0.953311026096344,-1.3780109497929516e-8,0,-0.02638522908091545,-0.006823949981480837,-1.0413507556261692e-10,1],[7,7.242134003604406e-9,1.2703201157648891e-8,-1,0,0.9843689799308777,-0.17612099647521973,4.891627103376095e-9,0,-0.17612099647521973,-0.9843689799308777,-1.3780116603356873e-8,0,-0.028065010905265808,-0.010543400421738625,-1.1071417393981875e-10,1],[7,4.554238763887497e-9,1.3895300021715684e-8,-1,0,0.9997029900550842,0.024378500878810883,4.891630656089774e-9,0,0.024378500878810883,-0.9997029900550842,-1.3780142360531045e-8,0,-0.028023039922118187,-0.01648310013115406,-1.180176928405885e-10,1],[7,4.554238763887497e-9,1.3895300021715684e-8,-1,0,0.9997029900550842,0.024378500878810883,4.891630656089774e-9,0,0.024378500878810883,-0.9997029900550842,-1.3780142360531045e-8,0,-0.031048890203237534,-0.01648310013115406,-1.2770669244321908e-10,1]],8,8,8,8,8]]],0,0,[],[],[]],[[[73,"Skin-3",2069783319,["Root_M/Tail0_M/Tail1_M","Root_M/Tail0_M/Tail1_M/Tail2_M/Tail3_M","Root_M/Tail0_M/Tail1_M/Tail2_M/Tail3_M/Tail4_M","Root_M/Tail0_M/Tail1_M/Tail2_M/Tail3_M/Tail4_M/Tail5_M","Root_M/Tail0_M/Tail1_M/Tail2_M/Tail3_M/Tail4_M/Tail5_M/Tail6_M","Root_M/RootPart1_M/RootPart2_M","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Neck_M","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Neck_M/NeckPart1_M","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Neck_M/NeckPart1_M/Head_M","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Neck_M/NeckPart1_M/Head_M/HeadEnd_M","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Neck_M/NeckPart1_M/Head_M/Jaw_M","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Neck_M/NeckPart1_M/Head_M/Jaw_M/JawEnd_M","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Scapula_R","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Scapula_L"],[[[7,1.368354318742604e-8,5.1556670044305974e-9,-1,0,0.6453080177307129,-0.7639229893684387,4.891563598619086e-9,0,-0.7639229893684387,-0.6453080177307129,-1.378015657138576e-8,0,-0.019863199442625046,0.007571079768240452,-9.91303428232726e-11,1],[7,8.824710739929742e-9,1.1659502696659274e-8,-1,0,0.953311026096344,-0.30199098587036133,4.891627103376095e-9,0,-0.30199098587036133,-0.953311026096344,-1.3780109497929516e-8,0,-0.02638522908091545,-0.006823949981480837,-1.0413507556261692e-10,1],[7,7.242134003604406e-9,1.2703201157648891e-8,-1,0,0.9843689799308777,-0.17612099647521973,4.891627103376095e-9,0,-0.17612099647521973,-0.9843689799308777,-1.3780116603356873e-8,0,-0.028065010905265808,-0.010543400421738625,-1.1071417393981875e-10,1],[7,4.554238763887497e-9,1.3895300021715684e-8,-1,0,0.9997029900550842,0.024378500878810883,4.891630656089774e-9,0,0.024378500878810883,-0.9997029900550842,-1.3780142360531045e-8,0,-0.028023039922118187,-0.01648310013115406,-1.180176928405885e-10,1],[7,4.554238763887497e-9,1.3895300021715684e-8,-1,0,0.9997029900550842,0.024378500878810883,4.891630656089774e-9,0,0.024378500878810883,-0.9997029900550842,-1.3780142360531045e-8,0,-0.031048890203237534,-0.01648310013115406,-1.2770669244321908e-10,1],[7,-1.4622564492583479e-8,9.991857466201334e-14,1,0,-0.334526002407074,-0.9423869848251343,-4.891529403749928e-9,0,0.9423869848251343,-0.334526002407074,1.3780135255103687e-8,0,0.005665639881044626,0.012238300405442715,1.4324269548282587e-10,1],[7,-1.3905882667586411e-8,-4.521021779169132e-9,1,0,-0.02671949937939644,-0.9996430277824402,-4.890965854542628e-9,0,0.9996430277824402,-0.02671949937939644,1.3780117491535293e-8,0,-0.005804460030049086,0.012557229958474636,1.432356594444073e-10,1],[7,2.6738802283432506e-9,-1.4375999946025786e-8,1,0,0.987667977809906,-0.1565610021352768,-4.891629767911354e-9,0,0.1565610021352768,0.987667977809906,1.378009795161006e-8,0,-0.016659319400787354,-0.006594500038772821,1.432440138726676e-10,1],[7,2.6738802283432506e-9,-1.4375999946025786e-8,1,0,0.987667977809906,-0.1565610021352768,-4.891629767911354e-9,0,0.1565610021352768,0.987667977809906,1.378009795161006e-8,0,-0.02249862067401409,-0.006594500038772821,1.1426301571582087e-10,1],[7,4.3289900553133975e-9,-1.3967099476985823e-8,1,0,0.9991779923439026,-0.04053809866309166,-4.891631100178984e-9,0,0.04053809866309166,0.9991779923439026,1.378012903785475e-8,0,-0.027377750724554062,-0.009848039597272873,4.0910809462335607e-11,1],[7,4.3289900553133975e-9,-1.3967099476985823e-8,1,0,0.9991779923439026,-0.04053809866309166,-4.891631100178984e-9,0,0.04053809866309166,0.9991779923439026,1.378012903785475e-8,0,-0.042473018169403076,-0.009848039597272873,4.0910805992888655e-11,1],[7,-1.4613597443258186e-8,-5.118049317687223e-10,1,0,-0.30133599042892456,-0.9535179734230042,-4.891618665681108e-9,0,0.9535179734230042,-0.30133599042892456,1.3780104168858998e-8,0,-0.005687799770385027,0.022578949108719826,4.0910826809570366e-11,1],[7,-1.4613597443258186e-8,-5.118049317687223e-10,1,0,-0.30133599042892456,-0.9535179734230042,-4.891618665681108e-9,0,0.9535179734230042,-0.30133599042892456,1.3780104168858998e-8,0,-0.01713244989514351,0.022578949108719826,4.0910823340123414e-11,1],[7,-0.5131128430366516,-3.031340156667284e-8,-0.8583210110664368,0,-0.8443281054496765,0.17983601987361908,0.5047469735145569,0,0.15435706079006195,0.9836969971656799,-0.09227608889341354,0,0.00894182175397873,-0.009505600668489933,-0.009528659284114838,1],[7,-0.5131128430366516,-1.3161886691648306e-8,-0.8583210110664368,0,0.8443281054496765,-0.17983601987361908,-0.5047469735145569,0,-0.15435707569122314,-0.9836969971656799,0.09227607399225235,0,-0.00894182175397873,0.009505600668489933,0.009528658352792263,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[11,".bin",3452774048,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":7200,"length":1560,"count":390,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":7200,"count":100,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,4]]},"minPosition",8,[1,-0.0033853717613965273,0.028086872771382332,-0.017067698761820793],"maxPosition",8,[1,0.004926302004605532,0.035957127809524536,-0.01209910400211811]]],-1],0,0,[],[],[]],[[[73,"Skin-1",3830142098,["Root_M/RootPart1_M/RootPart2_M","Root_M/RootPart1_M/RootPart2_M/Spine2_M","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Neck_M","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Neck_M/NeckPart1_M","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Neck_M/NeckPart1_M/Head_M","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Neck_M/NeckPart1_M/Head_M/Jaw_M","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Scapula_R","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Scapula_R/Shoulder_R","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Scapula_L","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Scapula_L/Shoulder_L"],[[[7,-1.4622564492583479e-8,9.991857466201334e-14,1,0,-0.334526002407074,-0.9423869848251343,-4.891529403749928e-9,0,0.9423869848251343,-0.334526002407074,1.3780135255103687e-8,0,0.005665639881044626,0.012238300405442715,1.4324269548282587e-10,1],[7,-1.4058525898974494e-8,-4.020859645237351e-9,1,0,-0.06241219863295555,-0.9980499744415283,-4.890447158345523e-9,0,0.9980499744415283,-0.06241219863295555,1.3780174334954154e-8,0,0.00009530929673928767,0.012756559997797012,1.432288870839571e-10,1],[7,-1.3905882667586411e-8,-4.521021779169132e-9,1,0,-0.02671949937939644,-0.9996430277824402,-4.890965854542628e-9,0,0.9996430277824402,-0.02671949937939644,1.3780117491535293e-8,0,-0.005804460030049086,0.012557229958474636,1.432356594444073e-10,1],[7,2.6738802283432506e-9,-1.4375999946025786e-8,1,0,0.987667977809906,-0.1565610021352768,-4.891629767911354e-9,0,0.1565610021352768,0.987667977809906,1.378009795161006e-8,0,-0.016659319400787354,-0.006594500038772821,1.432440138726676e-10,1],[7,2.6738802283432506e-9,-1.4375999946025786e-8,1,0,0.987667977809906,-0.1565610021352768,-4.891629767911354e-9,0,0.1565610021352768,0.987667977809906,1.378009795161006e-8,0,-0.02249862067401409,-0.006594500038772821,1.1426301571582087e-10,1],[7,4.3289900553133975e-9,-1.3967099476985823e-8,1,0,0.9991779923439026,-0.04053809866309166,-4.891631100178984e-9,0,0.04053809866309166,0.9991779923439026,1.378012903785475e-8,0,-0.027377750724554062,-0.009848039597272873,4.0910809462335607e-11,1],[7,-1.4613597443258186e-8,-5.118049317687223e-10,1,0,-0.30133599042892456,-0.9535179734230042,-4.891618665681108e-9,0,0.9535179734230042,-0.30133599042892456,1.3780104168858998e-8,0,-0.005687799770385027,0.022578949108719826,4.0910826809570366e-11,1],[7,-0.5131128430366516,-3.031340156667284e-8,-0.8583210110664368,0,-0.8443281054496765,0.17983601987361908,0.5047469735145569,0,0.15435706079006195,0.9836969971656799,-0.09227608889341354,0,0.00894182175397873,-0.009505600668489933,-0.009528659284114838,1],[7,7.749635599907378e-9,-1.1038293834531032e-8,-1,0,-0.929023027420044,-0.3700230121612549,-3.11516501483311e-9,0,-0.3700230121612549,0.929023027420044,-1.312236275197165e-8,0,0.013529599644243717,-0.002738649956882,-0.005117619875818491,1],[7,-0.5131128430366516,-1.3161886691648306e-8,-0.8583210110664368,0,0.8443281054496765,-0.17983601987361908,-0.5047469735145569,0,-0.15435707569122314,-0.9836969971656799,0.09227607399225235,0,-0.00894182175397873,0.009505600668489933,0.009528658352792263,1],[7,5.493474564133294e-9,4.893671601280403e-8,-1,0,0.9061650037765503,0.4229229986667633,2.567448653678639e-8,0,0.4229229986667633,-0.9061650037765503,-4.2021468971142895e-8,0,-0.013664890080690384,0.0019547499250620604,0.005117619875818491,1]],8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[72,"eating_sfx",".mp3",1.469333],-1],0,0,[],[],[]],[[[11,".bin",3219909449,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6776,"length":2400,"count":600,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":6776,"count":121,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-5,0,-5],"maxPosition",8,[1,5,0,5]]],-1],0,0,[],[],[]],[[[11,".bin",3434579268,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1344,"length":144,"count":36,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":1344,"count":24,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-0.5,-0.5],"maxPosition",8,[1,0.5,0.5,0.5]]],-1],0,0,[],[],[]],[[[11,".bin",3383603168,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":224,"length":24,"count":6,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":224,"count":4,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.5,-0.5,0],"maxPosition",8,[1,0.5,0.5,0]]],-1],0,0,[],[],[]],[[[73,"Skin-0",1221932206,["Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Scapula_R/Shoulder_R","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R/Fingers1_R","Root_M/Tail0_M/Tail1_M/Tail2_M/Tail3_M/Tail4_M/Tail5_M","Root_M/Tail0_M/Tail1_M/Tail2_M/Tail3_M/Tail4_M","Root_M/Tail0_M/Tail1_M/Tail2_M/Tail3_M","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Neck_M/NeckPart1_M/Head_M","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Neck_M/NeckPart1_M","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Neck_M","Root_M/Tail0_M/Tail1_M","Root_M/Tail0_M/Tail1_M/Tail2_M","Root_M/Tail0_M","Root_M/Hip_R/Knee_R/Ankle_R/Toes1_R","Root_M/Hip_R","Root_M/Hip_R/Knee_R/Ankle_R","Root_M/Hip_R/Knee_R","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Scapula_L/Shoulder_L","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L/Fingers1_L","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Scapula_L","Root_M/RootPart1_M","Root_M","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Scapula_R","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M","Root_M/RootPart1_M/RootPart2_M/Spine2_M","Root_M/RootPart1_M/RootPart2_M","Root_M/Hip_L/Knee_L","Root_M/Hip_L/Knee_L/Ankle_L/Toes1_L","Root_M/Hip_L/Knee_L/Ankle_L","Root_M/Hip_L","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R","Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R"],[[[7,7.74850406060068e-9,-1.1039094971465602e-8,-1,0,-0.9290609955787659,-0.36992698907852173,-3.1151723423050726e-9,0,-0.36992698907852173,0.9290609955787659,-1.3122368969220588e-8,0,0.013529320247471333,-0.0027400499675422907,-0.005117619875818491,1],[7,5.830429827824446e-8,4.102600037469983e-9,-1,0,-9.860761315262648e-32,1,4.102600037469983e-9,0,1,-2.3919921909863783e-16,5.830429827824446e-8,0,-0.007224829867482185,-0.001113350037485361,-0.005117619875818491,1],[7,5.260566737774752e-8,8.692819619682268e-8,-1,0,0.9997029900550842,0.024378500878810883,5.470920072525587e-8,0,0.024378500878810883,-0.9997029900550842,-8.561990227917704e-8,0,-0.028023039922118187,-0.01648310013115406,-2.668369969427431e-9,1],[7,6.893350246173213e-8,7.464610263241411e-8,-1,0,0.9843689799308777,-0.17612099647521973,5.4709207830683226e-8,0,-0.17612099647521973,-0.9843689799308777,-8.561986675204025e-8,0,-0.028065010905265808,-0.010543400421738625,-2.4951696264707834e-9,1],[7,7.801131829410224e-8,6.5100692836495e-8,-1,0,0.953311026096344,-0.30199098587036133,5.470920427796955e-8,0,-0.30199098587036133,-0.953311026096344,-8.561988806832233e-8,0,-0.02638522908091545,-0.006823949981480837,-2.294319845219661e-9,1],[7,4.3289900553133975e-9,-1.3967099476985823e-8,1,0,0.9991779923439026,-0.04053809866309166,-4.891631100178984e-9,0,0.04053809866309166,0.9991779923439026,1.378012903785475e-8,0,-0.027377750724554062,-0.009848039597272873,4.0910708848374e-11,1],[7,2.6738802283432506e-9,-1.4375999946025786e-8,1,0,0.987667977809906,-0.1565610021352768,-4.891629767911354e-9,0,0.1565610021352768,0.987667977809906,1.378009795161006e-8,0,-0.02249862067401409,-0.006594500038772821,1.1426301571582087e-10,1],[7,2.6738802283432506e-9,-1.4375999946025786e-8,1,0,0.987667977809906,-0.1565610021352768,-4.891629767911354e-9,0,0.1565610021352768,0.987667977809906,1.378009795161006e-8,0,-0.016659319400787354,-0.006594500038772821,1.432440138726676e-10,1],[7,1.0071133260680654e-7,1.345690225917906e-8,-1,0,0.6453080177307129,-0.7639229893684387,5.470975139587608e-8,0,-0.7639229893684387,-0.6453080177307129,-8.56194901643903e-8,0,-0.019863199442625046,0.007571079768240452,-1.7649225414473335e-9,1],[7,9.499377284782895e-8,3.6056221119906695e-8,-1,0,0.8024290204048157,-0.5967479944229126,5.470925401596105e-8,0,-0.5967479944229126,-0.8024290204048157,-8.56198596466129e-8,0,-0.023963989689946175,0.0021665298845618963,-2.0250299215263112e-9,1],[7,1.0153414109481673e-7,3.832492989630509e-9,-1,0,0.5698469877243042,-0.8217509984970093,5.470955599662375e-8,0,-0.8217509984970093,-0.5698469877243042,-8.561968911635631e-8,0,-0.015836570411920547,0.009423140436410904,-1.4836117889771572e-9,1],[7,2.1572599706587425e-8,2.2469599514352012e-8,-1,0,1.9721522630525295e-31,1,2.2469599514352012e-8,0,1,-4.847276801373966e-16,2.1572599706587425e-8,0,0.006784679833799601,-0.0018823499558493495,-0.005224830005317926,1],[7,-0.2315392792224884,-0.021494265645742416,-0.9725880026817322,0,-0.8208611607551575,0.5408589839935303,0.1834651529788971,0,0.5220896601676941,0.8408390283584595,-0.14287376403808594,0,0.013664758764207363,-0.003299108939245343,-0.007227241061627865,1],[7,-5.533141056446311e-9,-2.040660262991878e-8,-1,0,-0.9556249976158142,0.29458698630332947,-7.239116528445777e-10,0,0.29458698630332947,0.9556249976158142,-2.113103825251983e-8,0,0.00761938001960516,0.005929090082645416,-0.005224830005317926,1],[7,0.03108430653810501,-0.23044800758361816,-0.9725879430770874,0,-0.5063292980194092,-0.842598021030426,0.18346519768238068,0,-0.8617798089981079,0.48674699664115906,-0.1428741067647934,0,0.0029983532149344683,0.007309860084205866,-0.007227241527289152,1],[7,8.308242982479896e-9,4.764870098483698e-8,-1,0,0.9290609955787659,0.36992698907852173,2.534539689236226e-8,0,0.36992698907852173,-0.9290609955787659,-4.119509355859918e-8,0,-0.013529320247471333,0.0027400499675422907,0.005117619875818491,1],[7,4.716016377415144e-8,6.104523464500744e-8,-1,0,0.7000529766082764,-0.7140910029411316,-1.0577238640507858e-8,0,-0.7140910029411316,-0.7000529766082764,-7.641153842996573e-8,0,0.003039909992367029,0.005852799862623215,0.005117619875818491,1],[7,3.492889533163179e-8,3.345740040572309e-8,-1,0,0.9675740003585815,-0.2525869905948639,2.534539689236226e-8,0,-0.2525869905948639,-0.9675740003585815,-4.119511132216758e-8,0,-0.004324129782617092,0.006582930218428373,0.005117619875818491,1],[7,8.368900239474897e-8,-2.883679961485086e-8,-1,0,7.888609052210118e-31,-1,2.883679961485086e-8,0,-1,-2.4133228628784057e-15,-8.368900239474897e-8,0,0.007224829867482185,0.001113350037485361,0.005117619875818491,1],[7,-0.5131128430366516,-3.635094003584527e-8,-0.8583210110664368,0,0.8443281054496765,-0.17983601987361908,-0.5047469735145569,0,-0.15435706079006195,-0.9836969971656799,0.09227609634399414,0,-0.008941820822656155,0.009505600668489933,0.009528660215437412,1],[7,-1.462253162998195e-8,1.9366344465587826e-13,1,0,-0.334526002407074,-0.9423869848251343,-4.8914299277669215e-9,0,0.9423869848251343,-0.334526002407074,1.3780135255103687e-8,0,0.007730870041996241,0.012238300405442715,1.432416962821037e-10,1],[7,-1.462253162998195e-8,1.9366344465587826e-13,1,0,-0.334526002407074,-0.9423869848251343,-4.8914299277669215e-9,0,0.9423869848251343,-0.334526002407074,1.3780135255103687e-8,0,0.009796090424060822,0.012238300405442715,1.432416962821037e-10,1],[7,-0.5131128430366516,-5.3502439811836666e-8,-0.8583210110664368,0,-0.8443281054496765,0.17983601987361908,0.5047469735145569,0,0.15435704588890076,0.9836969971656799,-0.09227611124515533,0,0.00894182175397873,-0.009505600668489933,-0.009528660215437412,1],[7,-1.3905864904018017e-8,-4.5197023901266675e-9,1,0,-0.02671949937939644,-0.9996430277824402,-4.889646021410954e-9,0,0.9996430277824402,-0.02671949937939644,1.3780135255103687e-8,0,-0.005804460030049086,0.012557229958474636,1.4321936692152093e-10,1],[7,-1.4058552544327085e-8,-4.0216971974871285e-9,1,0,-0.06241219863295555,-0.9980499744415283,-4.8912847105953006e-9,0,0.9980499744415283,-0.06241219863295555,1.3780147689601563e-8,0,0.00009530899842502549,0.012756559997797012,1.4323967012508376e-10,1],[7,-1.462253162998195e-8,1.9366344465587826e-13,1,0,-0.334526002407074,-0.9423869848251343,-4.8914299277669215e-9,0,0.9423869848251343,-0.334526002407074,1.3780135255103687e-8,0,0.005665639881044626,0.012238300405442715,1.432416962821037e-10,1],[7,0.03108430653810501,-0.23044800758361816,-0.9725879430770874,0,0.5063292980194092,0.842598021030426,-0.18346519768238068,0,0.8617798089981079,-0.48674699664115906,0.1428741067647934,0,-0.0029983532149344683,-0.007309860084205866,0.007227241527289152,1],[7,1.860029996691992e-8,-6.453130030337206e-9,-1,0,9.266095767849739e-33,-1,6.453130030337206e-9,0,-1,-1.2003015374943032e-16,-1.860029996691992e-8,0,-0.006784679833799601,0.0018823499558493495,0.005224830005317926,1],[7,1.132568794304234e-8,1.483430356330473e-8,-1,0,0.9556249976158142,-0.29458698630332947,6.453113599036442e-9,0,-0.29458698630332947,-0.9556249976158142,-1.751241995862074e-8,0,-0.00761938001960516,-0.005929090082645416,0.005224830005317926,1],[7,-0.2315392792224884,-0.021494265645742416,-0.9725880026817322,0,0.8208611607551575,-0.5408589839935303,-0.1834651529788971,0,-0.5220896601676941,-0.8408390283584595,0.14287376403808594,0,-0.013664758764207363,0.003299108939245343,0.007227241061627865,1],[7,-7.189803419294094e-9,-3.759199529440593e-8,-1,0,-0.7000529766082764,0.7140910029411316,-2.1810858896742502e-8,0,0.7140910029411316,0.7000529766082764,-3.145055771369698e-8,0,-0.003039909992367029,-0.005852799862623215,-0.005117619875818491,1],[7,-3.004192727917854e-10,-1.3483697713922993e-8,-1,0,-0.9675740003585815,0.2525869905948639,-3.115129931785532e-9,0,0.2525869905948639,0.9675740003585815,-1.312236186379323e-8,0,0.004324129782617092,-0.006582930218428373,-0.005117619875818491,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[11,".bin",105658638,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":86040,"length":10176,"count":5088,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[1],"indexView":{"offset":143376,"length":3936,"count":1968,"stride":2}},{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[2],"indexView":{"offset":162000,"length":1032,"count":516,"stride":2}},{"primitiveMode":7,"jointMapIndex":1,"vertexBundelIndices":[3],"indexView":{"offset":199824,"length":2532,"count":1266,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":86040,"count":1195,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":96216,"length":47160,"count":655,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":147312,"length":14688,"count":204,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]},{"view":{"offset":163032,"length":36792,"count":511,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,2,3,4,5,7,8,9,10,12,13,14,15,19,20,21,22,23,24,25,26,27,28,29],[0,1,5,7,8,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]]},"minPosition",8,[1,-0.01575685665011406,-0.00002662196675373707,-0.017050670459866524],"maxPosition",8,[1,0.015756862238049507,0.04117150232195854,0.024970829486846924]]],-1],0,0,[],[],[]],[[[47,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[7,6],[2,14]],[[[107,"builtin-standard",[{"hash":4038009253,"name":"builtin-standard|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"metallicRoughnessMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":7,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":8,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":9,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_vertexId","format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_color","format":44,"location":13,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":14,"defines":[]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":17,"location":0,"defines":["!CC_USE_ACCURATE_FOG"]},{"name":"v_shadowPos","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":17,"location":2,"defines":["USE_VERTEX_COLOR"]},{"name":"v_position","type":15,"count":1,"stageFlags":17,"location":3,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":17,"location":4,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":5,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":6,"defines":[]},{"name":"v_tangent","type":15,"count":1,"stageFlags":17,"location":7,"defines":["USE_NORMAL_MAP"]},{"name":"v_bitangent","type":15,"count":1,"stageFlags":17,"location":8,"defines":["USE_NORMAL_MAP"]},{"name":"v_luv","type":15,"count":1,"stageFlags":17,"location":9,"defines":["USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":["CC_FORWARD_ADD"]},{"name":"fragColor0","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor1","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"fragColor2","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["!CC_FORWARD_ADD","CC_PIPELINE_TYPE"]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) out float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  layout(location = 13) in vec4 a_color;\n  layout(location = 2) out vec4 v_color;\n#endif\nlayout(location = 3) out vec3 v_position;\nlayout(location = 4) out vec3 v_normal;\nlayout(location = 5) out vec2 v_uv;\nlayout(location = 6) out vec2 v_uv1;\n#if USE_NORMAL_MAP\n  layout(location = 7) out vec3 v_tangent;\n  layout(location = 8) out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 14) in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nlayout(location = 0) in float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(cc_shadowLPNNInfo.z > 0.0001)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n#endif\n#if CC_USE_IBL\n  layout(set = 0, binding = 4) uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    layout(set = 0, binding = 6) uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      {\n        vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\n        float pcf = cc_shadowWHPBInfo.z;\n        if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n        else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n        else shadow = CCGetShadowFactorHard(pos);\n        shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n      }\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nlayout(location = 1) in highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) in vec3 v_luv;\n  layout(set = 2, binding = 10) uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nlayout(location = 3) in vec3 v_position;\nlayout(location = 5) in vec2 v_uv;\nlayout(location = 6) in vec2 v_uv1;\nlayout(location = 4) in vec3 v_normal;\n#if USE_VERTEX_COLOR\n  layout(location = 2) in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 7) in vec3 v_tangent;\n  layout(location = 8) in vec3 v_bitangent;\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  layout(set = 1, binding = 3) uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  layout(set = 1, binding = 4) uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  layout(set = 1, binding = 5) uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(set = 2, binding = 1) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(set = 1, binding = 7) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(set = 1, binding = 8) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(set = 1, binding = 9) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nout float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(cc_shadowLPNNInfo.z > 0.0001)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      {\n        vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\n        float pcf = cc_shadowWHPBInfo.z;\n        if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n        else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n        else shadow = CCGetShadowFactorHard(pos);\n        shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n      }\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = texture(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if USE_VERTEX_COLOR\n  in vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(std430, binding = 4) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 5) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 6) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 fragColor0;\n  layout(location = 1) out vec4 fragColor1;\n  layout(location = 2) out vec4 fragColor2;\n  void main () {\n    StandardSurface s; surf(s);\n    fragColor0 = s.albedo;\n    fragColor1 = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    fragColor2 = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n#endif\n      uniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n    v_luv.z = cc_lightingMapUVParam.z;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n    v_luv.z = a_lightingMapUVParam.z;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n  uniform mediump vec4 cc_viewPort;\n     uniform vec4 albedo;\n     uniform vec4 albedoScaleAndCutoff;\n     uniform vec4 pbrParams;\n     uniform vec4 emissive;\n     uniform vec4 emissiveScaleParam;\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogStart = cc_fogBase.x;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = max(distance(cc_cameraPos, wPos) - fogStart, 0.0) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n  #if CC_USE_FOG == 0\n\tfactor = LinearFog(pos);\n  #elif CC_USE_FOG == 1\n    factor = ExpFog(pos);\n  #elif CC_USE_FOG == 2\n    factor = ExpSquaredFog(pos);\n  #elif CC_USE_FOG == 3\n    factor = LayeredFog(pos);\n  #else\n    factor = 1.0;\n  #endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n  color = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal)\n  {\n    vec4 newShadowPos = shadowPos;\n    if(cc_shadowLPNNInfo.z > 0.0001)\n    {\n      vec4 viewNormal = cc_matLightView * vec4(worldNormal, 0.0);\n      if(viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * cc_shadowProjInfo.xy * cc_shadowLPNNInfo.z * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    vec3 viewSpacePos;\n    viewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n    viewSpacePos.z = shadowPos.z * cc_shadowInvProjDepthInfo.x + shadowPos.w * cc_shadowInvProjDepthInfo.y;\n    viewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n    vec4 clipSpacePos;\n    clipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n    clipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      clipSpacePos.z = CCGetLinearDepthFromViewSpace(viewSpacePos.xyz);\n      clipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n    }\n    return clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias)\n  {\n    float coeffA = cc_shadowProjDepthInfo.x;\n    float coeffB = cc_shadowProjDepthInfo.y;\n    float viewSpacePos_z = (shadowPos.z - coeffB) / coeffA;\n    viewSpacePos_z += viewspaceDepthBias;\n    vec4 result = shadowPos;\n    result.z = viewSpacePos_z * coeffA + coeffB;\n    return result;\n  }\n  float CCGetShadowFactorHard (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n    }\n    shadow = step(clipPos.z, closestDepth);\n    return shadow;\n  }\n  float CCGetShadowFactorSoft (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * mapSize.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Orthographic(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float offsetDepth = clipPos.z;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(offsetDepth, dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(offsetDepth, texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float shadow = 0.0;\n    float closestDepth = 0.0;\n    float depth = clipPos.z;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    } else {\n      closestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n    }\n    shadow = step(depth, closestDepth);\n    return shadow;\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n    vec2 clipPos_offset = clipPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos.y)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset.y)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset.x, clipPos_offset.y)).x);\n    }\n    float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float CCGetSpotLightShadowFactorSoft2X (vec4 shadowPos, vec3 worldPos) {\n    vec4 clipPosNew = ApplyShadowDepthBias_Perspective(shadowPos, cc_shadowWHPBInfo.w);\n    vec3 clipPos = clipPosNew.xyz / clipPosNew.w * 0.5 + 0.5;\n    if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n        clipPos.y < 0.0 || clipPos.y > 1.0 ||\n        clipPos.z < 0.0 || clipPos.z > 1.0) { return 1.0; }\n    clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n    float depth = 0.0;\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      depth = CCGetLinearDepth(worldPos);\n    } else {\n      depth = clipPos.z;\n    }\n    float bias = cc_shadowWHPBInfo.w;\n    vec2 mapSize = cc_shadowWHPBInfo.xy;\n    vec2 oneTap = 1.0 / mapSize;\n    float clipPos_offset_L = clipPos.x - oneTap.x;\n    float clipPos_offset_R = clipPos.x + oneTap.x;\n    float clipPos_offset_U = clipPos.y - oneTap.y;\n    float clipPos_offset_D = clipPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    if (cc_shadowLPNNInfo.y > 0.000001) {\n      block0 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(depth, dot(texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    } else {\n      block0 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_U)).x);\n      block1 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_U)).x);\n      block2 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_U)).x);\n      block3 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos.y)).x);\n      block4 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x);\n      block5 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos.y)).x);\n      block6 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_L, clipPos_offset_D)).x);\n      block7 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos_offset_D)).x);\n      block8 = step(depth, texture2D(cc_spotLightingMap, vec2(clipPos_offset_R, clipPos_offset_D)).x);\n    }\n    float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n    float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n#endif\n#if CC_USE_IBL\n  uniform samplerCube cc_environment;\n  vec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return texture2DLodEXT(tex, coord, lod);\n      #else\n        return texture2D(tex, coord, lod);\n      #endif\n  }\n  vec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      #ifdef GL_EXT_shader_texture_lod\n        return textureCubeLodEXT(tex, coord, lod);\n      #else\n        return textureCube(tex, coord, lod);\n      #endif\n  }\n  vec3 unpackRGBE (vec4 rgbe) {\n    return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n  }\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * mipCount;\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n    \tvec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, R);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 emissive;\n  vec3 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 position;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  position = unpackHighpData(s.position, s.position_fract_part);\n  #else\n  position = s.position;\n  #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  float NV = max(abs(dot(N, V)), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L + V);\n  float NH = max(dot(N, H), 0.0);\n  float NL = max(dot(N, L), 0.0);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n  vec3 diffuseContrib = diffuse;\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    if (s.lightmap_test > 0.0001) {\n      finalColor = s.lightmap.rgb;\n    }\n  #else\n    diffuseContrib /= 3.14159265359;\n  #endif\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 dirlightContrib = (diffuseContrib + specularContrib);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      {\n        vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N);\n        float pcf = cc_shadowWHPBInfo.z;\n        if (pcf > 1.9) shadow = CCGetShadowFactorSoft2X(pos);\n        else if (pcf > 0.9) shadow = CCGetShadowFactorSoft(pos);\n        else shadow = CCGetShadowFactorHard(pos);\n        shadow = mix(shadow, 1.0, cc_shadowNFLSInfo.w);\n      }\n    }\n  #endif\n  dirlightContrib *= shadow;\n  finalColor *= dirlightContrib;\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP\n      vec4 diffuseMap = textureCube(cc_diffuseMap, N);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    vec3 R = normalize(reflect(-V, N));\n    #if USE_REFLECTION_DENOISE\n      vec3 env = GetEnvReflectionWithMipFiltering(R, s.roughness, cc_ambientGround.w, 0.6);\n    #else\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n    #endif\n    finalColor += env * cc_ambientSky.w * specular * s.occlusion;\n  #endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n  vec3 UnpackLightingmap(vec4 color) {\n    vec3 c;\n    float e = 1.0 + color.a * (8.0 - 1.0);\n    c.r = color.r * e;\n    c.g = color.g * e;\n    c.b = color.b * e;\n    return c;\n  }\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if USE_VERTEX_COLOR\n  varying vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    vec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\n    s.lightmap = UnpackLightingmap(lightColor);\n    s.lightmap_test = v_luv.z;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = cc_lightColor[i].rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[4u * i + 0u];\n    light.cc_lightColor = b_ccLights[4u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[4u * i + 2u];\n    light.cc_lightDir = b_ccLights[4u * i + 3u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 100u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (light.cc_lightPos.w > 0.0) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW\n        if (light.cc_lightPos.w > 0.0) {\n          {\n            float pcf = cc_shadowWHPBInfo.z;\n            if (pcf > 1.9) shadow = CCGetSpotLightShadowFactorSoft2X(shadowPos, position);\n            else if (pcf > 0.9) shadow = CCGetSpotLightShadowFactorSoft(shadowPos, position);\n            else shadow = CCGetSpotLightShadowFactorHard(shadowPos, position);\n          }\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    CC_APPLY_FOG(color, s.position.xyz);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    CC_APPLY_FOG(color, s.position.xyz);\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[1] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    gl_FragData[2] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":["CC_USE_IBL"]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_lightingMap","defines":["USE_LIGHTMAP","!USE_BATCHING","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":222,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":65}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":[]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"USE_VERTEX_COLOR","type":"boolean","defines":[]},{"name":"USE_NORMAL_MAP","type":"boolean","defines":[]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"USE_TWOSIDE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":[]},{"name":"CC_USE_IBL","type":"number","defines":[],"range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","defines":["CC_USE_IBL"],"range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean","defines":[]},{"name":"CC_USE_HDR","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","defines":["USE_NORMAL_MAP"],"options":["v_uv","v_uv1"]},{"name":"PBR_UV","type":"string","defines":[],"options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean","defines":[]},{"name":"USE_METALLIC_ROUGHNESS_MAP","type":"boolean","defines":[]},{"name":"USE_OCCLUSION_MAP","type":"boolean","defines":[]},{"name":"USE_EMISSIVE_MAP","type":"boolean","defines":[]},{"name":"EMISSIVE_UV","type":"string","defines":["USE_EMISSIVE_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean","defines":["CC_FORWARD_ADD"]}]},{"hash":210600745,"name":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_vertexId","format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_texCoord1","format":21,"location":13,"defines":[]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":17,"location":1,"defines":[]},{"name":"v_worldPos","type":16,"count":1,"stageFlags":17,"location":2,"defines":[]},{"name":"v_clip_depth","type":13,"count":1,"stageFlags":17,"location":3,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 13) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out vec2 v_uv1;\nlayout(location = 2) out vec4 v_worldPos;\nlayout(location = 3) out float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform highp sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform highp sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in vec2 v_uv1;\nlayout(location = 2) in vec4 v_worldPos;\nlayout(location = 3) in float v_clip_depth;\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\n      uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n   uniform vec4 albedo;\n   uniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nfloat CCGetLinearDepthFromViewSpace(vec3 viewPos) {\n  float dist = length(viewPos);\n  return (dist - cc_shadowNFLSInfo.x) / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n  vec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  return CCGetLinearDepthFromViewSpace(viewStartPos.xyz);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotLightingMap;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture2D(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  if(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\n    if (cc_shadowNFLSInfo.z > 0.000001) {\n      return vec4(CCGetLinearDepth(v_worldPos.xyz), 1.0, 1.0, 1.0);\n    }\n  }\n  if (cc_shadowLPNNInfo.y > 0.000001) {\n    return packDepthToRGBA(v_clip_depth);\n  }\n  return vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":183,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":65}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"HAS_SECOND_UV","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"USE_ALBEDO_MAP","type":"boolean","defines":[]},{"name":"ALBEDO_UV","type":"string","defines":["USE_ALBEDO_MAP"],"options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ALPHA_TEST_CHANNEL","type":"string","defines":["USE_ALPHA_TEST"],"options":["a","r"]}]}],[{"name":"opaque","passes":[{"program":"builtin-standard|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"SpecularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]},{"name":"transparent","passes":[{"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",2,13]},"SpecularIntensity":{"type":13,"value":[0.5],"editor":{"slide":true,"step":0.001,"range":[0,1]},"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP","slide":true,"step":0.001,"range":[0,1]},"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"pbrParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"editor":{"displayName":"Albedo","type":"color"},"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"editor":{"parent":"USE_ALPHA_TEST"},"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"editor":{"displayName":"AlbedoMap"},"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey","editor":{"visible":false,"deprecated":true}}}}]}]]],0,0,[],[],[]],[[[72,"electric_sfx",".mp3",4.157333],-1],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["214ncfEupO/ZqevD3MdL4v"]}],[1],0,[],[],[]],[[[47,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true},{},{}],[[[{},"mainColor",8,[4,4294957690]],{},{}],11,0,0]]],0,0,[0],[6],[6]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["2aXH9TKYJA2rjYSsF90buD"]}],[1],0,[],[],[]],[[{"name":"joy","rect":{"x":0,"y":0,"width":143,"height":143},"offset":{"x":0,"y":0},"originalSize":{"width":143,"height":143},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[4],0,[0],[11],[124]],[[[11,".bin",1765631370,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":12480,"length":1920,"count":480,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":12480,"count":260,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0016748126363381743,-0.007465453818440437,-0.0030989127699285746],"maxPosition",8,[1,0.019027747213840485,0.007291050627827644,0.0016704918816685677]]],-1],0,0,[],[],[]],[[[11,".bin",917030569,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":12480,"length":1920,"count":480,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":12480,"count":260,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.019027747213840485,-0.007465453818440437,-0.003098907880485058],"maxPosition",8,[1,0.0016748126363381743,0.007291050627827644,0.0016704918816685677]]],-1],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["2eEaZj+GpA3445jGNIbTJG"]}],[1],0,[],[],[]],[[{"name":"icon","rect":{"x":0,"y":0,"width":198,"height":198},"offset":{"x":0,"y":0},"originalSize":{"width":198,"height":198},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[4],0,[0],[11],[125]],[[[74,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true,"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainColor",8,[4,3959422975],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[7,6],[126,6]],[[[47,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true},{},{}],[[[{},"mainColor",8,[4,4294940928]],{},{}],11,0,0]]],0,0,[0],[6],[6]],[[[11,".bin",2342420532,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":22248,"length":3504,"count":876,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":22248,"count":309,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.12506414949893951,0.34783291816711426,-0.07924948632717133],"maxPosition",8,[1,0.12241599708795547,0.5570920705795288,0.14506348967552185]]],-1],0,0,[],[],[]],[[[73,"Skin-0",1279062076,["Root_M/buttock_L"],[[[7,1,-5.348829891036063e-16,-1.6772100375206378e-9,0,5.335503945193385e-16,1,-7.945151203614387e-10,0,1.6772100375206378e-9,7.945151203614387e-10,1,0,-0.00032889118301682174,-0.15005150437355042,0.06304768472909927,1]],8]]],0,0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["322PyWMu1CPbla5d4dpwqk@b1345"]}],[1],0,[],[],[]],[[[11,".bin",3044670045,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":214368,"length":24336,"count":6084,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":214368,"count":3828,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.4756031930446625,0.21085284650325775,0.0003200564533472061],"maxPosition",8,[1,-0.2999701499938965,0.38198626041412354,0.3399622440338135]]],-1],0,0,[],[],[]],[[[11,".bin",3120257591,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":42264,"length":7944,"count":1986,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":42264,"count":587,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,7,8,9,10,11,12,13,14,15,16,17,18,19,20,24,25]]},"minPosition",8,[1,-0.21110644936561584,0.10699793696403503,-0.08597378432750702],"maxPosition",8,[1,0.21110647916793823,0.3482615649700165,0.10603184998035431]]],-1],0,0,[],[],[]],[[[73,"Skin-2",3637680442,["Root_M","Root_M/Spine1_M","Root_M/Spine1_M/Spine2_M","Root_M/Spine1_M/Spine2_M/Chest_M","Root_M/Spine1_M/Spine2_M/Chest_M/Neck_M","Root_M/Spine1_M/Spine2_M/Chest_M/Neck_M/Head_M","Root_M/Spine1_M/Spine2_M/Chest_M/Neck_M/Head_M/HeadEnd_M","Root_M/Spine1_M/Spine2_M/Chest_M/Scapula_R","Root_M/Spine1_M/Spine2_M/Chest_M/Scapula_R/Shoulder_R","Root_M/Spine1_M/Spine2_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R","Root_M/Spine1_M/Spine2_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R","Root_M/Spine1_M/Spine2_M/Chest_M/Scapula_L","Root_M/Spine1_M/Spine2_M/Chest_M/Scapula_L/Shoulder_L","Root_M/Spine1_M/Spine2_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L","Root_M/Spine1_M/Spine2_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L","Root_M/Spine1_M/Belly1_M","Root_M/buttock_L","Root_M/joint1_R","Root_M/joint2_L","Root_M/Hip_R","Root_M/Hip_R/Knee_R","Root_M/Hip_R/Knee_R/Ankle_R","Root_M/Hip_R/Knee_R/Ankle_R/Toes_R","Root_M/Hip_R/Knee_R/Ankle_R/Toes_R/ToesEnd_R","Root_M/Hip_L","Root_M/Hip_L/Knee_L","Root_M/Hip_L/Knee_L/Ankle_L","Root_M/Hip_L/Knee_L/Ankle_L/Toes_L","Root_M/Hip_L/Knee_L/Ankle_L/Toes_L/ToesEnd_L"],[[[7,2.8306835245613853e-16,-2.724075957819959e-16,1,0,0.9992635846138,0.0383700430393219,-2.724075957819959e-16,0,-0.0383700430393219,0.9992635846138,2.8306835245613853e-16,0,-0.12750771641731262,-0.0025957876350730658,3.2829210325453567e-17,1],[7,2.832143068208623e-16,-2.77319513373344e-16,1,0,0.9997788071632385,0.021030396223068237,-2.77319513373344e-16,0,-0.021030396223068237,0.9997788071632385,2.832143068208623e-16,0,-0.17477837204933167,0.00043609683052636683,3.929222060551414e-17,1],[7,2.8326849045970696e-16,-2.8108735415074753e-16,1,0,0.9999701380729675,0.007729516830295324,-2.8108735415074753e-16,0,-0.007729516830295324,0.9999701380729675,2.8326849045970696e-16,0,-0.22773650288581848,0.0034657453652471304,3.5683665035586256e-17,1],[7,2.827994194953853e-16,-2.997180026442835e-16,1,0,0.9983143210411072,-0.058038849383592606,-2.997180026442835e-16,0,0.058038849383592606,0.9983143210411072,2.827994194953853e-16,0,-0.2802310287952423,0.02193942479789257,9.734971996670213e-18,1],[7,2.826187103100445e-16,-3.0257705647862196e-16,1,0,0.9976763129234314,-0.06813164800405502,-3.0257705647862196e-16,0,0.06813164800405502,0.9976763129234314,2.826187103100445e-16,0,-0.3299466669559479,0.025277405977249146,-2.844111974625571e-17,1],[7,2.83266161119102e-16,-2.857478617754387e-16,1,0,0.9999619722366333,-0.008722576312720776,-2.857478617754387e-16,0,0.008722576312720776,0.9999619722366333,2.83266161119102e-16,0,-0.39951708912849426,0.0015381244011223316,-1.1187290883001618e-16,1],[7,2.83266161119102e-16,-2.857478617754387e-16,1,0,0.9999619722366333,-0.008722576312720776,-2.857478617754387e-16,0,0.008722576312720776,0.9999619722366333,2.83266161119102e-16,0,-0.5205498933792114,0.0015381244011223316,-6.955730007222888e-17,1],[7,-1,-0.00018212287977803499,-0.00011399816867196932,0,-0.00010398840822745115,-0.054046712815761566,0.9985383749008179,0,-0.0001880179188447073,0.9985383749008179,0.054046694189310074,0,-0.037061236798763275,0.008283362723886967,-0.29953354597091675,1],[7,-0.9998190999031067,-0.019020864740014076,0.0000025862748316285433,0,0.0010306998156011105,-0.0540422759950161,0.9985381364822388,0,-0.018992917612195015,0.9983574748039246,0.05405210703611374,0,-0.061684053391218185,0.007124192081391811,-0.2995263338088989,1],[7,-0.9997711181640625,0.021395554766058922,0.0000025862748316285433,0,-0.0011538928374648094,-0.054039787501096725,0.9985381364822388,0,0.021364416927099228,0.9983095526695251,0.05405210703611374,0,-0.15465408563613892,0.01338441576808691,-0.2995263338088989,1],[7,-0.9997711181640625,0.021395554766058922,0.0000025862748316285433,0,-0.0011538928374648094,-0.054039787501096725,0.9985381364822388,0,0.021364416927099228,0.9983095526695251,0.05405210703611374,0,-0.2362636774778366,0.01338441576808691,-0.2995263338088989,1],[7,-1,-0.00018214024021290243,-0.00011400903895264491,0,0.00010399832535767928,0.05404670909047127,-0.9985383749008179,0,0.00018803584680426866,-0.9985383749008179,-0.054046690464019775,0,0.03706123307347298,-0.008283360861241817,0.29953354597091675,1],[7,-0.9998190999031067,-0.01902088150382042,0.000002575403414084576,0,-0.0010306898038834333,0.0540422759950161,-0.9985381364822388,0,0.018992936238646507,-0.9983574748039246,-0.05405210331082344,0,0.061684053391218185,-0.0071241906844079494,0.2995263338088989,1],[7,-0.9997711181640625,0.02139553800225258,0.000002575403414084576,0,0.0011539027327671647,0.05403978377580643,-0.9985381364822388,0,-0.021364398300647736,-0.9983095526695251,-0.05405210331082344,0,0.15465408563613892,-0.013384414836764336,0.2995263338088989,1],[7,-0.9997711181640625,0.02139553800225258,0.000002575403414084576,0,0.0011539027327671647,0.05403978377580643,-0.9985381364822388,0,-0.021364398300647736,-0.9983095526695251,-0.05405210331082344,0,0.2362636774778366,-0.013384414836764336,0.2995263338088989,1],[7,1,-1.7307391537612923e-18,-9.192672734137375e-10,0,1.4516892364491303e-17,1,1.3909070339934715e-8,0,9.192672734137375e-10,-1.3909069451756295e-8,1,0,-6.471603808400062e-11,-0.18404220044612885,-0.07039958238601685,1],[7,1,-5.348829891036063e-16,-1.6772100375206378e-9,0,5.335503945193385e-16,1,-7.945151203614387e-10,0,1.6772100375206378e-9,7.945151203614387e-10,1,0,-0.00032889118301682174,-0.15005150437355042,0.06304768472909927,1],[7,1,-5.348829891036063e-16,-1.6772100375206378e-9,0,5.335503945193385e-16,1,-7.945151203614387e-10,0,1.6772100375206378e-9,7.945151203614387e-10,1,0,0.09136062115430832,-0.15880857408046722,-0.009214391931891441,1],[7,1,7.171327156172097e-16,1.6772084832084033e-9,0,7.000524021149451e-16,-1,1.0183775600580702e-8,0,1.6772084832084033e-9,-1.0183775600580702e-8,-1,0,-0.09136059880256653,0.15880900621414185,0.009214388206601143,1],[7,-0.04012142866849899,0.0064054131507873535,-0.9991742968559265,0,-0.930670440196991,0.3636980354785919,0.03970224782824516,0,0.3636520504951477,0.9314948916435242,-0.008630757220089436,0,0.10476471483707428,-0.03824291750788689,-0.06004457175731659,1],[7,-0.033584825694561005,-0.022865213453769684,-0.9991742968559265,0,-0.9266262650489807,-0.37388163805007935,0.03970224782824516,0,-0.3744807243347168,0.9271945357322693,-0.008630757220089436,0,0.06592055410146713,0.00959679577499628,-0.06004457175731659,1],[7,3.3672215238311765e-8,0.007054429035633802,-0.9999751448631287,0,-1,-3.309362739400967e-8,-3.390651670542866e-8,0,-3.3331993165575113e-8,0.9999751448631287,0.007054429035633802,0,0.027068354189395905,0.0013068392872810364,-0.059003185480833054,1],[7,0.0000012926873296237318,1.7518367201319052e-7,-1,0,-0.1345013678073883,0.9909133911132812,-2.7635382870982994e-10,0,0.9909133911132812,0.1345013678073883,0.0000013045035984760034,0,-0.028417933732271194,-0.00626268470659852,-0.058800093829631805,1],[7,-0.0000012920086192025337,-1.7564914855938696e-7,-1,0,-0.1345013678073883,0.9909133911132812,-2.7617749753794385e-10,0,0.9909133911132812,0.1345013678073883,-0.000001303893668591627,0,-0.03655139356851578,-0.006262705661356449,-0.058800019323825836,1],[7,-0.04012142866849899,0.0064054131507873535,-0.9991742968559265,0,0.930670440196991,-0.3636980652809143,-0.03970224782824516,0,-0.3636520504951477,-0.9314948916435242,0.008630757220089436,0,-0.10476471483707428,0.03824291750788689,0.06004457175731659,1],[7,-0.033584825694561005,-0.022865213453769684,-0.9991742968559265,0,0.9266262650489807,0.37388163805007935,-0.03970224782824516,0,0.3744807243347168,-0.9271945357322693,0.008630757220089436,0,-0.06592055410146713,-0.00959679577499628,0.06004457175731659,1],[7,3.287529537487899e-8,0.007054429035633802,-0.9999751448631287,0,1,3.230477574334145e-8,3.310400842337913e-8,0,3.253749980558496e-8,-0.9999751448631287,-0.007054429035633802,0,-0.027068352326750755,-0.0013068391708657146,0.059003185480833054,1],[7,-0.0000012908774351672037,-1.7609561098197446e-7,-1,0,0.1345013529062271,-0.9909133911132812,8.707315979350483e-10,0,-0.9909133911132812,-0.1345013529062271,0.0000013028328567088465,0,0.02841808646917343,0.006262705661356449,0.058800019323825836,1],[7,-0.0000012908774351672037,-1.7609561098197446e-7,-1,0,0.1345013529062271,-0.9909133911132812,8.707315979350483e-10,0,-0.9909133911132812,-0.1345013529062271,0.0000013028328567088465,0,0.03655139356851578,0.006262705661356449,0.058800019323825836,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[11,".bin",273581643,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":92736,"length":26232,"count":6558,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":92736,"count":1288,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,24,25,26,27]]},"minPosition",8,[1,-0.2532799541950226,-0.0002595180121716112,-0.07259728014469147],"maxPosition",8,[1,0.2532799541950226,0.5148173570632935,0.1084643006324768]]],-1],0,0,[],[],[]],[[[73,"Skin-3",3310967661,["Root_M/Spine1_M/Spine2_M/Chest_M/Neck_M/Head_M"],[[[7,2.83266161119102e-16,-2.857478617754387e-16,1,0,0.9999619722366333,-0.008722576312720776,-2.857478617754387e-16,0,0.008722576312720776,0.9999619722366333,2.83266161119102e-16,0,-0.39951708912849426,0.0015381244011223316,-1.1187290883001618e-16,1]],8]]],0,0,[],[],[]],[[{"fmt":"1","w":0,"h":0},-1],[0],0,[],[],[]],[[[11,".bin",3322788929,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":33480,"length":4212,"count":1053,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":33480,"count":465,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.12607599794864655,0.044656604528427124,-0.1034713014960289],"maxPosition",8,[1,0.13143639266490936,0.3155306875705719,-0.0779692530632019]]],-1],0,0,[],[],[]],[[[73,"Skin-1",3637680442,["Root_M","Root_M/Spine1_M","Root_M/Spine1_M/Spine2_M","Root_M/Spine1_M/Spine2_M/Chest_M","Root_M/Spine1_M/Spine2_M/Chest_M/Neck_M","Root_M/Spine1_M/Spine2_M/Chest_M/Neck_M/Head_M","Root_M/Spine1_M/Spine2_M/Chest_M/Neck_M/Head_M/HeadEnd_M","Root_M/Spine1_M/Spine2_M/Chest_M/Scapula_R","Root_M/Spine1_M/Spine2_M/Chest_M/Scapula_R/Shoulder_R","Root_M/Spine1_M/Spine2_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R","Root_M/Spine1_M/Spine2_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R","Root_M/Spine1_M/Spine2_M/Chest_M/Scapula_L","Root_M/Spine1_M/Spine2_M/Chest_M/Scapula_L/Shoulder_L","Root_M/Spine1_M/Spine2_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L","Root_M/Spine1_M/Spine2_M/Chest_M/Scapula_L/Shoulder_L/Elbow_L/Wrist_L","Root_M/Spine1_M/Belly1_M","Root_M/buttock_L","Root_M/joint1_R","Root_M/joint2_L","Root_M/Hip_R","Root_M/Hip_R/Knee_R","Root_M/Hip_R/Knee_R/Ankle_R","Root_M/Hip_R/Knee_R/Ankle_R/Toes_R","Root_M/Hip_R/Knee_R/Ankle_R/Toes_R/ToesEnd_R","Root_M/Hip_L","Root_M/Hip_L/Knee_L","Root_M/Hip_L/Knee_L/Ankle_L","Root_M/Hip_L/Knee_L/Ankle_L/Toes_L","Root_M/Hip_L/Knee_L/Ankle_L/Toes_L/ToesEnd_L"],[[[7,2.8306835245613853e-16,-2.724075957819959e-16,1,0,0.9992635846138,0.0383700430393219,-2.724075957819959e-16,0,-0.0383700430393219,0.9992635846138,2.8306835245613853e-16,0,-0.12750771641731262,-0.0025957876350730658,3.2829210325453567e-17,1],[7,2.832143068208623e-16,-2.77319513373344e-16,1,0,0.9997788071632385,0.021030396223068237,-2.77319513373344e-16,0,-0.021030396223068237,0.9997788071632385,2.832143068208623e-16,0,-0.17477837204933167,0.00043609683052636683,3.929222060551414e-17,1],[7,2.8326849045970696e-16,-2.8108735415074753e-16,1,0,0.9999701380729675,0.007729516830295324,-2.8108735415074753e-16,0,-0.007729516830295324,0.9999701380729675,2.8326849045970696e-16,0,-0.22773650288581848,0.0034657453652471304,3.5683665035586256e-17,1],[7,2.827994194953853e-16,-2.997180026442835e-16,1,0,0.9983143210411072,-0.058038849383592606,-2.997180026442835e-16,0,0.058038849383592606,0.9983143210411072,2.827994194953853e-16,0,-0.2802310287952423,0.02193942479789257,9.734971996670213e-18,1],[7,2.826187103100445e-16,-3.0257705647862196e-16,1,0,0.9976763129234314,-0.06813164800405502,-3.0257705647862196e-16,0,0.06813164800405502,0.9976763129234314,2.826187103100445e-16,0,-0.3299466669559479,0.025277405977249146,-2.844111974625571e-17,1],[7,2.83266161119102e-16,-2.857478617754387e-16,1,0,0.9999619722366333,-0.008722576312720776,-2.857478617754387e-16,0,0.008722576312720776,0.9999619722366333,2.83266161119102e-16,0,-0.39951708912849426,0.0015381244011223316,-1.1187290883001618e-16,1],[7,2.83266161119102e-16,-2.857478617754387e-16,1,0,0.9999619722366333,-0.008722576312720776,-2.857478617754387e-16,0,0.008722576312720776,0.9999619722366333,2.83266161119102e-16,0,-0.5205498933792114,0.0015381244011223316,-6.955730007222888e-17,1],[7,-1,-0.00018212287977803499,-0.00011399816867196932,0,-0.00010398840822745115,-0.054046712815761566,0.9985383749008179,0,-0.0001880179188447073,0.9985383749008179,0.054046694189310074,0,-0.037061236798763275,0.008283362723886967,-0.29953354597091675,1],[7,-0.9998190999031067,-0.019020864740014076,0.0000025862748316285433,0,0.0010306998156011105,-0.0540422759950161,0.9985381364822388,0,-0.018992917612195015,0.9983574748039246,0.05405210703611374,0,-0.061684053391218185,0.007124192081391811,-0.2995263338088989,1],[7,-0.9997711181640625,0.021395554766058922,0.0000025862748316285433,0,-0.0011538928374648094,-0.054039787501096725,0.9985381364822388,0,0.021364416927099228,0.9983095526695251,0.05405210703611374,0,-0.15465408563613892,0.01338441576808691,-0.2995263338088989,1],[7,-0.9997711181640625,0.021395554766058922,0.0000025862748316285433,0,-0.0011538928374648094,-0.054039787501096725,0.9985381364822388,0,0.021364416927099228,0.9983095526695251,0.05405210703611374,0,-0.2362636774778366,0.01338441576808691,-0.2995263338088989,1],[7,-1,-0.00018214024021290243,-0.00011400903895264491,0,0.00010399832535767928,0.05404670909047127,-0.9985383749008179,0,0.00018803584680426866,-0.9985383749008179,-0.054046690464019775,0,0.03706123307347298,-0.008283360861241817,0.29953354597091675,1],[7,-0.9998190999031067,-0.01902088150382042,0.000002575403414084576,0,-0.0010306898038834333,0.0540422759950161,-0.9985381364822388,0,0.018992936238646507,-0.9983574748039246,-0.05405210331082344,0,0.061684053391218185,-0.0071241906844079494,0.2995263338088989,1],[7,-0.9997711181640625,0.02139553800225258,0.000002575403414084576,0,0.0011539027327671647,0.05403978377580643,-0.9985381364822388,0,-0.021364398300647736,-0.9983095526695251,-0.05405210331082344,0,0.15465408563613892,-0.013384414836764336,0.2995263338088989,1],[7,-0.9997711181640625,0.02139553800225258,0.000002575403414084576,0,0.0011539027327671647,0.05403978377580643,-0.9985381364822388,0,-0.021364398300647736,-0.9983095526695251,-0.05405210331082344,0,0.2362636774778366,-0.013384414836764336,0.2995263338088989,1],[7,1,-1.7307391537612923e-18,-9.192672734137375e-10,0,1.4516892364491303e-17,1,1.3909070339934715e-8,0,9.192672734137375e-10,-1.3909069451756295e-8,1,0,-6.471603808400062e-11,-0.18404220044612885,-0.07039958238601685,1],[7,1,-5.348829891036063e-16,-1.6772100375206378e-9,0,5.335503945193385e-16,1,-7.945151203614387e-10,0,1.6772100375206378e-9,7.945151203614387e-10,1,0,-0.00032889118301682174,-0.15005150437355042,0.06304768472909927,1],[7,1,-5.348829891036063e-16,-1.6772100375206378e-9,0,5.335503945193385e-16,1,-7.945151203614387e-10,0,1.6772100375206378e-9,7.945151203614387e-10,1,0,0.09136062115430832,-0.15880857408046722,-0.009214391931891441,1],[7,1,7.171327156172097e-16,1.6772084832084033e-9,0,7.000524021149451e-16,-1,1.0183775600580702e-8,0,1.6772084832084033e-9,-1.0183775600580702e-8,-1,0,-0.09136059880256653,0.15880900621414185,0.009214388206601143,1],[7,-0.04012142866849899,0.0064054131507873535,-0.9991742968559265,0,-0.930670440196991,0.3636980354785919,0.03970224782824516,0,0.3636520504951477,0.9314948916435242,-0.008630757220089436,0,0.10476471483707428,-0.03824291750788689,-0.06004457175731659,1],[7,-0.033584825694561005,-0.022865213453769684,-0.9991742968559265,0,-0.9266262650489807,-0.37388163805007935,0.03970224782824516,0,-0.3744807243347168,0.9271945357322693,-0.008630757220089436,0,0.06592055410146713,0.00959679577499628,-0.06004457175731659,1],[7,3.3672215238311765e-8,0.007054429035633802,-0.9999751448631287,0,-1,-3.309362739400967e-8,-3.390651670542866e-8,0,-3.3331993165575113e-8,0.9999751448631287,0.007054429035633802,0,0.027068354189395905,0.0013068392872810364,-0.059003185480833054,1],[7,0.0000012926873296237318,1.7518367201319052e-7,-1,0,-0.1345013678073883,0.9909133911132812,-2.7635382870982994e-10,0,0.9909133911132812,0.1345013678073883,0.0000013045035984760034,0,-0.028417933732271194,-0.00626268470659852,-0.058800093829631805,1],[7,-0.0000012920086192025337,-1.7564914855938696e-7,-1,0,-0.1345013678073883,0.9909133911132812,-2.7617749753794385e-10,0,0.9909133911132812,0.1345013678073883,-0.000001303893668591627,0,-0.03655139356851578,-0.006262705661356449,-0.058800019323825836,1],[7,-0.04012142866849899,0.0064054131507873535,-0.9991742968559265,0,0.930670440196991,-0.3636980652809143,-0.03970224782824516,0,-0.3636520504951477,-0.9314948916435242,0.008630757220089436,0,-0.10476471483707428,0.03824291750788689,0.06004457175731659,1],[7,-0.033584825694561005,-0.022865213453769684,-0.9991742968559265,0,0.9266262650489807,0.37388163805007935,-0.03970224782824516,0,0.3744807243347168,-0.9271945357322693,0.008630757220089436,0,-0.06592055410146713,-0.00959679577499628,0.06004457175731659,1],[7,3.287529537487899e-8,0.007054429035633802,-0.9999751448631287,0,1,3.230477574334145e-8,3.310400842337913e-8,0,3.253749980558496e-8,-0.9999751448631287,-0.007054429035633802,0,-0.027068352326750755,-0.0013068391708657146,0.059003185480833054,1],[7,-0.0000012908774351672037,-1.7609561098197446e-7,-1,0,0.1345013529062271,-0.9909133911132812,8.707315979350483e-10,0,-0.9909133911132812,-0.1345013529062271,0.0000013028328567088465,0,0.02841808646917343,0.006262705661356449,0.058800019323825836,1],[7,-0.0000012908774351672037,-1.7609561098197446e-7,-1,0,0.1345013529062271,-0.9909133911132812,8.707315979350483e-10,0,-0.9909133911132812,-0.1345013529062271,0.0000013028328567088465,0,0.03655139356851578,0.006262705661356449,0.058800019323825836,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[74,"0",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true,"USE_ALBEDO_MAP":true},{},{}],[[[{"occlusion":0,"roughness":0,"metallic":0,"SpecularIntensity":0},"mainColor",8,[4,4278234623],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[7,6],[69,6]],[[[169,"Walk Break"],[170,"Walk Break",[-3,-4],[-2],[102,"f6h5JTA61Krp7fpJXxRpdl",-1,0],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[171,"Sparkle",1,[-5],[102,"ec12r82KpHmrFyR4IuXAYD",1,0]],[174,1,false,false,0,2,[103,"d6dNQQc1JJ872kZBLdCYV/"],[0],[175,[4,2181038079]],[12,3,0.5,2],[0],[0],[2,5],[0],[0],[176,3,4.71238898038469],[0],[12,3,0.2,0.8],[2,0.2],[0],[0],[[21,[2,10]]],[22,true,[20,1,[28,[[39],[13,0.10044642857142858,[4,4284012543]],[13,0.2700892857142857,[4,4280130815]],[13,1,[4,4278190335]]]]]],[178,true,3,0.01,[2,1]],[29,[15,1,[16,[0,0.2846153846153846,0.49230769230769234,0.6846153846153846,1],[[129,2,6.066666666666666,6.066666666666666],[70,2,0.9925925925925926],[70,2,0.5148148148148148],[70,2,0.9962962962962965],[129,2,-5.149758454106279,-5.149758454106279]]]],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[61,true,0.01,[0],[0],[0],[2,10]],[25,[0],[0],[177,3,-0.7853981633974483,0.7853981633974483,180]],[181,true,2,2,[15,1,[16,[0,1],[[70,2,1],[70,2,1]]]],[2,3]],[26,[2,1],[0],[9],[9],-6],[182,1,0,1]],[172,"Ring",1,[-7],[102,"f2sDa1qWtF56f7v5izDlLP",1,0],[3,0.7071067811865475,0,0,0.7071067811865476],[1,89.99999999999999,0,0]],[125,1,false,false,4,[103,"d8s2smx0BGKZuCh9SYwYNL"],[2],[9],[2,1],[0],[0],[2,0.01],[0],[0],[0],[0],[2,0.5],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[126,[[60,[4,4278203391]],[96,0.9888392857142857]],[[131,255],[97,0,0.9955357142857143]]]]],[127,0,[2,1]],[128,true,[15,1,[16,[0,1],[[179,2,3,2.6376811594202896,0.49907870413964467,2.6376811594202896,1],[180,2,3,1,1,0.4714045207910316]]]],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[130,[15,1,[16,[0,1],[[70,2,1],[70,2,1]]]],[0]],[26,[2,1],[0],[9],[9],-8],[38,3]],[125,1,false,false,1,[103,"b2Z3tunMxD543DLFEf8MY1"],[4],[9],[12,3,1.5,2.3],[0],[0],[0],[0],[0],[69,3,4.71238898038469],[0],[2,0.12],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[126,[[96,0.002232142857142857],[13,0.5200892857142857,[4,4280596991]],[13,0.9977678571428571,[4,4278216447]]],[[131,255],[97,255,0.9977678571428571]]]]],[127,0,[2,1]],[128,true,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[130,[15,1,[16,[0,1],[[70,2,1],[70,2,1]]]],[0]],[26,[2,1],[0],[9],[9],-9],[38,5]]],0,[0,16,1,0,-1,6,0,-1,2,0,-2,4,0,-1,3,0,3,3,0,-1,5,0,3,5,0,3,6,0,43,1,9],[0,0,0,0,0,0],[-1,4,-1,4,-1,4],[70,43,127,72,71,44]],[[[11,".bin",3557673830,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":130512,"length":23172,"count":5793,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":130512,"count":2719,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.003197639249265194,-0.00005396946653490886,-0.003193923505023122],"maxPosition",8,[1,0.005336482543498278,0.019998442381620407,0.005217656027525663]]],-1],0,0,[],[],[]],[[[47,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true,"HAS_SECOND_UV":true,"USE_ALBEDO_MAP":true},{},{}],[[[{"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[7,6],[69,6]],[[[47,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[7,6],[43,14]],[[[47,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[7,6],[44,14]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["41czDe+hJIArQqaw4XZ+L6"]}],[1],0,[],[],[]],[[{"name":"tut_hand","rect":{"x":2,"y":2,"width":108,"height":134},"offset":{"x":0,"y":0},"originalSize":{"width":112,"height":138},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[4],0,[0],[11],[128]],[[[74,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_INSTANCING":true,"USE_LIGHTMAP":true},{},{}],[[[{},"mainColor",8,[4,3372208186],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[7,6],[129,6]],[[[11,".bin",187543112,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":7008,"length":1680,"count":420,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":7008,"count":146,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.004699284676462412,0.0015650882851332426,-0.004699224140495062],"maxPosition",8,[1,0.004699284676462412,0.004009468946605921,0.004699224140495062]]],-1],0,0,[],[],[]],[[[11,".bin",199009772,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6768,"length":1680,"count":420,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":6768,"count":141,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.005977137014269829,-9.73795377667841e-10,-0.00597704341635108],"maxPosition",8,[1,0.005977113265544176,0.0024210817646235228,0.005977053195238113]]],-1],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["4cvCa1mgxPlLhFCZMoZz6x"]}],[1],0,[],[],[]],[[[74,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true},{},{}],[[[{},"mainColor",8,[4,4278190335]],{},{}],11,0,0]]],0,0,[0],[6],[6]],[[[11,".bin",2254166265,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":1008,"count":252,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0008237636648118496,-0.006162404548376799,-0.014634717255830765],"maxPosition",8,[1,0.0008237636648118496,0.006162403151392937,0.014634717255830765]]],-1],0,0,[],[],[]],[[[11,".bin",2975573567,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":35280,"length":7920,"count":1980,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":35280,"count":735,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.007146873511373997,-1.225123752446322e-10,-0.0007057737093418837],"maxPosition",8,[1,0.002633505268022418,0.01577996276319027,0.001747388974763453]]],-1],0,0,[],[],[]],[[[11,".bin",2912657917,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":35280,"length":7920,"count":1980,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":35280,"count":735,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.007146873511373997,-1.225123752446322e-10,-0.0017473874613642693],"maxPosition",8,[1,0.002633505268022418,0.01577996276319027,0.0007057737675495446]]],-1],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["50LQlrSVNMD70mm+01Hc0E"]}],[1],0,[],[],[]],[[{"name":"hand","rect":{"x":0,"y":0,"width":205,"height":168},"offset":{"x":0,"y":0},"originalSize":{"width":205,"height":168},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[4],0,[0],[11],[130]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["52vf0vl2VCIIG7oj5WyUi9"]}],[1],0,[],[],[]],[[[47,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true,"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[7,6],[131,6]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["5aYelt7SZIzat2vnJTRi7a"]}],[1],0,[],[],[]],[[{"name":"text_dragtomove","rect":{"x":1,"y":2,"width":438,"height":56},"offset":{"x":0,"y":0},"originalSize":{"width":440,"height":60},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[4],0,[0],[11],[132]],[[[11,".bin",96470146,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":19264,"length":2496,"count":624,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":19264,"count":344,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.007814688608050346,-0.007526932284235954,-0.0010816886788234115],"maxPosition",8,[1,0,0.007286946754902601,0.0011317601893097162]]],-1],0,0,[],[],[]],[[[11,".bin",212083226,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":19264,"length":2496,"count":624,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":19264,"count":344,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,0,-0.007526932284235954,-0.0010816886788234115],"maxPosition",8,[1,0.007814688608050346,0.007286946754902601,0.0011317601893097162]]],-1],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["5dbVvn+olAg4I5LaULAS+p"]}],[1],0,[],[],[]],[[{"name":"text_gradient","rect":{"x":0,"y":0,"width":16,"height":478},"offset":{"x":0,"y":0},"originalSize":{"width":16,"height":478},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[4],0,[0],[11],[133]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["62BflQnDlPi4iyJvQocT+3"]}],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["65K0Btu8BBKa488G4VTYhg"]}],[1],0,[],[],[]],[[{"name":"time_tab1","rect":{"x":0,"y":0,"width":479,"height":92},"offset":{"x":0,"y":0},"originalSize":{"width":479,"height":92},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[4],0,[0],[11],[134]],[[[11,".bin",1983878921,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":249760,"length":25728,"count":6432,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":249760,"count":4460,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.0034827557392418385,-1.7630813475832952e-9,-0.0033954354003071785],"maxPosition",8,[1,0.0034827557392418385,0.0037849312648177147,0.003395435865968466]]],-1],0,0,[],[],[]],[[[47,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.30151134729385376,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[7,6],[69,6]],[[[72,"lose_sfx",".mp3",4.153425],-1],0,0,[],[],[]],[[[47,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"HAS_SECOND_UV":true},{},{}],[[[{"roughness":0.617,"metallic":0.4000000059604645},"mainColor",8,[4,4294741929]],{},{}],11,0,0]]],0,0,[0],[6],[6]],[[{"base":"2,2,0,0,2,0","rgbe":false,"mipmaps":[{"front":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@e9a6d","back":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@40c10","left":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@8fd34","right":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@74afd","top":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@bb97f","bottom":"6f01cf7f-81bf-4a7e-bd5d-0afc19696480@b47c0@7d38f"}]}],[22],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["78XW5GxOhAd6p2lnTVeP4d"]}],[1],0,[],[],[]],[[{"name":"title_game","rect":{"x":0,"y":0,"width":556,"height":220},"offset":{"x":-0.5,"y":0},"originalSize":{"width":557,"height":220},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[4],0,[0],[11],[135]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["7dj5uJT9FMn6OrOOx83tfK"]}],[1],0,[],[],[]],[[{"name":"default_sprite_splash","rect":{"x":0,"y":0,"width":2,"height":2},"offset":{"x":0,"y":0},"originalSize":{"width":2,"height":2},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[4],0,[0],[11],[136]],[[[47,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[7,6],[72,14]],[[[11,".bin",847924299,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0024998162407428026,-0.002499816007912159,-0.002499816007912159],"maxPosition",8,[1,0.0024998162407428026,0.002499816007912159,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",3629589560,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.002499816007912159,-0.0024998162407428026,-0.002499816007912159],"maxPosition",8,[1,0.002499816007912159,0.0024998157750815153,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",1623857048,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0024998157750815153,-0.0024998162407428026,-0.002499816007912159],"maxPosition",8,[1,0.0024998157750815153,0.0024998157750815153,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",2661431015,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0024998169392347336,-0.002499816007912159,-0.002499816007912159],"maxPosition",8,[1,0.002499815309420228,0.002499816007912159,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",66674010,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.002499816007912159,-0.0024998157750815153,-0.002499816007912159],"maxPosition",8,[1,0.002499816007912159,0.0024998162407428026,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",1264274950,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.002499816007912159,-0.002499816007912159,-0.002499816007912159],"maxPosition",8,[1,0.002499816007912159,0.002499816007912159,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",3031773104,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0024998162407428026,-0.0024998162407428026,-0.002499816007912159],"maxPosition",8,[1,0.0024998162407428026,0.0024998157750815153,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",3031773104,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0024998162407428026,-0.0024998162407428026,-0.002499816007912159],"maxPosition",8,[1,0.0024998162407428026,0.0024998157750815153,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",1637630638,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0024998157750815153,-0.0024998157750815153,-0.002499816007912159],"maxPosition",8,[1,0.0024998157750815153,0.0024998162407428026,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",4119393415,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.002499816007912159,-0.0024998162407428026,-0.002499816007912159],"maxPosition",8,[1,0.002499816007912159,0.0024998157750815153,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",66674010,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.002499816007912159,-0.0024998157750815153,-0.002499816007912159],"maxPosition",8,[1,0.002499816007912159,0.0024998162407428026,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",847924299,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0024998162407428026,-0.002499816007912159,-0.002499816007912159],"maxPosition",8,[1,0.0024998162407428026,0.002499816007912159,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",3192444665,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.002499816007912159,-0.002499816007912159,-0.002499816007912159],"maxPosition",8,[1,0.002499816007912159,0.002499816007912159,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",66674010,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.002499816007912159,-0.0024998157750815153,-0.002499816007912159],"maxPosition",8,[1,0.002499816007912159,0.0024998162407428026,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",4119393415,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.002499816007912159,-0.0024998162407428026,-0.002499816007912159],"maxPosition",8,[1,0.002499816007912159,0.0024998157750815153,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",3294857006,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0024998162407428026,-0.0024998157750815153,-0.002499816007912159],"maxPosition",8,[1,0.0024998162407428026,0.0024998162407428026,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",215310685,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.002499816007912159,-0.002499816007912159,-0.002499816007912159],"maxPosition",8,[1,0.002499816007912159,0.002499816007912159,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",2529725536,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0024998157750815153,-0.002499816007912159,-0.002499816007912159],"maxPosition",8,[1,0.0024998157750815153,0.002499816007912159,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",4119393415,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.002499816007912159,-0.0024998162407428026,-0.002499816007912159],"maxPosition",8,[1,0.002499816007912159,0.0024998157750815153,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",3119301634,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0024998169392347336,-0.0024998157750815153,-0.002499816007912159],"maxPosition",8,[1,0.002499815309420228,0.0024998162407428026,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",3192444665,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.002499816007912159,-0.002499816007912159,-0.002499816007912159],"maxPosition",8,[1,0.002499816007912159,0.002499816007912159,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",816707279,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0024998169392347336,-0.0024998162407428026,-0.002499816007912159],"maxPosition",8,[1,0.002499815309420228,0.0024998157750815153,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",3294857006,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.0024998162407428026,-0.0024998157750815153,-0.002499816007912159],"maxPosition",8,[1,0.0024998162407428026,0.0024998162407428026,0.002499816007912159]]],-1],0,0,[],[],[]],[[[11,".bin",1255485749,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":4608,"length":528,"count":132,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":4608,"count":96,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.002499816007912159,-0.0024998157750815153,-0.002499816007912159],"maxPosition",8,[1,0.002499816007912159,0.0024998162407428026,0.002499816007912159]]],-1],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["8cLFThm8JK4aFUZOzrno2S"]}],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["8fzCJGh7xEKrfC7z4lTGoe"]}],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["96ISdYN/pKSK1CQW/sEPvF"]}],[1],0,[],[],[]],[[[74,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true,"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[7,6],[137,6]],[[[47,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.30151134729385376,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[7,6],[73,6]],[[[11,".bin",923119503,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":25200,"length":10476,"count":2619,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":25200,"count":525,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.008112297393381596,-0.0000025160081804642687,-0.008118667639791965],"maxPosition",8,[1,0.008211755193769932,0.00033962499583140016,0.008173173293471336]]],-1],0,0,[],[],[]],[[[72,"win",".mp3",1.776327],-1],0,0,[],[],[]],[[[74,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true,"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainColor",8,[4,4278255605],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[7,6],[138,6]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["acRkRdhndJooQl+r58DQxS"]}],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["adFj3JcEZNabOAtAOTI+9s"]}],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["b2MxkzZKxHeq7NsiMjm/Lr"]}],[1],0,[],[],[]],[[[168,"enemy_police1",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"HAS_SECOND_UV":true,"USE_ALBEDO_MAP":true}],[[[{"metallic":0.4000000059604645,"roughness":0.30151134729385376},"mainTexture",6,0]],11]]],0,0,[0,0],[7,6],[139,6]],[[{"fmt":"1","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["b7wS4ssk9NqbyI19bmAGNP"]}],[1],0,[],[],[]],[[[72,"electric2_sfx",".mp3",0.485333],-1],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["bdlD1yPolAV6FO+5ND3N7x"]}],[1],0,[],[],[]],[[{"name":"Download","rect":{"x":0,"y":0,"width":373,"height":167},"offset":{"x":0,"y":0},"originalSize":{"width":373,"height":167},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[4],0,[0],[11],[140]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["c6q4qImG9J8qs7j3XMkTZj"]}],[1],0,[],[],[]],[[[74,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true},{},{}],[[[{},"mainColor",8,[4,4287233800]],{},{}],11,0,0]]],0,0,[0],[6],[6]],[[{"base":"2,2,0,0,2,0","rgbe":true,"mipmaps":[{"front":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@e9a6d","back":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@40c10","left":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@8fd34","right":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@74afd","top":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@bb97f","bottom":"d032ac98-05e1-4090-88bb-eb640dcb5fc1@b47c0@7d38f"}]}],[22],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[[107,"builtin-particle",[{"hash":2554907268,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\n  uniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":52,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":40}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]},{"hash":1720952533,"name":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]},{"name":"FragConstants","stageFlags":16,"binding":1,"members":[{"name":"tintColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = multiply(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\n  uniform vec4 tintColor;\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = multiply(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":52,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":40}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]},{"hash":1759026248,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = addSmooth(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 addSmooth () {\n  vec4 col = color * texture2D(mainTexture, uv);\n  col.rgb *= col.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = addSmooth(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":52,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":39}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]},{"hash":3775475229,"name":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","blocks":[{"name":"Constants","stageFlags":1,"binding":0,"members":[{"name":"mainTiling_Offset","type":16,"count":1},{"name":"frameTile_velLenScale","type":16,"count":1},{"name":"scale","type":16,"count":1},{"name":"nodeRotation","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_texCoord","format":32,"location":1,"defines":[]},{"name":"a_texCoord1","format":32,"location":2,"defines":[]},{"name":"a_texCoord2","format":32,"location":3,"defines":[]},{"name":"a_color","format":44,"location":4,"defines":[]},{"name":"a_color1","format":32,"location":8,"defines":["CC_RENDER_MODE"]},{"name":"a_texCoord3","format":32,"location":6,"defines":["CC_RENDER_MODE"]},{"name":"a_normal","format":32,"location":7,"defines":["CC_RENDER_MODE"]}],"varyings":[{"name":"uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":[]},{"name":"color","type":16,"count":1,"stageFlags":17,"location":1,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 8) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 8) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl3":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n  vec4 nodeRotation;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = premultiplied(); }"},"glsl1":{"vert":"\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nmat3 quatToMat3(vec4 q) {\n  vec3 m0 = vec3(\n    1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z,\n    2.0 * q.x * q.y + 2.0 * q.w * q.z,\n    2.0 * q.x * q.z - 2.0 * q.w * q.y);\n\tvec3 m1 = vec3(\n    2.0 * q.x * q.y - 2.0 * q.w * q.z,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.z * q.z,\n    2.0 * q.y * q.z + 2.0 * q.w * q.x);\n\tvec3 m2 = vec3(\n    2.0 * q.x * q.z + 2.0 * q.w * q.y,\n    2.0 * q.y * q.z - 2.0 * q.w * q.x,\n    1.0 - 2.0 * q.x * q.x - 2.0 * q.y * q.y);\n  return mat3(m0, m1, m2);\n}\nvec4 mat3ToQuat(mat3 mat) {\n  float tr = mat[0][0] + mat[1][1] + mat[2][2];\n\tfloat qw, qx, qy, qz;\n  if (tr > 0.0) {\n    float S = sqrt(tr + 1.0) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = 0.25 * S;\n\t  qx = (mat[1][2] - mat[2][1]) * invS;\n\t  qy = (mat[2][0] - mat[0][2]) * invS;\n\t  qz = (mat[0][1] - mat[1][0]) * invS;\n  } else if ((mat[0][0] > mat[1][1])&&(mat[0][0] > mat[2][2])) {\n    float S = sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[1][2] - mat[2][1]) * invS;\n\t  qx = 0.25 * S;\n\t  qy = (mat[1][0] + mat[0][1]) * invS;\n\t  qz = (mat[2][0] + mat[0][2]) * invS;\n  } else if (mat[1][1] > mat[2][2]) {\n\t  float S = sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[2][0] - mat[0][2]) * invS;\n\t  qx = (mat[1][0] + mat[0][1]) * invS;\n\t  qy = 0.25 * S;\n\t  qz = (mat[2][1] + mat[1][2]) * invS;\n  } else {\n\t  float S = sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2.0;\n\t  float invS = 1.0 / S;\n\t  qw = (mat[0][1] - mat[1][0]) * invS;\n\t  qx = (mat[2][0] + mat[0][2]) * invS;\n\t  qy = (mat[2][1] + mat[1][2]) * invS;\n\t  qz = 0.25 * S;\n  }\n  return vec4(qx, qy, qz, qw);\n}\n   uniform vec4 mainTiling_Offset;\n   uniform vec4 frameTile_velLenScale;\n   uniform vec4 scale;\n   uniform vec4 nodeRotation;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewInv;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  rotateVecFromQuat(viewSpaceVert, q);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    vec3 rotTmp = a_texCoord2;\n    float mulFactor = 1.0;\n    if (rotTmp.x > 10.0 * 0.5) {\n        rotTmp.x -= 10.0;\n        mulFactor = -1.0;\n    }\n    vec4 rot = vec4(rotTmp, 0.0);\n    rot.w = mulFactor * sqrt(abs(1.0 - rot.x * rot.x - rot.y * rot.y - rot.z * rot.z));\n  #else\n    #if CC_RENDER_MODE != 4\n      #if CC_RENDER_MODE == 0\n        vec3 rotEuler = a_texCoord2;\n      #elif CC_RENDER_MODE == 1\n        vec3 rotEuler = vec3(0.);\n      #else\n        vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n      #endif\n      vec4 rot = quaternionFromEuler(rotEuler);\n    #else\n      vec4 rot = quaternionFromEuler(a_texCoord2);\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_matViewInv);\n    #elif CC_RENDER_MODE == 1\n      computeVertPos(pos, cornerOffset, rot, compScale, cc_cameraPos.xyz, velocity, frameTile_velLenScale.z, frameTile_velLenScale.w, a_texCoord.x);\n    #elif 2\n      computeVertPos(pos, cornerOffset, rot, compScale);\n    #endif\n    color = a_color;\n  #else\n    mat3 rotMat = quatToMat3(rot);\n    mat3 nodeMat = quatToMat3(nodeRotation);\n    rotMat = nodeMat * rotMat;\n    rot = mat3ToQuat(rotMat);\n    mat4 xformNoScale = matrixFromRT(rot, pos.xyz);\n    mat4 xform = matFromRTS(rot, pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }","frag":"\nprecision mediump float;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nvec4 premultiplied () {\n  vec4 col = color * texture2D(mainTexture, uv) * color.a;\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = premultiplied(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":52,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":39}},"defines":[{"name":"CC_RENDER_MODE","type":"number","defines":[],"range":[0,4]},{"name":"CC_USE_WORLD_SPACE","type":"boolean","defines":[]},{"name":"ROTATION_OVER_TIME_MODULE_ENABLE","type":"boolean","defines":[]}]}],[{"name":"add","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"alpha-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-multiply","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:multiply","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":7,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":3}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]},"tintColor":{"type":16,"value":[0.5,0.5,0.5,0.5],"editor":{"type":"color"}}}}]},{"name":"add-smooth","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:addSmooth","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]},{"name":"premultiply-blend","passes":[{"program":"builtin-particle|particle-vs-legacy:lpvs_main|no-tint-fs:premultiplied","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"grey","type":28},"mainTiling_Offset":{"type":16,"value":[1,1,0,0]}}}]}]]],0,0,[],[],[]],[[[47,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[7,6],[2,14]],[[[47,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[7,6],[2,14]],[[[74,"1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true,"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[7,6],[141,6]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["dcCTiT2PVBO4UvIzXQfNk9"]}],[1],0,[],[],[]],[[{"name":"tryBtn","rect":{"x":0,"y":0,"width":373,"height":167},"offset":{"x":0,"y":0},"originalSize":{"width":373,"height":167},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[4],0,[0],[11],[142]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["deaoOX0RFK54zvVtz/nhBo"]}],[1],0,[],[],[]],[[{"name":"time_tab2","rect":{"x":91,"y":30,"width":376,"height":34},"offset":{"x":39.5,"y":-1},"originalSize":{"width":479,"height":92},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[4],0,[0],[11],[143]],[[[47,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true,"HAS_SECOND_UV":true},{},{}],[[[{"roughness":0.30151134729385376,"metallic":0},"mainColor",8,[4,4293778943]],{},{}],11,0,0]]],0,0,[0],[6],[6]],[[[47,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_LIGHTMAP":true,"USE_ALBEDO_MAP":true},{},{}],[[[{},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[7,6],[144,6]],[[[132,"CatScene2"],[36,"break_wall_",[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24]],[36,"break_wall_",[-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48]],[8,["d8s2smx0BGKZuCh9SYwYNL"]],[114,"Canvas2D",33554432,[-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63],[[32,-49,[5,320,480]],[133,-51,-50],[134,45,-2.842170943040401e-14,-2.842170943040401e-14,-52]],[1,160,239.99999999999997,0]],[119,"Boss",[[[54,"lv1_policeman",-73],-74,-75,-76,-77],4,1,1,1,1],[[135,true,-65,[290,291,292],[[83,"Root_M/Spine1_M/Spine2_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R",-64]],293],[27,-66,[1,0,0.3,0],[1,0.3,0.58,0.3]],[52,16,100,-67,[1,1,0,1],[1,1,0,1]],[141,-72,-71,-70,-69,-68]],[1,5.914,0,2.109],[3,0,1,0,6.123233995736766e-17],[1,4,4,4],[1,0,180,0]],[108,"Wall",[-78,-79,-80,-81,-82,-83,-84,-85,-86,-87,-88,-89,-90],[1,1,1.5,0.9999999999999998]],[121,"CatController",[-97,-98,-99,-100,-101,-102],[[[136,-93,[241,242],[[83,"Root_M/Tail0_M/Tail1_M/Tail2_M/Tail3_M/Tail4_M/Tail5_M",-91],[83,"Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Neck_M/NeckPart1_M/Head_M/HeadEnd_M",-92]],243],[27,-94,[1,0,0.02,0.004],[1,0.033,0.04,0.043]],[139,100,-95,[1,1,0,1]],-96],4,4,4,1],[1,-7.64,0,2.195],[3,0,0.7071067811865475,0,0.7071067811865476],[1,30,30,30],[1,0,90,0]],[36,"Room",[-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113]],[90,"AudioManager","91MUdo8mRCu5o6mQ9zrX1M",[-115,-116,-117,-118,-119,-120,-121,-122],[-114]],[91,"CTA",33554432,4,[-125,-126,-127,-128,-129,-130],[[89,-123],[105,-124,[262],263]]],[109,0,{},[124,"f6h5JTA61Krp7fpJXxRpdl",-133,[142,"0aRJjUW8ZPNJ2S45jl1QOw",null,[[10,"Walk Break",["_name"],[8,["f6h5JTA61Krp7fpJXxRpdl"]]],[57,["_lpos"],[8,["f6h5JTA61Krp7fpJXxRpdl"]],[1,0,0.017,0]],[57,["_lrot"],[8,["f6h5JTA61Krp7fpJXxRpdl"]],[3,0.7071067811865475,0,0,0.7071067811865476]],[57,["_euler"],[8,["f6h5JTA61Krp7fpJXxRpdl"]],[1,90,0,0]],[10,1,["_simulationSpace"],[8,["b2Z3tunMxD543DLFEf8MY1"]]],[57,["_lscale"],[8,["f6h5JTA61Krp7fpJXxRpdl"]],[1,1,1,1]],[10,true,["loop"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,true,["loop"],[8,["b2Z3tunMxD543DLFEf8MY1"]]],[10,true,["loop"],[8,["d8s2smx0BGKZuCh9SYwYNL"]]],[10,0,["scaleSpace"],[8,["b2Z3tunMxD543DLFEf8MY1"]]],[10,0,["scaleSpace"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,0,["scaleSpace"],[8,["d8s2smx0BGKZuCh9SYwYNL"]]],[57,["_lscale"],[8,["ec12r82KpHmrFyR4IuXAYD"]],[1,0.007,0.007,0.007]],[57,["_lpos"],[8,["ec12r82KpHmrFyR4IuXAYD"]],[1,0,0,0.013]],[10,true,["playOnAwake"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,2,["_materials","length"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,null,["_materials","1"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,0.25,["duration"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,0.3,["startSizeX","constantMin"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,2,["startSizeX","constantMax"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,0.35,["simulationSpeed"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,6.283185307179586,["startRotationZ","constantMin"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,0,["gravityModifier","constant"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,false,["startSize3D"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,2,["startSpeed","constant"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,0.6,["startLifetime","constantMax"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,6.283185307179586,["startRotationZ","constantMax"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,true,["_textureAnimationModule","_enable"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[85,["renderer","_mainTexture"],[8,["d6dNQQc1JJ872kZBLdCYV/"]],134],[10,true,["_limitVelocityOvertimeModule","_enable"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,false,["_trailModule","_enable"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,0,["_simulationSpace"],[8,["d8s2smx0BGKZuCh9SYwYNL"]]],[10,true,["playOnAwake"],[8,["d8s2smx0BGKZuCh9SYwYNL"]]],[77,["_lpos"],-131,[1,0,0,0.017]],[85,["_materials","0"],[8,["d8s2smx0BGKZuCh9SYwYNL"]],135],[143,["renderer","_mainTexture"],3,136],[85,["_materials","0"],[8,["d6dNQQc1JJ872kZBLdCYV/"]],137],[10,0,["_simulationSpace"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[17,0.10039999999999999,["_colorOverLifetimeModule","color","gradient","colorKeys","1","time"],3],[17,0.9352678571428571,["_colorOverLifetimeModule","color","gradient","alphaKeys","1","time"],3],[17,4,["_colorOverLifetimeModule","color","gradient","colorKeys","length"],3],[86,["_colorOverLifetimeModule","color","gradient","colorKeys","2"],3,[96,0.2701]],[86,["_colorOverLifetimeModule","color","gradient","colorKeys","3"],3,[13,1,[4,4278190335]]],[77,["_colorOverLifetimeModule","color","gradient","colorKeys","1","color"],3,[4,4284012543]],[17,0.2,["duration"],3],[17,0.1,["simulationSpeed"],3],[77,["startColor","color"],3,[4,2533359615]],[17,false,["startRotation3D"],3],[17,6.283185307179586,["startRotationZ","constant"],3],[77,["_lscale"],-132,[1,0.016,0.016,0.016]],[17,3,["startRotationZ","mode"],3],[17,6.283185307179586,["startRotationZ","constantMin"],3],[17,6.283185307179586,["startRotationZ","constantMax"],3],[17,3,["startLifetime","mode"],3],[17,0.2,["startLifetime","constantMin"],3],[17,0.6,["startLifetime","constantMax"],3],[17,0.8883928571428572,["_colorOverLifetimeModule","color","gradient","alphaKeys","0","time"],3],[17,255,["_colorOverLifetimeModule","color","gradient","alphaKeys","0","alpha"],3],[17,255,["_colorOverLifetimeModule","color","gradient","alphaKeys","1","alpha"],3],[17,3,["_colorOverLifetimeModule","color","gradient","alphaKeys","length"],3],[86,["_colorOverLifetimeModule","color","gradient","alphaKeys","2"],3,[97,255,0.9910714285714286]],[17,0.2,["startSpeed","constant"],3]]],133]],[90,"GameNode","2dHAV5VQFGj4wTXC++MSEv",[-135,-136,-137,-138,4],[-134]],[144,"CatScene2",[12,-149,-150,-151,9,-152],[123,"f82590ab-7475-4b63-9a96-e8c0a6a65b85",[[46,["_trailModule","_particleSystem"],11,[8,["b2Z3tunMxD543DLFEf8MY1"]],11,[8,["b2Z3tunMxD543DLFEf8MY1"]]],[46,["_trailModule","_particleSystem"],11,[8,["d6dNQQc1JJ872kZBLdCYV/"]],11,[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[46,["_trailModule","_particleSystem"],11,[8,["d8s2smx0BGKZuCh9SYwYNL"]],11,[8,["d8s2smx0BGKZuCh9SYwYNL"]]],[46,["_trailModule","_particleSystem"],-140,[8,["5cc7kqZIFB1br2814jbBtQ"]],-139,[8,["5cc7kqZIFB1br2814jbBtQ"]]],[46,["_trailModule","_particleSystem"],-142,[8,["5cc7kqZIFB1br2814jbBtQ"]],-141,[8,["5cc7kqZIFB1br2814jbBtQ"]]],[46,["_trailModule","_particleSystem"],-144,[8,["5cc7kqZIFB1br2814jbBtQ"]],-143,[8,["5cc7kqZIFB1br2814jbBtQ"]]],[46,["_trailModule","_particleSystem"],-146,[8,["5cc7kqZIFB1br2814jbBtQ"]],-145,[8,["5cc7kqZIFB1br2814jbBtQ"]]],[46,["_trailModule","_particleSystem"],-148,[8,["5cc7kqZIFB1br2814jbBtQ"]],-147,[8,["5cc7kqZIFB1br2814jbBtQ"]]],[46,["_sockets","0","target"],5,[8,["bcOyuKyI9UqIPP5L1YlBcV"]],5,[8,["17EzxZGYxR5r4/1hl3YAhn"]]]],[11]],[145,[146,0.5208,[2,0.23529411764705882,0.3607843137254902,0.796078431372549,0.520833125],[2,0.23529411764705882,0.3607843137254902,0.796078431372549,1],[2,0.519964,0.630786,0.905039,0.5208],[2,0.519544,0.630484,0.905069,0]],[147,1,true,2,0.05,0.4,0.2,30,2000,10,0.36,[4,4283190348],[0,2048,2048]],[148,true,294,295],[149],[150]]],[51,"Environment",12,[-153,6,-154,8,-155,-156]],[151,9],[94,"Root_M",5,[[-157,[62,"buttock_L",-158,[1,0.024852434173226357,-0.059839557856321335,0.0003288912703283131],[3,-0.4903136496389626,-0.5095022325542063,-0.4903136496389626,0.5095022325542063],[1,-87.80101540917607,-90,0]],[62,"joint1_R",-159,[1,0.030830349773168564,0.012705310247838497,-0.09136062115430832],[3,-0.4903136496389626,-0.5095022325542063,-0.4903136496389626,0.5095022325542063],[1,-87.80101540917607,-90,0]],[62,"joint2_L",-160,[1,0.030830780044198036,0.012705325148999691,0.09136059880256653],[3,0.5095022325542063,-0.4903136496389626,0.5095022325542063,0.4903136496389626],[1,92.19898459082393,-90,0]],-161,-162],1,4,4,4,1,1],[1,2.557074801318597e-18,0.12751342356204987,-0.0022986005060374737],[3,0.49031366511188224,0.5095022176640187,0.49031366511188224,0.5095022176640187],[1,0,90.00000000000034,87.80101888917287]],[4,"break_wall.009",2,[[3,1,-163,[94],[1],95],[6,4,-164],[5,-165,[1,0.005,0.005,0.005]]],[1,-0.012499326840043068,0.007452864665538073,-0.000001718401563266525]],[120,"carpet1",[[-166,-167,-168,-169,[54,"transform1",-170]],1,1,1,1,4]],[92,"Food",8,[-174,11],[[3,1,-171,[138],[58,true],139],[27,-172,[1,0,0.002,0],[1,0.00944,0.0035,0.006958]],[84,true,-173,[140],141]],[1,4.524,0.365,-3.039],[1,150,150,150]],[51,"Effects",14,[-175,-176,-177,-178,-179]],[63,"Electric_1",20,[-181,-182],[-180],[1,2.87,1.145,4.176],[3,0.7071067811865475,0,0,0.7071067811865476],[1,0.26,0.26000000000000006,0.26000000000000006],[1,89.99999999999999,0,0]],[63,"Electric_2",20,[-184,-185],[-183],[1,2.87,1.142,0.299],[3,0.7071067811865475,0,0,0.7071067811865476],[1,0.26,0.26000000000000006,0.26000000000000006],[1,89.99999999999999,0,0]],[63,"Electric_3",20,[-187,-188],[-186],[1,2.87,1.303,2.125],[3,0.7071067811865475,0,0,0.7071067811865476],[1,0.26,0.26000000000000006,0.26000000000000006],[1,89.99999999999999,0,0]],[63,"Electric_4",20,[-190,-191],[-189],[1,2.87,0.108,1.03],[3,0.7071067811865475,0,0,0.7071067811865476],[1,0.26,0.26000000000000006,0.26000000000000006],[1,89.99999999999999,0,0]],[63,"Electric_5",20,[-193,-194],[-192],[1,2.87,0.076,3.149],[3,0.7071067811865475,0,0,0.7071067811865476],[1,0.26,0.26000000000000006,0.26000000000000006],[1,89.99999999999999,0,0]],[122,"JoyStick",33554432,4,[[[32,-195,[5,80,80]],[106,0,-196,267],-197,[98,0,-198]],4,4,1,4],[1,0,-130,0]],[4,"break_wall",1,[[3,1,-199,[28],[1],29],[5,-200,[1,0.005,0.005,0.005]],[6,4,-201]],[1,-0.017498958855867386,0.012452497147023678,-0.0000017197428405779647]],[4,"break_wall.001",1,[[3,1,-202,[30],[1],31],[5,-203,[1,0.005,0.005,0.005]],[6,4,-204]],[1,-0.012499326840043068,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.002",1,[[3,1,-205,[32],[1],33],[5,-206,[1,0.005,0.005,0.005]],[6,4,-207]],[1,-0.007499693427234888,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.004",1,[[3,1,-208,[36],[1],37],[5,-209,[1,0.005,0.005,0.005]],[6,4,-210]],[1,0.0024995713029056787,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.005",1,[[3,1,-211,[38],[1],39],[5,-212,[1,0.005,0.005,0.005]],[6,4,-213]],[1,0.007499203085899353,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.006",1,[[3,1,-214,[40],[1],41],[5,-215,[1,0.005,0.005,0.005]],[6,4,-216]],[1,0.012498835101723671,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.007",1,[[3,1,-217,[42],[1],43],[5,-218,[1,0.005,0.005,0.005]],[6,4,-219]],[1,0.017498468980193138,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.008",1,[[3,1,-220,[44],[1],45],[5,-221,[1,0.005,0.005,0.005]],[6,4,-222]],[1,-0.017498958855867386,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.009",1,[[3,1,-223,[46],[1],47],[5,-224,[1,0.005,0.005,0.005]],[6,4,-225]],[1,-0.012499326840043068,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.010",1,[[3,1,-226,[48],[1],49],[5,-227,[1,0.005,0.005,0.005]],[6,4,-228]],[1,-0.007499693427234888,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.011",1,[[3,1,-229,[50],[1],51],[5,-230,[1,0.005,0.005,0.005]],[6,4,-231]],[1,-0.0025000611785799265,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.012",1,[[3,1,-232,[52],[1],53],[5,-233,[1,0.005,0.005,0.005]],[6,4,-234]],[1,0.0024995713029056787,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.013",1,[[3,1,-235,[54],[1],55],[5,-236,[1,0.005,0.005,0.005]],[6,4,-237]],[1,0.007499203085899353,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.014",1,[[3,1,-238,[56],[1],57],[5,-239,[1,0.005,0.005,0.005]],[6,4,-240]],[1,0.012498835101723671,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.015",1,[[3,1,-241,[58],[1],59],[5,-242,[1,0.005,0.005,0.005]],[6,4,-243]],[1,0.017498468980193138,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.016",1,[[3,1,-244,[60],[1],61],[5,-245,[1,0.005,0.005,0.005]],[6,4,-246]],[1,-0.017498958855867386,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.017",1,[[3,1,-247,[62],[1],63],[5,-248,[1,0.005,0.005,0.005]],[6,4,-249]],[1,-0.012499326840043068,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.018",1,[[3,1,-250,[64],[1],65],[5,-251,[1,0.005,0.005,0.005]],[6,4,-252]],[1,-0.007499693427234888,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.019",1,[[3,1,-253,[66],[1],67],[5,-254,[1,0.005,0.005,0.005]],[6,4,-255]],[1,-0.0025000611785799265,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.020",1,[[3,1,-256,[68],[1],69],[5,-257,[1,0.005,0.005,0.005]],[6,4,-258]],[1,0.0024995713029056787,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.021",1,[[3,1,-259,[70],[1],71],[5,-260,[1,0.005,0.005,0.005]],[6,4,-261]],[1,0.007499203085899353,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.022",1,[[3,1,-262,[72],[1],73],[5,-263,[1,0.005,0.005,0.005]],[6,4,-264]],[1,0.012498835101723671,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.023",1,[[3,1,-265,[74],[1],75],[5,-266,[1,0.005,0.005,0.005]],[6,4,-267]],[1,0.017498468980193138,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall",2,[[3,1,-268,[76],[1],77],[6,4,-269],[5,-270,[1,0.005,0.005,0.005]]],[1,-0.017498958855867386,0.012452497147023678,-0.0000017197428405779647]],[4,"break_wall.001",2,[[3,1,-271,[78],[1],79],[6,4,-272],[5,-273,[1,0.005,0.005,0.005]]],[1,-0.012499326840043068,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.002",2,[[3,1,-274,[80],[1],81],[6,4,-275],[5,-276,[1,0.005,0.005,0.005]]],[1,-0.007499693427234888,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.003",2,[[3,1,-277,[82],[1],83],[6,4,-278],[5,-279,[1,0.005,0.005,0.005]]],[1,-0.0025000611785799265,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.004",2,[[3,1,-280,[84],[1],85],[6,4,-281],[5,-282,[1,0.005,0.005,0.005]]],[1,0.0024995713029056787,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.005",2,[[3,1,-283,[86],[1],87],[6,4,-284],[5,-285,[1,0.005,0.005,0.005]]],[1,0.007499203085899353,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.006",2,[[3,1,-286,[88],[1],89],[6,4,-287],[5,-288,[1,0.005,0.005,0.005]]],[1,0.012498835101723671,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.007",2,[[3,1,-289,[90],[1],91],[6,4,-290],[5,-291,[1,0.005,0.005,0.005]]],[1,0.017498468980193138,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.008",2,[[3,1,-292,[92],[1],93],[6,4,-293],[5,-294,[1,0.005,0.005,0.005]]],[1,-0.017498958855867386,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.010",2,[[3,1,-295,[96],[1],97],[6,4,-296],[5,-297,[1,0.005,0.005,0.005]]],[1,-0.007499693427234888,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.011",2,[[3,1,-298,[98],[1],99],[6,4,-299],[5,-300,[1,0.005,0.005,0.005]]],[1,-0.0025000611785799265,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.012",2,[[3,1,-301,[100],[1],101],[6,4,-302],[5,-303,[1,0.005,0.005,0.005]]],[1,0.0024995713029056787,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.013",2,[[3,1,-304,[102],[1],103],[6,4,-305],[5,-306,[1,0.005,0.005,0.005]]],[1,0.007499203085899353,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.014",2,[[3,1,-307,[104],[1],105],[6,4,-308],[5,-309,[1,0.005,0.005,0.005]]],[1,0.012498835101723671,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.015",2,[[3,1,-310,[106],[1],107],[6,4,-311],[5,-312,[1,0.005,0.005,0.005]]],[1,0.017498468980193138,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.016",2,[[3,1,-313,[108],[1],109],[6,4,-314],[5,-315,[1,0.005,0.005,0.005]]],[1,-0.017498958855867386,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.017",2,[[3,1,-316,[110],[1],111],[6,4,-317],[5,-318,[1,0.005,0.005,0.005]]],[1,-0.012499326840043068,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.018",2,[[3,1,-319,[112],[1],113],[6,4,-320],[5,-321,[1,0.005,0.005,0.005]]],[1,-0.007499693427234888,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.019",2,[[3,1,-322,[114],[1],115],[6,4,-323],[5,-324,[1,0.005,0.005,0.005]]],[1,-0.0025000611785799265,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.020",2,[[3,1,-325,[116],[1],117],[6,4,-326],[5,-327,[1,0.005,0.005,0.005]]],[1,0.0024995713029056787,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.021",2,[[3,1,-328,[118],[1],119],[6,4,-329],[5,-330,[1,0.005,0.005,0.005]]],[1,0.007499203085899353,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.022",2,[[3,1,-331,[120],[1],121],[6,4,-332],[5,-333,[1,0.005,0.005,0.005]]],[1,0.012498835101723671,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.023",2,[[3,1,-334,[122],[1],123],[6,4,-335],[5,-336,[1,0.005,0.005,0.005]]],[1,0.017498468980193138,0.0024532328825443983,-0.000001718401563266525]],[36,"Laser_Button",[-337,-338,-339,-340]],[36,"Laser_Button",[-341,-342,-343,-344]],[7,"Root_M",7,[-345,-346,-347,-348],[1,1.0018953194960331e-25,0.01481025293469429,-0.0051376777701079845],[3,0.6968476547856595,-0.12001394093906889,0.6968476547856595,-0.12001394093906889],[1,180,-90,-19.543700609739705]],[18,"Cat China",7,[[137,-349]]],[91,"Navigate",33554432,4,[-351,-352],[[89,-350]]],[100,"Point",33554432,4,[[32,-353,[5,40,40]],[79,0,-354,[4,4279177021],252],[98,0,-355]],[1,0,-130,0]],[35,"tryBtn",33554432,10,[[32,-356,[5,373,167]],[71,-357,[4,16777215],255],[154,3,1.1,-358,256]],[1,0,-162.034,0],[1,0.4,0.4,1]],[51,"lv2_soldier",5,[-359,-360,-361,-362]],[110,"FakeCat",false,[-363,-364],[1,-0.418,0.296,0.191],[3,0.4999999999999999,0.5,0.5,0.5000000000000001],[1,2.7,2.7,2.7],[1,0,90,90]],[7,"Root_M",81,[-365,-366,-367,-368],[1,1.0018953194960331e-25,0.01481025293469429,-0.0051376777701079845],[3,0.6968476547856595,-0.12001394093906889,0.6968476547856595,-0.12001394093906889],[1,180,-90,-19.543700609739705]],[41,"Vision",5,[[87,"Quad<ModelComponent>",-369,[288],[1],289],[138,-370,[1,0,0,0.3]],[140,false,32,10000,-371,[1,0,1,0]]],[1,0,0.031,0.344],[3,-0.7071067811865475,0,0,0.7071067811865476],[1,0.5,0.6,0.833333],[1,-90,0,0]],[35,"Cube1",8388608,6,[[34,"Cube<ModelComponent>",1,-372,[2],[1],3],[45,-373],[33,2,2,-374]],[1,0,0.5,-5],[1,20,2,0.25]],[35,"Cube2",8388608,6,[[34,"Cube<ModelComponent>",1,-375,[4],[1],5],[5,-376,[1,1,1.1,2]],[33,2,2,-377]],[1,-2,0.5,4.873],[1,16,2,0.25]],[35,"Cube3",8388608,6,[[87,"Cube<ModelComponent>",-378,[6],[1],7],[45,-379],[33,2,2,-380]],[1,7.123,0.5,4.873],[1,5,2,0.25]],[101,"Cube4",8388608,6,[[34,"Cube<ModelComponent>",1,-381,[8],[1],9],[5,-382,[1,1,1,2]],[33,2,2,-383]],[1,-9.876,0.5,-0.032],[3,0,0.7071067811865475,0,0.7071067811865476],[1,10,2,0.25],[1,0,89.99999999999999,0]],[81,"Cube5",6,[[34,"Cube<ModelComponent>",1,-384,[10],[1],11],[5,-385,[1,1,1,1.5]],[33,2,2,-386]],[1,-7.329,0.5,-0.801],[1,5,2,0.35]],[41,"Cube8",6,[[34,"Cube<ModelComponent>",1,-387,[12],[1],13],[5,-388,[1,1,1,1.5]],[33,2,2,-389]],[1,-5,0.5,-1.969],[3,0,0.7071067811865475,0,0.7071067811865477],[1,6,2,0.35],[1,0,89.99999999999999,0]],[41,"Cube9",6,[[34,"Cube<ModelComponent>",1,-390,[14],[1],15],[45,-391],[33,2,2,-392]],[1,-5,0.5,4.06],[3,0,0.7071067811865475,0,0.7071067811865477],[1,1.8,2,0.35],[1,0,89.99999999999999,0]],[81,"Cube10",6,[[34,"Cube<ModelComponent>",1,-393,[16],[1],17],[45,-394],[33,2,2,-395]],[1,2.428,0.5,-0.846],[1,4.8,2,0.35]],[41,"Cube11",6,[[34,"Cube<ModelComponent>",1,-396,[18],[1],19],[45,-397],[33,2,2,-398]],[1,8.367,0.5,-0.846],[3,0,1,0,6.123233995736766e-17],[1,2.8,2,0.35],[1,0,180,0]],[41,"Cube19",6,[[34,"Cube<ModelComponent>",1,-399,[20],[1],21],[45,-400],[33,2,2,-401]],[1,9.861,0.5,-2.231],[3,0,0.7071067811865475,0,0.7071067811865477],[1,5.5,2,0.25],[1,0,89.99999999999999,0]],[41,"Cube20",6,[[34,"Cube<ModelComponent>",1,-402,[22],[1],23],[45,-403],[33,2,2,-404]],[1,1.246,0.5,4.095],[3,-6.5420519111824014e-18,0.7071067811865475,1.4719616800160387e-17,0.7071067811865476],[1,1.8,2,0.35],[1,-1.7228004524594049e-15,89.99999999999999,6.626155586382319e-16]],[41,"Cube21",6,[[34,"Cube<ModelComponent>",1,-405,[24],[1],25],[45,-406],[33,2,2,-407]],[1,1.246,0.5,0.066],[3,-6.5420519111824014e-18,0.7071067811865475,1.4719616800160387e-17,0.7071067811865476],[1,1.8,2,0.35],[1,-1.7228004524594049e-15,89.99999999999999,6.626155586382319e-16]],[41,"Cube12",6,[[34,"Cube<ModelComponent>",1,-408,[26],[1],27],[45,-409],[33,2,2,-410]],[1,9.74,0.5,4.354],[3,-1.0630834355671389e-17,0.7071067811865475,-1.0630834355671397e-17,0.7071067811865476],[1,1.3,2,0.25],[1,4.033991139266958e-31,90,-1.7228004524594049e-15]],[4,"break_wall.003",1,[[3,1,-411,[34],[1],35],[5,-412,[1,0.005,0.005,0.005]],[6,4,-413]],[1,-0.0025000611785799265,0.012452497147023678,-0.000001718401563266525]],[115,"MocQuanAo",8,[-416],[[78,-414,[126],[1],127],[27,-415,[1,0,0.009,0],[1,0.006667,0.020667,0.006667]]],[1,8.969,0,-4.229],[3,0,-0.6205731361358193,0,0.7841485718322477],[1,150,150,150],[1,0,-76.716,0]],[92,"Tham",8,[18,-418],[[152,-417,[130],[1]]],[1,-7.62,0,2.195],[1,80.00000000000001,80,80.00000000000001]],[56,"Door1_1",[[3,1,-419,[146],[1],147],[52,8,0.0001,-420,[1,0,0,0],[1,0,1,0]],[27,-421,[1,-0.004,0,0],[1,0.006,0.015,0.002]]],[1,0.007821347564458847,0.00755288265645504,1.175609470882577e-10]],[56,"Door1_2",[[3,1,-422,[148],[1],149],[52,8,0.0001,-423,[1,0,0,0],[1,0,1,0]],[27,-424,[1,0.004,0,0],[1,0.006,0.015,0.002]]],[1,-0.007821347564458847,0.00755288265645504,1.175609470882577e-10]],[56,"Door1",[[3,1,-425,[150],[1],151],[52,8,0.0001,-426,[1,0,0,0],[1,0,1,0]],[27,-427,[1,-0.004,0,0],[1,0.006,0.015,0.003]]],[1,0.007821347564458847,0.00755288265645504,1.175609470882577e-10]],[56,"Door2",[[3,1,-428,[152],[1],153],[52,8,0.0001,-429,[1,0,0,0],[1,0,1,0]],[27,-430,[1,0.004,0,0],[1,0.006,0.015,0.003]]],[1,-0.007821347564458847,0.00755288265645504,1.175609470882577e-10]],[56,"Door1",[[3,1,-431,[154],[1],155],[52,8,0.1,-432,[1,0,0,0],[1,0,1,0]],[27,-433,[1,-0.004,0,0],[1,0.007,0.014,0.002]]],[1,0.007821347564458847,0.00755288265645504,1.175609470882577e-10]],[56,"Door2",[[3,1,-434,[156],[1],157],[27,-435,[1,0.004,0,0],[1,0.007,0.014,0.002]],[52,8,0.1,-436,[1,0,0,0],[1,0,1,0]]],[1,-0.007821347564458847,0.00755288265645504,1.175609470882577e-10]],[18,"WallLaserBtn",74,[[3,1,-437,[172],[1],173],[27,-438,[1,-1.1874362826347351e-8,0.0005,4.889443516731262e-9],[1,0.002,0.1,0.002]],[33,2,2,-439]]],[51,"Lasers",14,[-440,-441,-442]],[36,"Electro",[-443,-444,-445]],[81,"Electro_vfx_mesh",108,[[3,1,-446,[180],[1],181],[5,-447,[1,0.0019843416521325707,0.010201558005064726,0.03618932329118252]]],[1,2.410281751963339e-7,0.007962931878864765,1.182999476156965e-9],[1,1.2,1.2,1]],[36,"laser",[-448,-449,-450]],[4,"laser_vfx_mesh",110,[[3,1,-451,[184],[1],185],[5,-452,[1,0.0016475273296236992,0.012324807699769735,0.02926943451166153]]],[1,-2.109229413349567e-8,0.007881137542426586,2.020315292838859e-7]],[36,"laser",[-453,-454,-455]],[4,"laser_vfx_mesh",112,[[3,1,-456,[190],[1],191],[5,-457,[1,0.0016475273296236992,0.012324807699769735,0.02926943451166153]]],[1,-2.109229413349567e-8,0.007881137542426586,2.020315292838859e-7]],[80,"Chest_M",[-458,-459,-460],[1,0.005447485018521547,-1.554312241092664e-17,-5.346294532827751e-18],[3,-9.193751724705897e-17,7.319178504059276e-18,-0.017864119002931025,0.9998404238938577],[1,-1.0525317154700937e-14,6.507944086134008e-16,-2.0471861423310167]],[155,12,15,7,4,77,26,10,79],[35,"Gradient",33554432,4,[[32,-461,[5,16,478]],[53,-462,244]],[1,0,240,0],[1,50,0.2,1]],[35,"text",33554432,4,[[32,-463,[5,438,56]],[53,-464,245]],[1,0,-224.365,0],[1,0.3,0.3,0.3]],[35,"title",33554432,4,[[32,-465,[5,556,220]],[53,-466,246]],[1,-40,206.99999999999997,0],[1,0.2,0.2,0.4]],[35,"icon",33554432,4,[[32,-467,[5,198,198]],[53,-468,247]],[1,56,206.99999999999997,0],[1,0.25,0.25,0.6]],[35,"hand",33554432,77,[[32,-469,[5,108,134]],[53,-470,249],[84,true,-471,[250],251]],[1,-53.722999999999985,-197.265,0],[1,0.24999999999999997,0.24999999999999997,0.24999999999999997]],[88,"LoadMap",33554432,10,[[32,-472,[5,2000,2000]],[79,0,-473,[4,0],253]]],[35,"Download",33554432,10,[[32,-474,[5,373,167]],[71,-475,[4,16777215],254]],[1,0,-163,0],[1,0.4,0.4,1]],[35,"hand",33554432,10,[[104,-476,[5,205,168],[0,0.5,0]],[71,-477,[4,16777215],259],[84,true,-478,[260],261]],[1,39.009000000000015,-238.782,0],[1,0.35,0.35,1]],[88,"fakeBG",33554432,4,[[32,-479,[5,5000,5000]],[79,0,-480,[4,16777215],264]]],[173,"Clock",false,33554432,4,[-482,-483],[[89,-481]],[1,0,200,0],[1,0.6,0.6,1]],[80,"Chest_M",[-484,-485,-486],[1,0.0533306784927845,2.381428366645137e-16,3.4815426486148546e-17],[3,-2.794241066213517e-18,-1.276094809930094e-16,0.03289460314046024,0.9994588261075249],[1,1.6134277965385988e-16,-1.463619740813736e-14,3.7701239795085772]],[80,"Chest_M",[-487,-488,-489],[1,0.005447485018521547,-1.554312241092664e-17,-5.346294532827751e-18],[3,-9.193751724705897e-17,7.319178504059276e-18,-0.017864119002931025,0.9998404238938577],[1,-1.0525317154700937e-14,6.507944086134008e-16,-2.0471861423310167]],[75,"Camera",12,[[156,"Camera<CameraComponent>",2,1822425087,-490,[4,4285583532]]],[1,-13,24,0],[3,-0.3588838181618332,-0.6092638222162746,-0.358883818161833,0.6092638222162747],[1,-61,-90,6.3611093629270335e-15]],[116,"Ground",14,[[87,"Plane<ModelComponent>",-491,[0],[153,true],1],[158,-492]],[1,2,1,1]],[51,"BreakWalls",14,[-493,-494]],[50,"Doors_1",8,[-495],[1,-4.943,0,2.084],[3,0,0.7071067811865475,0,0.7071067811865476],[1,140,140,140],[1,0,89.99999999999999,0]],[51,"Doors",131,[100,101]],[36,"Doors",[102,103]],[36,"Doors",[104,105]],[36,"exit_door",[-496,-497]],[4,"ExitDoor",135,[[3,1,-498,[158],[1],159],[27,-499,[1,0.008676467288751155,-0.00008720159530639648,-0.0007142104441300035],[1,0.02070255985017866,0.014756504446268082,0.004769404651597142]]],[1,-0.019050396978855133,0.0074655115604400635,-0.00011989556514890864]],[4,"ExitDoor",135,[[3,1,-500,[160],[1],161],[27,-501,[1,-0.008676467288751155,-0.00008720159530639648,-0.0007142079994082451],[1,0.02070255985017866,0.014756504446268082,0.0047693997621536255]]],[1,0.019050396978855133,0.0074655115604400635,-0.00011989721679128706]],[18,"LaserButtonGreen",73,[[3,1,-502,[162],[1],163]]],[18,"LaserBtn",73,[[3,1,-503,[164],[1],165],[27,-504,[1,-1.1874362826347351e-8,0.005,4.889443516731262e-9],[1,0.002,0.05,0.002]]]],[93,"LaserButtonRed",false,73,[[3,1,-505,[166],[1],167]]],[93,"WallLaserButtonGreen",false,74,[[3,1,-506,[170],[1],171]]],[18,"WallLaserButtonRed",74,[[3,1,-507,[174],[1],175]]],[4,"laser_base2",112,[[3,1,-508,[192],[1],193],[27,-509,[1,-0.0022566841216757894,0.007889981320338947,-0.0005208068469073623],[1,0.009780378779396415,0.015779962885702645,0.002453161228913814]]],[1,-2.078171768005177e-8,0.0000016899934962566476,0.014305144548416138]],[4,"laser_base1",112,[[3,1,-510,[194],[1],195],[27,-511,[1,-0.0022566841216757894,0.007889981320338947,0.0005208076327107847],[1,0.009780378779396415,0.015779962885702645,0.0024531626841053367]]],[1,-2.2032313751196853e-8,0.0000016899934962566476,-0.014305144548416138]],[65,0.3,false,21,[200],[9],[12,3,0.6,0.9],[0],[0],[12,3,2,4],[0],[0],[12,3,6.283185307179586,6.283185307179586],[0],[12,3,0.15,0.3],[0],[2,20],[0],[[21,[2,9]]],[22,true,[20,1,[28,[[60,[4,33554431]],[13,0.3727678571428572,[4,33539082]]]]]],[66,true,3,0.01,0.5,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[61,true,0.5,[0],[0],[0],[2,0.2]],[25,[0],[0],[0]],[44,true,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-512],[68,1,201]],[65,0.3,false,22,[206],[9],[12,3,0.6,0.9],[0],[0],[12,3,2,4],[0],[0],[69,3,6.283185307179586],[0],[12,3,0.15,0.3],[0],[2,20],[0],[[21,[2,9]]],[22,true,[20,1,[28,[[60,[4,33554431]],[13,0.3727678571428572,[4,33539082]]]]]],[66,true,3,0.01,0.5,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[61,true,0.5,[0],[0],[0],[2,0.2]],[25,[0],[0],[0]],[44,true,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-513],[68,1,207]],[65,0.6,false,23,[212],[9],[12,3,0.6,0.9],[0],[0],[12,3,2,4],[0],[0],[69,3,6.283185307179586],[0],[12,3,0.15,0.3],[0],[2,20],[0],[[21,[2,9]]],[22,true,[20,1,[28,[[60,[4,33554431]],[13,0.3727678571428572,[4,33539082]]]]]],[66,true,3,0.01,0.5,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[61,true,0.5,[0],[0],[0],[2,0.2]],[25,[0],[0],[0]],[44,true,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-514],[68,1,213]],[65,0.8,false,24,[218],[9],[12,3,0.6,0.9],[0],[0],[12,3,2,4],[0],[0],[69,3,6.283185307179586],[0],[12,3,0.15,0.3],[0],[2,20],[0],[[21,[2,9]]],[22,true,[20,1,[28,[[60,[4,33554431]],[13,0.3727678571428572,[4,33539082]]]]]],[66,true,3,0.01,0.5,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[61,true,0.5,[0],[0],[0],[2,0.2]],[25,[0],[0],[0]],[44,true,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-515],[68,1,219]],[65,0.8,false,25,[224],[9],[12,3,0.6,0.9],[0],[0],[12,3,2,4],[0],[0],[69,3,6.283185307179586],[0],[12,3,0.15,0.3],[0],[2,20],[0],[[21,[2,9]]],[22,true,[20,1,[28,[[60,[4,33554431]],[13,0.3727678571428572,[4,33539082]]]]]],[66,true,3,0.01,0.5,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[61,true,0.5,[0],[0],[0],[2,0.2]],[25,[0],[0],[0]],[44,true,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-516],[68,1,225]],[51,"Characters",12,[7,5]],[95,"Head_M",[[[14,"HeadEnd_M",-517,[1,0.015095275826752186,-2.2204459996194763e-18,1.1147259642693237e-17]],-518],4,1],[1,0.005839296150952578,-2.2204459996194763e-18,7.335141521958022e-11],[3,-3.2970677530887142e-24,2.9610711926934064e-25,-0.05829603108103105,0.9982993402583213],[1,-3.7776313382545368e-22,1.1929573189923404e-23,-6.684022599098756]],[75,"Tail5_M Socket",7,[[49,1,-519,[235],[58,true],76,236,237]],[1,6.341056700567878e-12,0.028416548234473003,-0.015795044030911892],[3,-0.4938677723887209,-0.5060579260202104,0.49386777290395006,0.5060579233593901],[1,0.000007402513691849027,-90.00000752545665,88.60307687403271]],[75,"HeadEnd_M Socket",7,[[49,1,-520,[238],[58,true],76,239,240]],[1,1.023330506786563e-10,0.0420388874710939,0.011561717930852245],[3,0.5100338561202763,0.4897606207231051,0.5100338561202766,0.48976062072310483],[1,-179.99999999999915,-90.00000000000078,87.67669918311346]],[160,26,15,12,7,78,124],[35,"8",33554432,77,[[32,-521,[5,416,201]],[53,-522,248]],[1,0,-180.053,0],[1,0.3,0.3,1]],[117,"icon",33554432,10,[[32,-523,[5,198,198]],[71,-524,[4,16777215],257]],[1,0.6,0.6,1]],[35,"title_game",33554432,10,[[32,-525,[5,556,220]],[71,-526,[4,16777215],258]],[1,0,157.99999999999997,0],[1,0.5,0.5,1]],[88,"time_tab1",33554432,125,[[32,-527,[5,479,92]],[53,-528,265]]],[100,"time_tab2",33554432,125,[[104,-529,[5,376,34],[0,0,0.5]],[53,-530,266]],[1,-150,0,0]],[94,"Spine1_M",16,[[-531,[62,"Belly1_M",-532,[1,0.0077425935305655,0.07469058781862259,5.683020321453694e-18],[3,-0.49471446425189547,-0.5052302434137925,-0.49471446425189547,0.5052302434137925],[1,-88.7949582615246,-90,0]]],1,4],[1,0.04725191742181778,-1.3322675997716858e-17,-2.7206586596425432e-18],[3,3.2975108234797884e-18,-1.1535630463133295e-16,0.008673650158111692,0.9999623831889553],[1,4.925825648115789e-16,-1.322362871078532e-14,0.9939395570423156]],[7,"Wrist_R Socket",5,[-533],[1,-0.23649517833507505,0.2995391313682958,0.007875874325497878],[3,0.007358544050005315,0.6876916440780526,0.7259240642975096,-0.007765781897171327],[1,-93.09776297189606,-178.77581523134523,-0.06611461176780299]],[118,"police_cathernet",161,[81],[[3,1,-534,[286],[1],287]],[1,0.308,-0.298,0]],[95,"Head_M",[[[14,"HeadEnd_M",-535,[1,0.015095275826752186,-2.2204459996194763e-18,1.1147259642693237e-17]],-536],4,1],[1,0.005839296150952578,-2.2204459996194763e-18,7.335141521958022e-11],[3,-3.2970677530887142e-24,2.9610711926934064e-25,-0.05829603108103105,0.9982993402583213],[1,-3.7776313382545368e-22,1.1929573189923404e-23,-6.684022599098756]],[75,"Directional Light",12,[[161,90000,2.34375,-537,[162]]],[1,-12.927,23.868,0.609],[3,-0.46772509094040937,-0.4606509224664642,-0.3889418124971846,0.6463421953013637],[1,-74.895,-74.112,-4.121]],[64,"breakwall_1",130,[1],[1,-2.437,0.04,-0.891],[1,120,120,120]],[50,"breakwall_2",130,[2],[1,1.256,0.04,-2.962],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,90,110,110],[1,0,-89.99999999999999,0]],[18,"coat",98,[[3,1,-538,[124],[1],125]]],[76,"polySurface5",18,[[54,"transform2",-539]]],[76,"polySurface6",18,[[54,"transform5",-540]]],[76,"polySurface7",18,[[54,"transform3",-541]]],[76,"polySurface9",18,[[54,"transform4",-542]]],[18,"polySurface6",99,[[78,-543,[128],[1],129]]],[18,"cat_food",19,[[3,1,-544,[131],[58,true],132]]],[8,["f2sDa1qWtF56f7v5izDlLP"]],[50,"tree_A_1",8,[-545],[1,4.066,0,7.047],[3,0,0.7336231290607853,0,0.6795565498963736],[1,75,75,75],[1,0,94.38200000000002,0]],[18,"Tree_A",175,[[78,-546,[142],[1],143]]],[50,"tree_A_2",8,[-547],[1,0.984,0,-6.896],[3,0,0.8902803762621423,0,0.45541283649293224],[1,50.00000000000001,50,50.00000000000001],[1,0,125.81700000000001,0]],[18,"Tree_A",177,[[78,-548,[144],[1],145]]],[50,"Doors_2",8,[133],[1,1.192,0.142,2.084],[3,-3.407318703740833e-18,0.7071067811865475,3.40731870374083e-18,0.7071067811865476],[1,140.00000000000003,140,140.00000000000003],[1,-5.521796321985272e-16,89.99999999999999,-2.2069531490250793e-31]],[64,"Doors_3",8,[134],[1,5.898,0.003,-0.858],[1,140,140,140]],[50,"Doors_4",8,[135],[1,9.806,0.542,2.119],[3,0,0.7071067811865475,0,0.7071067811865476],[1,80,90,90],[1,0,90,0]],[64,"laser_button_1",8,[73],[1,-2,0,-3],[1,100,100,100]],[41,"icon",73,[[34,"Quad<ModelComponent>",1,-549,[168],[1],169]],[1,-0.001,0.005,0],[3,-0.5,-0.5,-0.4999999999999999,0.5000000000000001],[1,0.007,0.007,0.007],[1,-90,-90,0]],[64,"laser_button_2",8,[74],[1,-7.7,0,-3],[1,100,100,100]],[41,"icon",74,[[34,"Quad<ModelComponent>",1,-550,[176],[1],177]],[1,0,0.003,0],[3,-0.5,-0.5,-0.4999999999999999,0.5000000000000001],[1,0.006,0.006,0.006],[1,-90,-90,0]],[50,"Electro",107,[108],[1,5.5,0,0.227],[3,0,0.7071067811865475,0,0.7071067811865476],[1,150,150,190],[1,0,90,0]],[4,"Electro_wall1",108,[[3,1,-551,[178],[1],179]],[1,2.452812566389184e-7,0.00001882825199572835,0.021018020808696747]],[4,"Electro_wall2",108,[[3,1,-552,[182],[1],183]],[1,2.452812566389184e-7,0.00001882825199572835,-0.021018020808696747]],[111,"laser_wall_1",false,107,[110],[1,5.685,0,2.944],[3,0,1,0,-6.123233995736766e-17],[1,120,120,120],[1,0,-180,0]],[4,"laser_base2",110,[[3,1,-553,[186],[1],187]],[1,-2.078171768005177e-8,0.0000016899934962566476,0.014305144548416138]],[4,"laser_base1",110,[[3,1,-554,[188],[1],189]],[1,-2.2032313751196853e-8,0.0000016899934962566476,-0.014305144548416138]],[111,"laser_wall_2",false,107,[112],[1,7.933,0,1.394],[3,0,0.7071067811865476,0,0.7071067811865475],[1,120,120,120],[1,0,90.00000000000003,0]],[40,"Nova",21,[-555],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[42,1,false,193,[196],[9],[12,3,1,2.5],[0],[0],[0],[0],[0],[0],[0],[2,0.25],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[28,[[39],[13,0.5,[4,4294943551]]]]]],[43,3,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[44,true,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-556],[38,197]],[40,"Glow",21,[-557],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[42,1,false,195,[198],[9],[2,5],[0],[0],[0],[0],[0],[0],[0],[2,0.5],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[28,[[39],[13,0.5,[4,4294943551]]]]]],[43,3,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[67,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-558],[38,199]],[40,"Nova",22,[-559],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[42,1,false,197,[202],[9],[12,3,1,2.5],[0],[0],[0],[0],[0],[0],[0],[2,0.25],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[28,[[39],[13,0.5,[4,4294943551]]]]]],[43,3,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[44,true,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-560],[38,203]],[40,"Glow",22,[-561],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[42,1,false,199,[204],[9],[2,5],[0],[0],[0],[0],[0],[0],[0],[2,0.5],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[28,[[39],[13,0.5,[4,4294943551]]]]]],[43,3,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[67,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-562],[38,205]],[40,"Nova",23,[-563],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[42,1,false,201,[208],[9],[12,3,1,2.5],[0],[0],[0],[0],[0],[0],[0],[2,0.25],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[28,[[39],[13,0.5,[4,4294943551]]]]]],[43,3,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[44,true,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-564],[38,209]],[40,"Glow",23,[-565],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[42,1,false,203,[210],[9],[2,5],[0],[0],[0],[0],[0],[0],[0],[2,0.5],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[28,[[39],[13,0.5,[4,4294943551]]]]]],[43,3,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[67,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-566],[38,211]],[40,"Nova",24,[-567],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[42,1,false,205,[214],[9],[12,3,1,2.5],[0],[0],[0],[0],[0],[0],[0],[2,0.25],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[28,[[39],[13,0.5,[4,4294943551]]]]]],[43,3,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[44,true,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-568],[38,215]],[40,"Glow",24,[-569],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[42,1,false,207,[216],[9],[2,5],[0],[0],[0],[0],[0],[0],[0],[2,0.5],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[28,[[39],[13,0.5,[4,4294943551]]]]]],[43,3,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[67,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-570],[38,217]],[40,"Nova",25,[-571],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[42,1,false,209,[220],[9],[12,3,1,2.5],[0],[0],[0],[0],[0],[0],[0],[2,0.25],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[28,[[39],[13,0.5,[4,4294943551]]]]]],[43,3,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[44,true,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-572],[38,221]],[40,"Glow",25,[-573],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[42,1,false,211,[222],[9],[2,5],[0],[0],[0],[0],[0],[0],[0],[2,0.5],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[28,[[39],[13,0.5,[4,4294943551]]]]]],[43,3,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[67,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-574],[38,223]],[7,"Tail0_M",75,[-575],[1,-0.003016774309799075,-0.0010064324596896768,4.4113056957284513e-11],[3,-0.13222044449472428,0.9912203357768733,1.899605991128237e-9,-2.5339324590359113e-10],[1,-2.1960685843697459e-7,-179.9999999999998,-15.19584442452546]],[7,"Tail1_M",213,[-576],[1,0.0032178927212953568,-1.1102229998097382e-18,-1.5827465746491744e-16],[3,7.854134306970377e-17,6.62973558865667e-17,-0.04753538670956306,0.9988695545517303],[1,9.393584386234256e-15,8.05274822932461e-15,-5.449207570713341]],[7,"Tail2_M",214,[-577],[1,0.002976355142891407,-5.551115205843844e-18,1.0832962131501755e-12],[3,-1.3949894977543174e-17,-3.883391342022682e-17,-0.11471089869868772,0.993398917716211],[1,-2.155174162256571e-15,-4.728473690825402e-15,-13.173900830243293]],[7,"Tail3_M",215,[-578],[1,0.003203141037374735,4.440891999238953e-18,3.920579572797012e-12],[3,-9.969521051823741e-17,-9.806948956650378e-17,-0.1655651210611257,0.9861988596059187],[1,-1.3888595449279292e-14,-1.3726848857505547e-14,-19.060130128725042]],[7,"Tail4_M",216,[-579],[1,0.0028079531621187925,0,6.5790389629227786e-12],[3,-8.251598561738025e-17,-1.135794569833411e-16,-0.06482256304208014,0.9978968059477171],[1,-1.0366549825034899e-14,-1.3716080958521048e-14,-7.433330535637716]],[19,"Tail5_M",217,[[14,"Tail6_M",-580,[1,0.0030258502811193466,8.881783998477905e-18,9.688655260020607e-12]]],[1,0.002689178567379713,4.440891999238953e-18,7.303118179646795e-12],[3,9.537444787153138e-17,-2.118270460406824e-16,-0.10054238934768282,0.9949327755905215],[1,8.60721837145069e-15,-2.3527419865239222e-14,-11.54080902638327]],[7,"Hip_R",75,[-581],[1,-0.00007880734483478591,0.0005406050477176905,-0.003936111461371183],[3,0.9649268585378106,0.23634742681996387,-0.11070779936605146,0.02828134840243218],[1,173.12485222053104,14.725639548400835,26.73431895575666]],[7,"Knee_R",219,[-582],[1,0.006485617719590664,9.992007618673103e-18,9.992007618673103e-18],[3,1.0421712215713451e-17,9.1641098275595e-18,-0.7509635080199943,0.6603437056732683],[1,180,180,-82.65218201681442]],[7,"Ankle_R",220,[-583],[1,0.006850753910839558,-9.992007618673103e-18,-1.4432898790731443e-17],[3,-0.107779091379776,0.03794360473263759,0.4382270207142593,0.8915722228945604],[1,-20.825588126741046,14.81324250428513,50.646009467453176]],[19,"Toes1_R",221,[[14,"Toes2_R",-584,[1,0.0028587731067091227,-0.0018769684247672558,-2.8829633125226906e-11]]],[1,0.003821877297013998,9.992007618673103e-18,1.4055525840439564e-11],[3,7.078807208851528e-26,7.338928554393833e-26,0.7197470906365884,0.6942363614217905],[1,-180,180,87.93279256115314]],[55,"RootPart1_M",75,[-585],[1,0.0020652245730161667,2.2204459996194763e-18,-6.089342295085281e-19]],[55,"RootPart2_M",223,[-586],[1,0.0020652245730161667,2.2204459996194763e-18,-6.089341778097398e-19]],[7,"Spine2_M",224,[114],[1,0.0020652245730161667,4.440891999238953e-18,2.7589170037440396e-18],[3,2.833542290373483e-16,-5.276558712844762e-17,-0.13887424912163487,0.9903100236445666],[1,3.257203985875381e-14,-1.5379762679065733e-15,-15.965418280697603]],[7,"Neck_M",114,[-587],[1,0.002901608357205987,-0.0031024303752928972,-9.727658892874631e-18],[3,-2.4871766108048305e-24,2.1821083289339757e-24,-0.6595017750111039,0.7517030056858913],[1,-3.791516639546766e-22,0,-82.52377277072583]],[55,"NeckPart1_M",226,[151],[1,0.005839296150952578,5.551115205843844e-18,2.898164867815023e-11]],[19,"Jaw_M",151,[[14,"JawEnd_M",-588,[1,0.01144465059041977,-4.440891999238953e-18,2.616274463397792e-18]]],[1,-0.0070828660391271114,0.001565893879160285,-4.563028938995164e-18],[3,-4.0602511795263196e-25,8.309202330691217e-25,0.7944917325602083,0.6072749681103925],[1,-180,180,74.7854503251938]],[7,"Scapula_R",114,[-589],[1,0.0009082318283617496,-0.0016960602952167392,-0.0035904867108911276],[3,0.7485383193052008,0.6073311003787559,-0.20668350270817637,0.16769391388107713],[1,112.31256356364936,70.98174103154757,57.129780034201545]],[7,"Shoulder_R",229,[-590],[1,0.002976213349029422,0,-8.881783998477905e-18],[3,-0.07353511641712662,0.25579661788485253,-0.2663195499695608,0.9264095067712771],[1,0.0000012480393304219223,30.871376804796846,-32.07723760154569]],[7,"Elbow_R",230,[-591],[1,0.006145196035504341,-5.551115205843844e-18,1.0769163656501374e-16],[3,8.504070203628985e-25,6.16430870102796e-26,0.3120392175523727,0.9500692220618996],[1,1.1223607321790314e-22,-2.942762314065395e-23,36.36433252877887]],[7,"Wrist_R",231,[-592],[1,0.003922537434846163,-7.77156120546332e-18,2.0003202219620597e-11],[3,1.26163860488356e-8,3.485806502145198e-9,0.26631405719129686,0.9638863122496919],[1,0.0000014998981938610756,2.921850661819311e-14,30.890097833571968]],[19,"Fingers1_R",232,[[14,"Fingers2_R",-593,[1,0.0024803609121590853,-0.0011090633925050497,4.9960034784643064e-17]]],[1,0.0013398798182606697,1.1102229998097382e-18,2.8932013035332105e-12],[3,-1.0268690676414758e-8,-4.1971217162257e-9,0.37834661793140156,0.9256639977334487],[1,-0.0000012712012910317389,-1.2653603427533027e-14,44.46261181934115]],[7,"Scapula_L",114,[-594],[1,0.0009082318283617496,-0.0016960602952167392,0.0035904867108911276],[3,-0.6073310985082828,0.7485383169998342,0.16769391336460931,0.20668351697278872],[1,-67.68743656021654,109.01825758625266,-57.12977896045119]],[7,"Shoulder_L",234,[-595],[1,-0.002976213349029422,-2.2204459996194763e-18,-6.661337998858429e-18],[3,-0.08087501841085962,0.2535716049327198,-0.29290211802618116,0.9183512518773331],[1,-0.0000020023668605326484,30.871375957102188,-35.37948463187456]],[7,"Elbow_L",235,[-596],[1,-0.006145196035504341,2.1649348186097164e-17,2.5022001831631613e-11],[3,3.698432393575249e-24,7.844895137691728e-26,0.4660808189363135,0.8847421490014223],[1,6.556099890129191e-22,-3.352136588885891e-22,55.56038648837976]],[7,"Wrist_L",236,[-597],[1,-0.003922537434846163,1.1102230411687688e-17,-2.0801102160183937e-11],[3,-2.2213494740521317e-8,2.682952490230911e-9,-0.11990886018104767,0.9927849038185872],[1,-0.000002563978345591965,-1.238952164628575e-14,-13.773685345369223]],[19,"Fingers1_L",237,[[14,"Fingers2_L",-598,[1,-0.0024803609121590853,0.0011090633925050497,-1.7181324071802173e-11]]],[1,-0.0013398798182606697,3.3306689994292145e-18,-3.0510691195750894e-11],[3,1.202641542986473e-8,-1.7758621256120527e-8,0.5607324843663741,0.8279970295697404],[1,0.000006148774687692887,-0.0000066217698935251255,68.21293812945635]],[7,"Hip_L",75,[-599],[1,-0.00007880722841946408,0.0005406050477176905,0.003936111461371183],[3,-0.33800700071914674,0.9337119991241997,0.028422765236197228,0.11456577400194808],[1,-9.622341407618702,162.62735726022657,-38.65942560522658]],[7,"Knee_L",239,[-600],[1,-0.006485617719590664,-5.551114999048691e-19,1.1102229998097382e-18],[3,-1.7336686139568426e-19,-9.811546734126506e-18,-0.719488810323054,0.6945040329759912],[1,-179.99999999999997,-179.99999999999997,-87.97541642889963]],[7,"Ankle_L",240,[-601],[1,-0.006850753910839558,9.992007618673103e-18,7.77156120546332e-18],[3,-0.10166416476507739,0.05983485747743264,0.6161200500698334,0.7787684324208453],[1,-46.51448788453161,43.07919569002581,71.34531796373011]],[19,"Toes1_L",241,[[14,"Toes2_L",-602,[1,-0.0028587731067091227,0.0018769684247672558,2.8829636594673858e-11]]],[1,-0.003821877297013998,0,2.3568615808988724e-11],[3,-0.00020272489692942466,0.00016227147528271118,0.6862465063574965,0.727369002008413],[1,-0.5101740052366177,0.5068947396755507,86.66730611092152]],[18,"Cat_model",7,[[49,1,-603,[226,227,228,229],[58,true],7,230,231]]],[7,"Root_M Socket",7,[-604],[1,1.0018953194960331e-25,0.01481025293469429,-0.0051376777701079845],[3,-0.6968476547856596,0.12001394093906889,-0.6968476547856595,0.12001394093906896],[1,-180,-90,-19.543700609739716]],[18,"Nacklace_03",244,[[159,-605,[232],[1],76,233,234]]],[163,7,15,115,131,154],[48,"BgSound",9,[-606]],[99,true,false,247],[48,"catAngrySoound",9,[-607]],[59,false,249],[48,"electricSound",9,[-608]],[99,true,false,251],[48,"electric2Sund",9,[-609]],[59,false,253],[48,"winSound",9,[-610]],[59,false,255],[48,"loseSoound",9,[-611]],[59,false,257],[48,"eatSound",9,[-612]],[59,false,259],[48,"clockSound",9,[-613]],[59,false,261],[112,"Camera",4,[-614],[1,0,0,1000]],[157,0,3,240,2000,6,41943040,263,[4,4278190080]],[164,15],[113,"GameController","9fgkvo20FBAKynqRhhqW/W",13,[265]],[7,"Spine2_M",160,[126],[1,0.0529840886592865,1.9317880734356842e-16,7.913655945448904e-18],[3,1.59653115827679e-18,-1.1437177449015343e-16,0.006651127207577884,0.9999778810088095],[1,2.701387872169356e-16,-1.3108126613390177e-14,0.762168655473236]],[7,"Neck_M",126,[-615],[1,0.04995439574122429,4.440892164675075e-17,4.32763757305452e-17],[3,7.771092302403045e-17,3.141471072609305e-17,0.005056470487761085,0.9999872159713875],[1,8.887153843039344e-15,3.554968494150405e-15,0.5794313055199013]],[19,"Head_M",268,[[14,"HeadEnd_M",-616,[1,0.12103284150362015,-6.300515611808204e-17,-3.361059491057321e-17]]],[1,0.06877291202545166,6.883382540917734e-16,8.258370727148945e-17],[3,-1.6069880936063149e-16,-1.4475227627136765e-16,-0.02972651022747891,0.9995580696436278],[1,-1.8933135374120044e-14,-1.715778760004779e-14,-3.406909038336909]],[7,"Scapula_R",126,[-617],[1,0.019262749701738358,0.01245173066854477,-0.0370938740670681],[3,0.0013493490321890777,0.7071458057518473,-0.0014779679385766669,0.7070649222493876],[1,0.22909391510412205,90.00657468872008,-0.01040866958080289]],[7,"Shoulder_R",270,[-618],[1,0.02444273978471756,-7.327472253693609e-17,-1.0658140798173486e-16],[3,-0.0000021503426025227283,-0.00005831555473670341,-0.009419804220521624,0.9999556309572536],[1,-0.00030940264875414775,-0.00668568147479377,-1.0794459992370342]],[19,"Elbow_R",271,[[14,"Wrist_R",-619,[1,0.0816095843911171,3.552713599391162e-17,-3.552713599391162e-17]]],[1,0.09338455647230148,3.996803047469241e-17,7.815970051009455e-16],[3,-4.4445069374134324e-17,-3.299727683376842e-17,0.020208222761823387,0.9997957930161583],[1,-5.019678031168802e-15,-3.6805222124929556e-15,2.315849391111249]],[7,"Scapula_L",126,[-620],[1,0.019262749701738358,0.01245173066854477,0.0370938740670681],[3,0.7071458057490803,-0.0013493440263249903,-0.7070649222466209,-0.0014779751563207923],[1,-179.7709059056131,89.99342530928352,0.010409660028795393]],[7,"Shoulder_L",273,[-621],[1,-0.02444273978471756,9.992006956928613e-17,-3.552713599391162e-17],[3,-0.0000021503426025227283,-0.00005831555473670341,-0.009419804220521624,0.9999556309572536],[1,-0.00030940264875414775,-0.00668568147479377,-1.0794459992370342]],[19,"Elbow_L",274,[[14,"Wrist_L",-622,[1,-0.0816095843911171,-1.776356799695581e-17,8.171241609471918e-16]]],[1,-0.09338455647230148,-8.881783998477905e-18,-1.0302869372059921e-15],[3,-3.7509785296623065e-17,-3.274865612050279e-17,0.020208222761823387,0.9997957930161583],[1,-4.225042019150996e-15,-3.6680880197500774e-15,2.315849391111249]],[7,"Hip_R",16,[-623],[1,-0.013682468794286251,-0.0012203477090224624,-0.05554671958088875],[3,0.16618651318955646,0.9858849743909147,-0.00017639259927130745,0.02031819356570466],[1,0.4306378076991254,177.56614860686935,19.127681958936297]],[7,"Knee_R",276,[-624],[1,0.05022026598453522,-1.332267682489747e-16,-2.5518253959563864e-13],[3,-9.518974254788701e-17,5.4738645451065224e-21,-0.3690863896759494,0.9293950919581904],[1,-1.393381721456747e-14,-5.532797704604732e-15,-43.318567206855924]],[7,"Ankle_R",277,[-625],[1,0.043153680860996246,-3.2267743164948737e-13,-1.600231042510683e-13],[3,-0.011484564534798845,0.01799553299819029,0.1906909090532255,0.9814179755710671],[1,-1.816857587635506,2.453397727152498,21.95520760854224]],[19,"Toes_R",278,[[62,"ToesEnd_R",-626,[1,0.008133307099342346,-3.604894296483155e-15,2.1022124485625682e-8],[3,1.754164031807122e-7,-0.0000012923479744120337,2.2667127506559457e-13,0.9999999999991496],[1,0.000020101239119256964,-0.0001480921691922244,-3.1808627288522512e-15]]],[1,0.02468482218682766,0.02989344485104084,7.938168455901007e-10],[3,0.002656072892099482,-0.0023199296978108444,0.6578327536948384,0.7531557816077993],[1,3.001861554994413,-2.9745621326411364,82.25971987154263]],[7,"Hip_L",16,[-627],[1,-0.013682468794286251,-0.0012203477090224624,0.05554671958088875],[3,0.9858849743909097,-0.16618651318955563,-0.020318193565704554,-0.0001763926283751373],[1,-179.56936218882086,2.433851393716727,-19.12768195886437]],[7,"Knee_L",280,[-628],[1,-0.05022026598453522,3.9867921464153966e-11,2.5518253959563864e-13],[3,-1.0161553971190601e-16,-6.77521811173757e-18,-0.3690863896759494,0.9293950919581904],[1,-1.52686202586018e-14,-6.898920371138734e-15,-43.318567206855924]],[7,"Ankle_L",281,[-629],[1,-0.043153680860996246,3.4580747987345006e-11,-7.836664802328419e-13],[3,-0.011484564567432416,0.017995533049324882,0.19069089469391517,0.981417978359782],[1,-1.816857543390386,2.4533976909996236,21.95520593294532]],[19,"Toes_L",282,[[14,"ToesEnd_L",-630,[1,-0.008133307099342346,-5.4400929265423855e-17,-2.8360424902604264e-13]]],[1,-0.02468482218682766,-0.02989344485104084,-7.796541190430162e-10],[3,0.002657055192385141,-0.002320786736754183,0.6578327506699668,0.7531557781446095],[1,3.0029692206456007,-2.975659625233852,82.25971211842969]],[18,"soldier_gun",80,[[49,1,-631,[268],[1],5,269,270]]],[18,"soldier_Jacket",80,[[49,1,-632,[271],[1],5,272,273]]],[18,"soldier_body",80,[[49,1,-633,[274],[1],5,275,276]]],[18,"soldier_hat",80,[[49,1,-634,[277],[1],5,278,279]]],[7,"Tail0_M",82,[-635],[1,-0.003016774309799075,-0.0010064324596896768,4.4113056957284513e-11],[3,-0.13222044449472428,0.9912203357768733,1.899605991128237e-9,-2.5339324590359113e-10],[1,-2.1960685843697459e-7,-179.9999999999998,-15.19584442452546]],[7,"Tail1_M",288,[-636],[1,0.0032178927212953568,-1.1102229998097382e-18,-1.5827465746491744e-16],[3,7.854134306970377e-17,6.62973558865667e-17,-0.04753538670956306,0.9988695545517303],[1,9.393584386234256e-15,8.05274822932461e-15,-5.449207570713341]],[7,"Tail2_M",289,[-637],[1,0.002976355142891407,-5.551115205843844e-18,1.0832962131501755e-12],[3,-1.3949894977543174e-17,-3.883391342022682e-17,-0.11471089869868772,0.993398917716211],[1,-2.155174162256571e-15,-4.728473690825402e-15,-13.173900830243293]],[7,"Tail3_M",290,[-638],[1,0.003203141037374735,4.440891999238953e-18,3.920579572797012e-12],[3,-9.969521051823741e-17,-9.806948956650378e-17,-0.1655651210611257,0.9861988596059187],[1,-1.3888595449279292e-14,-1.3726848857505547e-14,-19.060130128725042]],[7,"Tail4_M",291,[-639],[1,0.0028079531621187925,0,6.5790389629227786e-12],[3,-8.251598561738025e-17,-1.135794569833411e-16,-0.06482256304208014,0.9978968059477171],[1,-1.0366549825034899e-14,-1.3716080958521048e-14,-7.433330535637716]],[19,"Tail5_M",292,[[14,"Tail6_M",-640,[1,0.0030258502811193466,8.881783998477905e-18,9.688655260020607e-12]]],[1,0.002689178567379713,4.440891999238953e-18,7.303118179646795e-12],[3,9.537444787153138e-17,-2.118270460406824e-16,-0.10054238934768282,0.9949327755905215],[1,8.60721837145069e-15,-2.3527419865239222e-14,-11.54080902638327]],[7,"Hip_R",82,[-641],[1,-0.00007880734483478591,0.0005406050477176905,-0.003936111461371183],[3,0.9649268585378106,0.23634742681996387,-0.11070779936605146,0.02828134840243218],[1,173.12485222053104,14.725639548400835,26.73431895575666]],[7,"Knee_R",294,[-642],[1,0.006485617719590664,9.992007618673103e-18,9.992007618673103e-18],[3,1.0421712215713451e-17,9.1641098275595e-18,-0.7509635080199943,0.6603437056732683],[1,180,180,-82.65218201681442]],[7,"Ankle_R",295,[-643],[1,0.006850753910839558,-9.992007618673103e-18,-1.4432898790731443e-17],[3,-0.107779091379776,0.03794360473263759,0.4382270207142593,0.8915722228945604],[1,-20.825588126741046,14.81324250428513,50.646009467453176]],[19,"Toes1_R",296,[[14,"Toes2_R",-644,[1,0.0028587731067091227,-0.0018769684247672558,-2.8829633125226906e-11]]],[1,0.003821877297013998,9.992007618673103e-18,1.4055525840439564e-11],[3,7.078807208851528e-26,7.338928554393833e-26,0.7197470906365884,0.6942363614217905],[1,-180,180,87.93279256115314]],[55,"RootPart1_M",82,[-645],[1,0.0020652245730161667,2.2204459996194763e-18,-6.089342295085281e-19]],[55,"RootPart2_M",298,[-646],[1,0.0020652245730161667,2.2204459996194763e-18,-6.089341778097398e-19]],[7,"Spine2_M",299,[127],[1,0.0020652245730161667,4.440891999238953e-18,2.7589170037440396e-18],[3,2.833542290373483e-16,-5.276558712844762e-17,-0.13887424912163487,0.9903100236445666],[1,3.257203985875381e-14,-1.5379762679065733e-15,-15.965418280697603]],[7,"Neck_M",127,[-647],[1,0.002901608357205987,-0.0031024303752928972,-9.727658892874631e-18],[3,-2.4871766108048305e-24,2.1821083289339757e-24,-0.6595017750111039,0.7517030056858913],[1,-3.791516639546766e-22,0,-82.52377277072583]],[55,"NeckPart1_M",301,[163],[1,0.005839296150952578,5.551115205843844e-18,2.898164867815023e-11]],[19,"Jaw_M",163,[[14,"JawEnd_M",-648,[1,0.01144465059041977,-4.440891999238953e-18,2.616274463397792e-18]]],[1,-0.0070828660391271114,0.001565893879160285,-4.563028938995164e-18],[3,-4.0602511795263196e-25,8.309202330691217e-25,0.7944917325602083,0.6072749681103925],[1,-180,180,74.7854503251938]],[7,"Scapula_R",127,[-649],[1,0.0009082318283617496,-0.0016960602952167392,-0.0035904867108911276],[3,0.7485383193052008,0.6073311003787559,-0.20668350270817637,0.16769391388107713],[1,112.31256356364936,70.98174103154757,57.129780034201545]],[7,"Shoulder_R",304,[-650],[1,0.002976213349029422,0,-8.881783998477905e-18],[3,-0.07353511641712662,0.25579661788485253,-0.2663195499695608,0.9264095067712771],[1,0.0000012480393304219223,30.871376804796846,-32.07723760154569]],[7,"Elbow_R",305,[-651],[1,0.006145196035504341,-5.551115205843844e-18,1.0769163656501374e-16],[3,8.504070203628985e-25,6.16430870102796e-26,0.3120392175523727,0.9500692220618996],[1,1.1223607321790314e-22,-2.942762314065395e-23,36.36433252877887]],[7,"Wrist_R",306,[-652],[1,0.003922537434846163,-7.77156120546332e-18,2.0003202219620597e-11],[3,1.26163860488356e-8,3.485806502145198e-9,0.26631405719129686,0.9638863122496919],[1,0.0000014998981938610756,2.921850661819311e-14,30.890097833571968]],[19,"Fingers1_R",307,[[14,"Fingers2_R",-653,[1,0.0024803609121590853,-0.0011090633925050497,4.9960034784643064e-17]]],[1,0.0013398798182606697,1.1102229998097382e-18,2.8932013035332105e-12],[3,-1.0268690676414758e-8,-4.1971217162257e-9,0.37834661793140156,0.9256639977334487],[1,-0.0000012712012910317389,-1.2653603427533027e-14,44.46261181934115]],[7,"Scapula_L",127,[-654],[1,0.0009082318283617496,-0.0016960602952167392,0.0035904867108911276],[3,-0.6073310985082828,0.7485383169998342,0.16769391336460931,0.20668351697278872],[1,-67.68743656021654,109.01825758625266,-57.12977896045119]],[7,"Shoulder_L",309,[-655],[1,-0.002976213349029422,-2.2204459996194763e-18,-6.661337998858429e-18],[3,-0.08087501841085962,0.2535716049327198,-0.29290211802618116,0.9183512518773331],[1,-0.0000020023668605326484,30.871375957102188,-35.37948463187456]],[7,"Elbow_L",310,[-656],[1,-0.006145196035504341,2.1649348186097164e-17,2.5022001831631613e-11],[3,3.698432393575249e-24,7.844895137691728e-26,0.4660808189363135,0.8847421490014223],[1,6.556099890129191e-22,-3.352136588885891e-22,55.56038648837976]],[7,"Wrist_L",311,[-657],[1,-0.003922537434846163,1.1102230411687688e-17,-2.0801102160183937e-11],[3,-2.2213494740521317e-8,2.682952490230911e-9,-0.11990886018104767,0.9927849038185872],[1,-0.000002563978345591965,-1.238952164628575e-14,-13.773685345369223]],[19,"Fingers1_L",312,[[14,"Fingers2_L",-658,[1,-0.0024803609121590853,0.0011090633925050497,-1.7181324071802173e-11]]],[1,-0.0013398798182606697,3.3306689994292145e-18,-3.0510691195750894e-11],[3,1.202641542986473e-8,-1.7758621256120527e-8,0.5607324843663741,0.8279970295697404],[1,0.000006148774687692887,-0.0000066217698935251255,68.21293812945635]],[7,"Hip_L",82,[-659],[1,-0.00007880722841946408,0.0005406050477176905,0.003936111461371183],[3,-0.33800700071914674,0.9337119991241997,0.028422765236197228,0.11456577400194808],[1,-9.622341407618702,162.62735726022657,-38.65942560522658]],[7,"Knee_L",314,[-660],[1,-0.006485617719590664,-5.551114999048691e-19,1.1102229998097382e-18],[3,-1.7336686139568426e-19,-9.811546734126506e-18,-0.719488810323054,0.6945040329759912],[1,-179.99999999999997,-179.99999999999997,-87.97541642889963]],[7,"Ankle_L",315,[-661],[1,-0.006850753910839558,9.992007618673103e-18,7.77156120546332e-18],[3,-0.10166416476507739,0.05983485747743264,0.6161200500698334,0.7787684324208453],[1,-46.51448788453161,43.07919569002581,71.34531796373011]],[19,"Toes1_L",316,[[14,"Toes2_L",-662,[1,-0.0028587731067091227,0.0018769684247672558,2.8829636594673858e-11]]],[1,-0.003821877297013998,0,2.3568615808988724e-11],[3,-0.00020272489692942466,0.00016227147528271118,0.6862465063574965,0.727369002008413],[1,-0.5101740052366177,0.5068947396755507,86.66730611092152]],[18,"Cat_model",81,[[49,1,-663,[280,281,282,283],[58,true],81,284,285]]],[82,"LaserController","252+iqgvVFK61BOQRNHXeq",13,[[165,-664,15,246,111,113,109,140,138,142,141,[145,146,147,148,149]]]],[82,"CubeController","b3nb8h/T5GgIPN/YxYu1K3",13,[[166,-665,[27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,17,17,59,60,61,62,63,64,65,66,67,68,69,70,71,72]]]],[82,"Responsive","93m7EM2HBCV798YB+7/26R",13,[[167,-666,116,115]]]],0,[0,-1,27,0,-2,28,0,-3,29,0,-4,97,0,-5,30,0,-6,31,0,-7,32,0,-8,33,0,-9,34,0,-10,35,0,-11,36,0,-12,37,0,-13,38,0,-14,39,0,-15,40,0,-16,41,0,-17,42,0,-18,43,0,-19,44,0,-20,45,0,-21,46,0,-22,47,0,-23,48,0,-24,49,0,-1,50,0,-2,51,0,-3,52,0,-4,53,0,-5,54,0,-6,55,0,-7,56,0,-8,57,0,-9,58,0,-10,17,0,-11,59,0,-12,60,0,-13,61,0,-14,62,0,-15,63,0,-16,64,0,-17,65,0,-18,66,0,-19,67,0,-20,68,0,-21,69,0,-22,70,0,-23,71,0,-24,72,0,0,4,0,17,264,0,0,4,0,0,4,0,-1,263,0,-2,116,0,-3,117,0,-4,118,0,-5,119,0,-6,77,0,-7,26,0,-8,78,0,-9,10,0,-10,124,0,-11,125,0,9,161,0,0,5,0,0,5,0,0,5,0,18,83,0,19,81,0,20,115,0,21,15,0,0,5,0,2,5,0,-2,16,0,-3,80,0,-4,161,0,-5,83,0,-1,84,0,-2,85,0,-3,86,0,-4,87,0,-5,88,0,-6,89,0,-7,90,0,-8,91,0,-9,92,0,-10,93,0,-11,94,0,-12,95,0,-13,96,0,9,152,0,9,153,0,0,7,0,0,7,0,0,7,0,-4,246,0,-1,75,0,-2,243,0,-3,76,0,-4,244,0,-5,152,0,-6,153,0,-1,98,0,-2,99,0,-3,19,0,-4,175,0,-5,177,0,-6,131,0,-7,179,0,-8,180,0,-9,181,0,-10,182,0,-11,184,0,-1,15,0,-1,247,0,-2,249,0,-3,251,0,-4,253,0,-5,255,0,-6,257,0,-7,259,0,-8,261,0,0,10,0,0,10,0,-1,121,0,-2,122,0,-3,79,0,-4,156,0,-5,157,0,-6,123,0,15,174,0,15,174,0,16,11,0,-1,115,0,-1,128,0,-2,164,0,-3,14,0,-4,150,0,9,21,0,13,21,0,9,22,0,13,22,0,9,23,0,13,23,0,9,25,0,13,25,0,9,24,0,13,24,0,-2,266,0,-3,319,0,-4,320,0,-6,321,0,-1,129,0,-3,130,0,-5,107,0,-6,20,0,-1,160,0,2,16,0,2,16,0,2,16,0,-5,276,0,-6,280,0,0,17,0,0,17,0,0,17,0,-1,168,0,-2,169,0,-3,170,0,-4,171,0,2,18,0,0,19,0,0,19,0,0,19,0,-1,173,0,-1,21,0,-2,22,0,-3,23,0,-4,24,0,-5,25,0,-1,145,0,-1,193,0,-2,195,0,-1,146,0,-1,197,0,-2,199,0,-1,147,0,-1,201,0,-2,203,0,-1,148,0,-1,205,0,-2,207,0,-1,149,0,-1,209,0,-2,211,0,0,26,0,0,26,0,-3,154,0,0,26,0,0,27,0,0,27,0,0,27,0,0,28,0,0,28,0,0,28,0,0,29,0,0,29,0,0,29,0,0,30,0,0,30,0,0,30,0,0,31,0,0,31,0,0,31,0,0,32,0,0,32,0,0,32,0,0,33,0,0,33,0,0,33,0,0,34,0,0,34,0,0,34,0,0,35,0,0,35,0,0,35,0,0,36,0,0,36,0,0,36,0,0,37,0,0,37,0,0,37,0,0,38,0,0,38,0,0,38,0,0,39,0,0,39,0,0,39,0,0,40,0,0,40,0,0,40,0,0,41,0,0,41,0,0,41,0,0,42,0,0,42,0,0,42,0,0,43,0,0,43,0,0,43,0,0,44,0,0,44,0,0,44,0,0,45,0,0,45,0,0,45,0,0,46,0,0,46,0,0,46,0,0,47,0,0,47,0,0,47,0,0,48,0,0,48,0,0,48,0,0,49,0,0,49,0,0,49,0,0,50,0,0,50,0,0,50,0,0,51,0,0,51,0,0,51,0,0,52,0,0,52,0,0,52,0,0,53,0,0,53,0,0,53,0,0,54,0,0,54,0,0,54,0,0,55,0,0,55,0,0,55,0,0,56,0,0,56,0,0,56,0,0,57,0,0,57,0,0,57,0,0,58,0,0,58,0,0,58,0,0,59,0,0,59,0,0,59,0,0,60,0,0,60,0,0,60,0,0,61,0,0,61,0,0,61,0,0,62,0,0,62,0,0,62,0,0,63,0,0,63,0,0,63,0,0,64,0,0,64,0,0,64,0,0,65,0,0,65,0,0,65,0,0,66,0,0,66,0,0,66,0,0,67,0,0,67,0,0,67,0,0,68,0,0,68,0,0,68,0,0,69,0,0,69,0,0,69,0,0,70,0,0,70,0,0,70,0,0,71,0,0,71,0,0,71,0,0,72,0,0,72,0,0,72,0,-1,138,0,-2,139,0,-3,140,0,-4,183,0,-1,141,0,-2,106,0,-3,142,0,-4,185,0,-1,213,0,-2,219,0,-3,223,0,-4,239,0,0,76,0,0,77,0,-1,155,0,-2,120,0,0,78,0,0,78,0,0,78,0,0,79,0,0,79,0,0,79,0,-1,284,0,-2,285,0,-3,286,0,-4,287,0,-1,82,0,-2,318,0,-1,288,0,-2,294,0,-3,298,0,-4,314,0,0,83,0,0,83,0,0,83,0,0,84,0,0,84,0,0,84,0,0,85,0,0,85,0,0,85,0,0,86,0,0,86,0,0,86,0,0,87,0,0,87,0,0,87,0,0,88,0,0,88,0,0,88,0,0,89,0,0,89,0,0,89,0,0,90,0,0,90,0,0,90,0,0,91,0,0,91,0,0,91,0,0,92,0,0,92,0,0,92,0,0,93,0,0,93,0,0,93,0,0,94,0,0,94,0,0,94,0,0,95,0,0,95,0,0,95,0,0,96,0,0,96,0,0,96,0,0,97,0,0,97,0,0,97,0,0,98,0,0,98,0,-1,167,0,0,99,0,-2,172,0,0,100,0,0,100,0,0,100,0,0,101,0,0,101,0,0,101,0,0,102,0,0,102,0,0,102,0,0,103,0,0,103,0,0,103,0,0,104,0,0,104,0,0,104,0,0,105,0,0,105,0,0,105,0,0,106,0,0,106,0,0,106,0,-1,186,0,-2,189,0,-3,192,0,-1,187,0,-2,109,0,-3,188,0,0,109,0,0,109,0,-1,111,0,-2,190,0,-3,191,0,0,111,0,0,111,0,-1,113,0,-2,143,0,-3,144,0,0,113,0,0,113,0,-1,226,0,-2,229,0,-3,234,0,0,116,0,0,116,0,0,117,0,0,117,0,0,118,0,0,118,0,0,119,0,0,119,0,0,120,0,0,120,0,0,120,0,0,121,0,0,121,0,0,122,0,0,122,0,0,123,0,0,123,0,0,123,0,0,124,0,0,124,0,0,125,0,-1,158,0,-2,159,0,-1,268,0,-2,270,0,-3,273,0,-1,301,0,-2,304,0,-3,309,0,0,128,0,0,129,0,0,129,0,-1,165,0,-2,166,0,-1,132,0,-1,136,0,-2,137,0,0,136,0,0,136,0,0,137,0,0,137,0,0,138,0,0,139,0,0,139,0,0,140,0,0,141,0,0,142,0,0,143,0,0,143,0,0,144,0,0,144,0,3,145,0,3,146,0,3,147,0,3,148,0,3,149,0,2,151,0,-2,228,0,0,152,0,0,153,0,0,155,0,0,155,0,0,156,0,0,156,0,0,157,0,0,157,0,0,158,0,0,158,0,0,159,0,0,159,0,-1,267,0,2,160,0,-1,162,0,0,162,0,2,163,0,-2,303,0,0,164,0,0,167,0,2,168,0,2,169,0,2,170,0,2,171,0,0,172,0,0,173,0,-1,176,0,0,176,0,-1,178,0,0,178,0,0,183,0,0,185,0,0,187,0,0,188,0,0,190,0,0,191,0,-1,194,0,3,194,0,-1,196,0,3,196,0,-1,198,0,3,198,0,-1,200,0,3,200,0,-1,202,0,3,202,0,-1,204,0,3,204,0,-1,206,0,3,206,0,-1,208,0,3,208,0,-1,210,0,3,210,0,-1,212,0,3,212,0,-1,214,0,-1,215,0,-1,216,0,-1,217,0,-1,218,0,2,218,0,-1,220,0,-1,221,0,-1,222,0,2,222,0,-1,224,0,-1,225,0,-1,227,0,2,228,0,-1,230,0,-1,231,0,-1,232,0,-1,233,0,2,233,0,-1,235,0,-1,236,0,-1,237,0,-1,238,0,2,238,0,-1,240,0,-1,241,0,-1,242,0,2,242,0,0,243,0,-1,245,0,0,245,0,-1,248,0,-1,250,0,-1,252,0,-1,254,0,-1,256,0,-1,258,0,-1,260,0,-1,262,0,-1,264,0,-1,269,0,2,269,0,-1,271,0,-1,272,0,2,272,0,-1,274,0,-1,275,0,2,275,0,-1,277,0,-1,278,0,-1,279,0,2,279,0,-1,281,0,-1,282,0,-1,283,0,2,283,0,0,284,0,0,285,0,0,286,0,0,287,0,-1,289,0,-1,290,0,-1,291,0,-1,292,0,-1,293,0,2,293,0,-1,295,0,-1,296,0,-1,297,0,2,297,0,-1,299,0,-1,300,0,-1,302,0,2,303,0,-1,305,0,-1,306,0,-1,307,0,-1,308,0,2,308,0,-1,310,0,-1,311,0,-1,312,0,-1,313,0,2,313,0,-1,315,0,-1,316,0,-1,317,0,2,317,0,0,318,0,0,319,0,0,320,0,0,321,0,22,13,1,2,165,2,2,166,4,2,12,5,2,150,6,2,14,7,2,150,8,2,14,9,2,13,11,2,19,12,2,13,15,23,262,15,24,260,15,25,258,15,26,256,15,27,254,15,28,252,15,29,250,15,30,248,18,2,99,73,2,182,74,2,184,81,2,162,100,2,132,101,2,132,102,2,133,103,2,133,104,2,134,105,2,134,108,2,186,110,2,189,112,2,192,114,2,225,115,31,122,115,32,121,115,33,128,115,34,118,115,35,117,115,36,119,115,37,265,115,38,154,126,2,267,127,2,300,133,2,179,134,2,180,135,2,181,151,2,227,163,2,302,265,0,266,666],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,250,252,254,256,258,260,262],[-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,-1,1,39,14,14,14,14,-1,1,-1,12,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,-2,-3,-4,1,8,-1,1,8,-1,1,8,-1,1,8,-1,-2,12,5,5,5,5,5,5,-1,12,5,5,5,5,40,5,5,5,-1,12,-1,12,5,5,5,5,-1,1,8,-1,1,8,-1,1,8,-1,1,8,-1,-2,-3,-4,1,8,-1,1,-1,1,-1,-2,-3,12,41,42,10,10,10,10,10,10,10,10],[74,75,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,0,19,1,20,0,21,1,22,0,23,1,24,0,25,1,26,1,27,0,28,1,29,0,30,1,31,0,32,1,33,0,34,0,35,1,36,0,37,1,38,0,39,1,40,0,41,1,42,0,19,1,20,0,21,1,22,0,23,1,24,0,25,1,26,1,27,0,28,1,29,0,30,1,31,0,32,1,33,0,34,0,35,1,36,0,37,1,38,0,39,1,40,0,41,1,42,45,46,45,46,47,76,47,5,48,77,43,71,44,70,5,48,49,49,5,50,5,50,7,15,7,16,7,15,7,16,7,15,7,16,7,78,7,79,0,12,5,51,52,12,80,17,81,12,5,51,52,12,82,17,5,83,84,85,5,86,53,54,5,55,5,56,53,54,5,55,5,56,9,2,10,2,11,2,9,2,10,2,11,2,9,2,10,2,11,2,9,2,10,2,11,2,9,2,10,2,11,2,8,8,8,8,57,58,18,87,88,18,89,90,18,91,92,59,93,59,94,95,60,61,96,97,62,62,63,64,98,65,65,61,60,99,66,66,67,67,64,145,146,63,13,100,101,13,102,103,13,104,105,13,106,107,8,8,8,8,57,58,108,109,110,17,111,68,112,68,113,114,115,116,117,118,119,120,121,122]],[[[11,".bin",1324059261,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":77232,"length":22176,"count":5544,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":77232,"count":1609,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.020160561427474022,-0.0016125263646245003,-0.01934860460460186],"maxPosition",8,[1,0.025917362421751022,0.019485151395201683,0.017504869028925896]]],-1],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,2,2,0,0","mipmaps":["e71uS35VpPpbPKtBCx7x94"]}],[1],0,[],[],[]],[[{"name":"img_navigate","rect":{"x":2,"y":1,"width":416,"height":201},"offset":{"x":0,"y":0.5},"originalSize":{"width":420,"height":204},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[4],0,[0],[11],[147]],[[{"fmt":"0","w":0,"h":0},-1],[0],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["edGoT/hLNPK7dChjeBJYcx"]}],[1],0,[],[],[]],[[[72,"angry_cat",".mp3",1.205333],-1],0,0,[],[],[]],[[[47,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{},{}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":0.30151134729385376,"metallic":0.4000000059604645},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[7,6],[73,6]],[[[132,"CatEscape"],[36,"break_wall_",[-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24]],[36,"break_wall_",[-25,-26,-27,-28,-29,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-42,-43,-44,-45,-46,-47,-48]],[36,"break_wall_",[-49,-50,-51,-52,-53,-54,-55,-56,-57,-58,-59,-60,-61,-62,-63,-64,-65,-66,-67,-68,-69,-70,-71,-72]],[8,["d8s2smx0BGKZuCh9SYwYNL"]],[119,"Boss",[[[54,"lv1_policeman",-82],-83,-84,-85,-86],4,1,1,1,1],[[135,true,-74,[338,339,340],[[83,"Root_M/Spine1_M/Spine2_M/Chest_M/Scapula_R/Shoulder_R/Elbow_R/Wrist_R",-73]],341],[27,-75,[1,0,0.3,0],[1,0.3,0.58,0.3]],[52,16,100,-76,[1,1,0,1],[1,1,0,1]],[141,-81,-80,-79,-78,-77]],[1,-3.5,0,2.109],[3,0,0.7071067811865475,0,0.7071067811865476],[1,4,4,4],[1,0,90,0]],[114,"Canvas2D",33554432,[-91,-92,-93,-94,-95,-96,-97,-98,-99,-100],[[32,-87,[5,320,480]],[133,-89,-88],[134,45,-2.842170943040401e-14,-2.842170943040401e-14,-90]],[1,160,239.99999999999997,0]],[108,"Wall",[-101,-102,-103,-104,-105,-106,-107,-108,-109,-110,-111,-112,-113],[1,1,1.5,0.9999999999999998]],[121,"CatController",[-120,-121,-122,-123,-124,-125],[[[136,-116,[289,290],[[83,"Root_M/Tail0_M/Tail1_M/Tail2_M/Tail3_M/Tail4_M/Tail5_M",-114],[83,"Root_M/RootPart1_M/RootPart2_M/Spine2_M/Chest_M/Neck_M/NeckPart1_M/Head_M/HeadEnd_M",-115]],291],[27,-117,[1,0,0.02,0.004],[1,0.033,0.04,0.043]],[139,100,-118,[1,1,0,1]],-119],4,4,4,1],[1,-7.64,0,2.195],[3,0,0.7071067811865475,0,0.7071067811865476],[1,30,30,30],[1,0,90,0]],[36,"Room",[-126,-127,-128,-129,-130,-131,-132,-133,-134,-135,-136]],[90,"AudioManager","91MUdo8mRCu5o6mQ9zrX1M",[-138,-139,-140,-141,-142,-143,-144,-145],[-137]],[91,"CTA",33554432,6,[-148,-149,-150,-151,-152,-153],[[89,-146],[105,-147,[310],311]]],[109,0,{},[124,"f6h5JTA61Krp7fpJXxRpdl",-156,[142,"0aRJjUW8ZPNJ2S45jl1QOw",null,[[10,"Walk Break",["_name"],[8,["f6h5JTA61Krp7fpJXxRpdl"]]],[57,["_lpos"],[8,["f6h5JTA61Krp7fpJXxRpdl"]],[1,0,0.017,0]],[57,["_lrot"],[8,["f6h5JTA61Krp7fpJXxRpdl"]],[3,0.7071067811865475,0,0,0.7071067811865476]],[57,["_euler"],[8,["f6h5JTA61Krp7fpJXxRpdl"]],[1,90,0,0]],[10,1,["_simulationSpace"],[8,["b2Z3tunMxD543DLFEf8MY1"]]],[57,["_lscale"],[8,["f6h5JTA61Krp7fpJXxRpdl"]],[1,1,1,1]],[10,true,["loop"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,true,["loop"],[8,["b2Z3tunMxD543DLFEf8MY1"]]],[10,true,["loop"],[8,["d8s2smx0BGKZuCh9SYwYNL"]]],[10,0,["scaleSpace"],[8,["b2Z3tunMxD543DLFEf8MY1"]]],[10,0,["scaleSpace"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,0,["scaleSpace"],[8,["d8s2smx0BGKZuCh9SYwYNL"]]],[57,["_lscale"],[8,["ec12r82KpHmrFyR4IuXAYD"]],[1,0.007,0.007,0.007]],[57,["_lpos"],[8,["ec12r82KpHmrFyR4IuXAYD"]],[1,0,0,0.013]],[10,true,["playOnAwake"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,2,["_materials","length"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,null,["_materials","1"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,0.25,["duration"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,0.3,["startSizeX","constantMin"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,2,["startSizeX","constantMax"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,0.35,["simulationSpeed"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,6.283185307179586,["startRotationZ","constantMin"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,0,["gravityModifier","constant"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,false,["startSize3D"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,2,["startSpeed","constant"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,0.6,["startLifetime","constantMax"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,6.283185307179586,["startRotationZ","constantMax"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,true,["_textureAnimationModule","_enable"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[85,["renderer","_mainTexture"],[8,["d6dNQQc1JJ872kZBLdCYV/"]],182],[10,true,["_limitVelocityOvertimeModule","_enable"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,false,["_trailModule","_enable"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[10,0,["_simulationSpace"],[8,["d8s2smx0BGKZuCh9SYwYNL"]]],[10,true,["playOnAwake"],[8,["d8s2smx0BGKZuCh9SYwYNL"]]],[77,["_lpos"],-154,[1,0,0,0.017]],[85,["_materials","0"],[8,["d8s2smx0BGKZuCh9SYwYNL"]],183],[143,["renderer","_mainTexture"],4,184],[85,["_materials","0"],[8,["d6dNQQc1JJ872kZBLdCYV/"]],185],[10,0,["_simulationSpace"],[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[17,0.10039999999999999,["_colorOverLifetimeModule","color","gradient","colorKeys","1","time"],4],[17,0.9352678571428571,["_colorOverLifetimeModule","color","gradient","alphaKeys","1","time"],4],[17,4,["_colorOverLifetimeModule","color","gradient","colorKeys","length"],4],[86,["_colorOverLifetimeModule","color","gradient","colorKeys","2"],4,[96,0.2701]],[86,["_colorOverLifetimeModule","color","gradient","colorKeys","3"],4,[13,1,[4,4278190335]]],[77,["_colorOverLifetimeModule","color","gradient","colorKeys","1","color"],4,[4,4284012543]],[17,0.2,["duration"],4],[17,0.1,["simulationSpeed"],4],[77,["startColor","color"],4,[4,2533359615]],[17,false,["startRotation3D"],4],[17,6.283185307179586,["startRotationZ","constant"],4],[77,["_lscale"],-155,[1,0.016,0.016,0.016]],[17,3,["startRotationZ","mode"],4],[17,6.283185307179586,["startRotationZ","constantMin"],4],[17,6.283185307179586,["startRotationZ","constantMax"],4],[17,3,["startLifetime","mode"],4],[17,0.2,["startLifetime","constantMin"],4],[17,0.6,["startLifetime","constantMax"],4],[17,0.8883928571428572,["_colorOverLifetimeModule","color","gradient","alphaKeys","0","time"],4],[17,255,["_colorOverLifetimeModule","color","gradient","alphaKeys","0","alpha"],4],[17,255,["_colorOverLifetimeModule","color","gradient","alphaKeys","1","alpha"],4],[17,3,["_colorOverLifetimeModule","color","gradient","alphaKeys","length"],4],[86,["_colorOverLifetimeModule","color","gradient","alphaKeys","2"],4,[97,255,0.9910714285714286]],[17,0.2,["startSpeed","constant"],4]]],181]],[90,"GameNode","2dHAV5VQFGj4wTXC++MSEv",[-158,-159,-160,-161,6],[-157]],[144,"CatEscape",[13,-172,-173,-174,10,-175],[123,"f82590ab-7475-4b63-9a96-e8c0a6a65b85",[[46,["_trailModule","_particleSystem"],12,[8,["b2Z3tunMxD543DLFEf8MY1"]],12,[8,["b2Z3tunMxD543DLFEf8MY1"]]],[46,["_trailModule","_particleSystem"],12,[8,["d6dNQQc1JJ872kZBLdCYV/"]],12,[8,["d6dNQQc1JJ872kZBLdCYV/"]]],[46,["_trailModule","_particleSystem"],12,[8,["d8s2smx0BGKZuCh9SYwYNL"]],12,[8,["d8s2smx0BGKZuCh9SYwYNL"]]],[46,["_trailModule","_particleSystem"],-163,[8,["5cc7kqZIFB1br2814jbBtQ"]],-162,[8,["5cc7kqZIFB1br2814jbBtQ"]]],[46,["_trailModule","_particleSystem"],-165,[8,["5cc7kqZIFB1br2814jbBtQ"]],-164,[8,["5cc7kqZIFB1br2814jbBtQ"]]],[46,["_trailModule","_particleSystem"],-167,[8,["5cc7kqZIFB1br2814jbBtQ"]],-166,[8,["5cc7kqZIFB1br2814jbBtQ"]]],[46,["_trailModule","_particleSystem"],-169,[8,["5cc7kqZIFB1br2814jbBtQ"]],-168,[8,["5cc7kqZIFB1br2814jbBtQ"]]],[46,["_trailModule","_particleSystem"],-171,[8,["5cc7kqZIFB1br2814jbBtQ"]],-170,[8,["5cc7kqZIFB1br2814jbBtQ"]]],[46,["_sockets","0","target"],5,[8,["bcOyuKyI9UqIPP5L1YlBcV"]],5,[8,["17EzxZGYxR5r4/1hl3YAhn"]]]],[12]],[145,[146,0.5208,[2,0.23529411764705882,0.3607843137254902,0.796078431372549,0.520833125],[2,0.23529411764705882,0.3607843137254902,0.796078431372549,1],[2,0.519964,0.630786,0.905039,0.5208],[2,0.519544,0.630484,0.905069,0]],[147,1,true,2,0.05,0.4,0.2,30,2000,10,0.36,[4,4283190348],[0,2048,2048]],[148,true,342,343],[149],[150]]],[51,"Environment",13,[-176,7,-177,9,-178,-179]],[151,10],[94,"Root_M",5,[[-180,[62,"buttock_L",-181,[1,0.024852434173226357,-0.059839557856321335,0.0003288912703283131],[3,-0.4903136496389626,-0.5095022325542063,-0.4903136496389626,0.5095022325542063],[1,-87.80101540917607,-90,0]],[62,"joint1_R",-182,[1,0.030830349773168564,0.012705310247838497,-0.09136062115430832],[3,-0.4903136496389626,-0.5095022325542063,-0.4903136496389626,0.5095022325542063],[1,-87.80101540917607,-90,0]],[62,"joint2_L",-183,[1,0.030830780044198036,0.012705325148999691,0.09136059880256653],[3,0.5095022325542063,-0.4903136496389626,0.5095022325542063,0.4903136496389626],[1,92.19898459082393,-90,0]],-184,-185],1,4,4,4,1,1],[1,2.557074801318597e-18,0.12751342356204987,-0.0022986005060374737],[3,0.49031366511188224,0.5095022176640187,0.49031366511188224,0.5095022176640187],[1,0,90.00000000000034,87.80101888917287]],[4,"break_wall.009",2,[[3,1,-186,[94],[1],95],[6,4,-187],[5,-188,[1,0.005,0.005,0.005]]],[1,-0.012499326840043068,0.007452864665538073,-0.000001718401563266525]],[120,"carpet1",[[-189,-190,-191,-192,[54,"transform1",-193]],1,1,1,1,4]],[92,"Food",9,[-197,12],[[3,1,-194,[186],[58,true],187],[27,-195,[1,0,0.002,0],[1,0.00944,0.0035,0.006958]],[84,true,-196,[188],189]],[1,-2.135,0.365,0.36],[1,150,150,150]],[51,"Effects",15,[-198,-199,-200,-201,-202]],[63,"Electric_1",21,[-204,-205],[-203],[1,2.87,1.145,4.176],[3,0.7071067811865475,0,0,0.7071067811865476],[1,0.26,0.26000000000000006,0.26000000000000006],[1,89.99999999999999,0,0]],[63,"Electric_2",21,[-207,-208],[-206],[1,2.87,1.142,0.299],[3,0.7071067811865475,0,0,0.7071067811865476],[1,0.26,0.26000000000000006,0.26000000000000006],[1,89.99999999999999,0,0]],[63,"Electric_3",21,[-210,-211],[-209],[1,2.87,1.303,2.125],[3,0.7071067811865475,0,0,0.7071067811865476],[1,0.26,0.26000000000000006,0.26000000000000006],[1,89.99999999999999,0,0]],[63,"Electric_4",21,[-213,-214],[-212],[1,2.87,0.108,1.03],[3,0.7071067811865475,0,0,0.7071067811865476],[1,0.26,0.26000000000000006,0.26000000000000006],[1,89.99999999999999,0,0]],[63,"Electric_5",21,[-216,-217],[-215],[1,2.87,0.076,3.149],[3,0.7071067811865475,0,0,0.7071067811865476],[1,0.26,0.26000000000000006,0.26000000000000006],[1,89.99999999999999,0,0]],[122,"JoyStick",33554432,6,[[[32,-218,[5,80,80]],[106,0,-219,315],-220,[98,0,-221]],4,4,1,4],[1,0,-130,0]],[4,"break_wall",1,[[3,1,-222,[28],[1],29],[5,-223,[1,0.005,0.005,0.005]],[6,4,-224]],[1,-0.017498958855867386,0.012452497147023678,-0.0000017197428405779647]],[4,"break_wall.001",1,[[3,1,-225,[30],[1],31],[5,-226,[1,0.005,0.005,0.005]],[6,4,-227]],[1,-0.012499326840043068,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.002",1,[[3,1,-228,[32],[1],33],[5,-229,[1,0.005,0.005,0.005]],[6,4,-230]],[1,-0.007499693427234888,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.004",1,[[3,1,-231,[36],[1],37],[5,-232,[1,0.005,0.005,0.005]],[6,4,-233]],[1,0.0024995713029056787,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.005",1,[[3,1,-234,[38],[1],39],[5,-235,[1,0.005,0.005,0.005]],[6,4,-236]],[1,0.007499203085899353,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.006",1,[[3,1,-237,[40],[1],41],[5,-238,[1,0.005,0.005,0.005]],[6,4,-239]],[1,0.012498835101723671,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.007",1,[[3,1,-240,[42],[1],43],[5,-241,[1,0.005,0.005,0.005]],[6,4,-242]],[1,0.017498468980193138,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.008",1,[[3,1,-243,[44],[1],45],[5,-244,[1,0.005,0.005,0.005]],[6,4,-245]],[1,-0.017498958855867386,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.009",1,[[3,1,-246,[46],[1],47],[5,-247,[1,0.005,0.005,0.005]],[6,4,-248]],[1,-0.012499326840043068,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.010",1,[[3,1,-249,[48],[1],49],[5,-250,[1,0.005,0.005,0.005]],[6,4,-251]],[1,-0.007499693427234888,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.011",1,[[3,1,-252,[50],[1],51],[5,-253,[1,0.005,0.005,0.005]],[6,4,-254]],[1,-0.0025000611785799265,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.012",1,[[3,1,-255,[52],[1],53],[5,-256,[1,0.005,0.005,0.005]],[6,4,-257]],[1,0.0024995713029056787,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.013",1,[[3,1,-258,[54],[1],55],[5,-259,[1,0.005,0.005,0.005]],[6,4,-260]],[1,0.007499203085899353,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.014",1,[[3,1,-261,[56],[1],57],[5,-262,[1,0.005,0.005,0.005]],[6,4,-263]],[1,0.012498835101723671,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.015",1,[[3,1,-264,[58],[1],59],[5,-265,[1,0.005,0.005,0.005]],[6,4,-266]],[1,0.017498468980193138,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.016",1,[[3,1,-267,[60],[1],61],[5,-268,[1,0.005,0.005,0.005]],[6,4,-269]],[1,-0.017498958855867386,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.017",1,[[3,1,-270,[62],[1],63],[5,-271,[1,0.005,0.005,0.005]],[6,4,-272]],[1,-0.012499326840043068,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.018",1,[[3,1,-273,[64],[1],65],[5,-274,[1,0.005,0.005,0.005]],[6,4,-275]],[1,-0.007499693427234888,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.019",1,[[3,1,-276,[66],[1],67],[5,-277,[1,0.005,0.005,0.005]],[6,4,-278]],[1,-0.0025000611785799265,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.020",1,[[3,1,-279,[68],[1],69],[5,-280,[1,0.005,0.005,0.005]],[6,4,-281]],[1,0.0024995713029056787,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.021",1,[[3,1,-282,[70],[1],71],[5,-283,[1,0.005,0.005,0.005]],[6,4,-284]],[1,0.007499203085899353,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.022",1,[[3,1,-285,[72],[1],73],[5,-286,[1,0.005,0.005,0.005]],[6,4,-287]],[1,0.012498835101723671,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.023",1,[[3,1,-288,[74],[1],75],[5,-289,[1,0.005,0.005,0.005]],[6,4,-290]],[1,0.017498468980193138,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall",2,[[3,1,-291,[76],[1],77],[6,4,-292],[5,-293,[1,0.005,0.005,0.005]]],[1,-0.017498958855867386,0.012452497147023678,-0.0000017197428405779647]],[4,"break_wall.001",2,[[3,1,-294,[78],[1],79],[6,4,-295],[5,-296,[1,0.005,0.005,0.005]]],[1,-0.012499326840043068,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.002",2,[[3,1,-297,[80],[1],81],[6,4,-298],[5,-299,[1,0.005,0.005,0.005]]],[1,-0.007499693427234888,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.003",2,[[3,1,-300,[82],[1],83],[6,4,-301],[5,-302,[1,0.005,0.005,0.005]]],[1,-0.0025000611785799265,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.004",2,[[3,1,-303,[84],[1],85],[6,4,-304],[5,-305,[1,0.005,0.005,0.005]]],[1,0.0024995713029056787,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.005",2,[[3,1,-306,[86],[1],87],[6,4,-307],[5,-308,[1,0.005,0.005,0.005]]],[1,0.007499203085899353,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.006",2,[[3,1,-309,[88],[1],89],[6,4,-310],[5,-311,[1,0.005,0.005,0.005]]],[1,0.012498835101723671,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.007",2,[[3,1,-312,[90],[1],91],[6,4,-313],[5,-314,[1,0.005,0.005,0.005]]],[1,0.017498468980193138,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.008",2,[[3,1,-315,[92],[1],93],[6,4,-316],[5,-317,[1,0.005,0.005,0.005]]],[1,-0.017498958855867386,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.010",2,[[3,1,-318,[96],[1],97],[6,4,-319],[5,-320,[1,0.005,0.005,0.005]]],[1,-0.007499693427234888,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.011",2,[[3,1,-321,[98],[1],99],[6,4,-322],[5,-323,[1,0.005,0.005,0.005]]],[1,-0.0025000611785799265,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.012",2,[[3,1,-324,[100],[1],101],[6,4,-325],[5,-326,[1,0.005,0.005,0.005]]],[1,0.0024995713029056787,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.013",2,[[3,1,-327,[102],[1],103],[6,4,-328],[5,-329,[1,0.005,0.005,0.005]]],[1,0.007499203085899353,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.014",2,[[3,1,-330,[104],[1],105],[6,4,-331],[5,-332,[1,0.005,0.005,0.005]]],[1,0.012498835101723671,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.015",2,[[3,1,-333,[106],[1],107],[6,4,-334],[5,-335,[1,0.005,0.005,0.005]]],[1,0.017498468980193138,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.016",2,[[3,1,-336,[108],[1],109],[6,4,-337],[5,-338,[1,0.005,0.005,0.005]]],[1,-0.017498958855867386,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.017",2,[[3,1,-339,[110],[1],111],[6,4,-340],[5,-341,[1,0.005,0.005,0.005]]],[1,-0.012499326840043068,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.018",2,[[3,1,-342,[112],[1],113],[6,4,-343],[5,-344,[1,0.005,0.005,0.005]]],[1,-0.007499693427234888,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.019",2,[[3,1,-345,[114],[1],115],[6,4,-346],[5,-347,[1,0.005,0.005,0.005]]],[1,-0.0025000611785799265,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.020",2,[[3,1,-348,[116],[1],117],[6,4,-349],[5,-350,[1,0.005,0.005,0.005]]],[1,0.0024995713029056787,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.021",2,[[3,1,-351,[118],[1],119],[6,4,-352],[5,-353,[1,0.005,0.005,0.005]]],[1,0.007499203085899353,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.022",2,[[3,1,-354,[120],[1],121],[6,4,-355],[5,-356,[1,0.005,0.005,0.005]]],[1,0.012498835101723671,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.023",2,[[3,1,-357,[122],[1],123],[6,4,-358],[5,-359,[1,0.005,0.005,0.005]]],[1,0.017498468980193138,0.0024532328825443983,-0.000001718401563266525]],[36,"Laser_Button",[-360,-361,-362,-363]],[36,"Laser_Button",[-364,-365,-366,-367]],[7,"Root_M",8,[-368,-369,-370,-371],[1,1.0018953194960331e-25,0.01481025293469429,-0.0051376777701079845],[3,0.6968476547856595,-0.12001394093906889,0.6968476547856595,-0.12001394093906889],[1,180,-90,-19.543700609739705]],[18,"Cat China",8,[[137,-372]]],[91,"Navigate",33554432,6,[-374,-375],[[89,-373]]],[100,"Point",33554432,6,[[32,-376,[5,40,40]],[79,0,-377,[4,4279177021],300],[98,0,-378]],[1,0,-130,0]],[35,"tryBtn",33554432,11,[[32,-379,[5,373,167]],[71,-380,[4,16777215],303],[154,3,1.1,-381,304]],[1,0,-162.034,0],[1,0.4,0.4,1]],[88,"fakeBG",33554432,6,[[32,-382,[5,5000,5000]],[79,0,-383,[4,39423],312],[105,-384,[313],314]]],[51,"lv2_soldier",5,[-385,-386,-387,-388]],[110,"FakeCat",false,[-389,-390],[1,-0.418,0.296,0.191],[3,0.4999999999999999,0.5,0.5,0.5000000000000001],[1,2.7,2.7,2.7],[1,0,90,90]],[7,"Root_M",83,[-391,-392,-393,-394],[1,1.0018953194960331e-25,0.01481025293469429,-0.0051376777701079845],[3,0.6968476547856595,-0.12001394093906889,0.6968476547856595,-0.12001394093906889],[1,180,-90,-19.543700609739705]],[41,"Vision",5,[[87,"Quad<ModelComponent>",-395,[336],[1],337],[138,-396,[1,0,0,0.3]],[140,false,32,10000,-397,[1,0,1,0]]],[1,0,0.031,0.344],[3,-0.7071067811865475,0,0,0.7071067811865476],[1,0.5,0.6,0.833333],[1,-90,0,0]],[35,"Cube1",8388608,7,[[34,"Cube<ModelComponent>",1,-398,[2],[1],3],[45,-399],[33,2,2,-400]],[1,0,0.5,-5],[1,20,2,0.25]],[35,"Cube2",8388608,7,[[34,"Cube<ModelComponent>",1,-401,[4],[1],5],[5,-402,[1,1,1.1,2]],[33,2,2,-403]],[1,-2,0.5,4.873],[1,16,2,0.25]],[101,"Cube3",8388608,7,[[87,"Cube<ModelComponent>",-404,[6],[1],7],[45,-405],[33,2,2,-406]],[1,9.873,0.5,2.466],[3,0,0.7071067811865475,0,0.7071067811865477],[1,5,2,0.25],[1,0,89.99999999999999,0]],[101,"Cube4",8388608,7,[[34,"Cube<ModelComponent>",1,-407,[8],[1],9],[5,-408,[1,1,1,2]],[33,2,2,-409]],[1,-9.876,0.5,-0.032],[3,0,0.7071067811865475,0,0.7071067811865476],[1,10,2,0.25],[1,0,89.99999999999999,0]],[81,"Cube5",7,[[34,"Cube<ModelComponent>",1,-410,[10],[1],11],[5,-411,[1,1,1,1.5]],[33,2,2,-412]],[1,-7.329,0.5,-0.801],[1,5,2,0.35]],[41,"Cube8",7,[[34,"Cube<ModelComponent>",1,-413,[12],[1],13],[5,-414,[1,1,1,1.5]],[33,2,2,-415]],[1,-5,0.5,0.115],[3,0,0.7071067811865475,0,0.7071067811865477],[1,1.8,2,0.35],[1,0,89.99999999999999,0]],[41,"Cube9",7,[[34,"Cube<ModelComponent>",1,-416,[14],[1],15],[45,-417],[33,2,2,-418]],[1,-5,0.5,4.06],[3,0,0.7071067811865475,0,0.7071067811865477],[1,1.8,2,0.35],[1,0,89.99999999999999,0]],[81,"Cube10",7,[[34,"Cube<ModelComponent>",1,-419,[16],[1],17],[45,-420],[33,2,2,-421]],[1,2.428,0.5,-0.846],[1,4.8,2,0.35]],[41,"Cube11",7,[[34,"Cube<ModelComponent>",1,-422,[18],[1],19],[45,-423],[33,2,2,-424]],[1,8.367,0.5,-0.846],[3,0,1,0,6.123233995736766e-17],[1,2.8,2,0.35],[1,0,180,0]],[41,"Cube19",7,[[34,"Cube<ModelComponent>",1,-425,[20],[1],21],[45,-426],[33,2,2,-427]],[1,9.873,0.5,-2.469],[3,0,0.7071067811865475,0,0.7071067811865477],[1,5,2,0.25],[1,0,89.99999999999999,0]],[41,"Cube20",7,[[34,"Cube<ModelComponent>",1,-428,[22],[1],23],[45,-429],[33,2,2,-430]],[1,1.246,0.5,4.095],[3,-6.5420519111824014e-18,0.7071067811865475,1.4719616800160387e-17,0.7071067811865476],[1,1.8,2,0.35],[1,-1.7228004524594049e-15,89.99999999999999,6.626155586382319e-16]],[41,"Cube21",7,[[34,"Cube<ModelComponent>",1,-431,[24],[1],25],[45,-432],[33,2,2,-433]],[1,1.246,0.5,0.066],[3,-6.5420519111824014e-18,0.7071067811865475,1.4719616800160387e-17,0.7071067811865476],[1,1.8,2,0.35],[1,-1.7228004524594049e-15,89.99999999999999,6.626155586382319e-16]],[41,"Cube12",7,[[34,"Cube<ModelComponent>",1,-434,[26],[1],27],[45,-435],[33,2,2,-436]],[1,9.7,0.5,4.873],[3,-1.5034270125132327e-17,1,-4.440904908137276e-33,6.123233995736767e-17],[1,0.6,2,0.25],[1,4.033991139266958e-31,180,-1.7228004524594049e-15]],[51,"BreakWalls",15,[-437,-438,-439]],[4,"break_wall.003",1,[[3,1,-440,[34],[1],35],[5,-441,[1,0.005,0.005,0.005]],[6,4,-442]],[1,-0.0025000611785799265,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall",3,[[3,1,-443,[124],[1],125],[6,4,-444],[5,-445,[1,0.005,0.005,0.005]]],[1,-0.017498958855867386,0.012452497147023678,-0.0000017197428405779647]],[4,"break_wall.001",3,[[3,1,-446,[126],[1],127],[6,4,-447],[5,-448,[1,0.005,0.005,0.005]]],[1,-0.012499326840043068,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.002",3,[[3,1,-449,[128],[1],129],[6,4,-450],[5,-451,[1,0.005,0.005,0.005]]],[1,-0.007499693427234888,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.003",3,[[3,1,-452,[130],[1],131],[6,4,-453],[5,-454,[1,0.005,0.005,0.005]]],[1,-0.0025000611785799265,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.004",3,[[3,1,-455,[132],[1],133],[6,4,-456],[5,-457,[1,0.005,0.005,0.005]]],[1,0.0024995713029056787,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.005",3,[[3,1,-458,[134],[1],135],[6,4,-459],[5,-460,[1,0.005,0.005,0.005]]],[1,0.007499203085899353,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.006",3,[[3,1,-461,[136],[1],137],[6,4,-462],[5,-463,[1,0.005,0.005,0.005]]],[1,0.012498835101723671,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.007",3,[[3,1,-464,[138],[1],139],[6,4,-465],[5,-466,[1,0.005,0.005,0.005]]],[1,0.017498468980193138,0.012452497147023678,-0.000001718401563266525]],[4,"break_wall.008",3,[[3,1,-467,[140],[1],141],[6,4,-468],[5,-469,[1,0.005,0.005,0.005]]],[1,-0.017498958855867386,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.009",3,[[3,1,-470,[142],[1],143],[6,4,-471],[5,-472,[1,0.005,0.005,0.005]]],[1,-0.012499326840043068,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.010",3,[[3,1,-473,[144],[1],145],[6,4,-474],[5,-475,[1,0.005,0.005,0.005]]],[1,-0.007499693427234888,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.011",3,[[3,1,-476,[146],[1],147],[6,4,-477],[5,-478,[1,0.005,0.005,0.005]]],[1,-0.0025000611785799265,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.012",3,[[3,1,-479,[148],[1],149],[6,4,-480],[5,-481,[1,0.005,0.005,0.005]]],[1,0.0024995713029056787,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.013",3,[[3,1,-482,[150],[1],151],[6,4,-483],[5,-484,[1,0.005,0.005,0.005]]],[1,0.007499203085899353,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.014",3,[[3,1,-485,[152],[1],153],[6,4,-486],[5,-487,[1,0.005,0.005,0.005]]],[1,0.012498835101723671,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.015",3,[[3,1,-488,[154],[1],155],[6,4,-489],[5,-490,[1,0.005,0.005,0.005]]],[1,0.017498468980193138,0.007452864665538073,-0.000001718401563266525]],[4,"break_wall.016",3,[[3,1,-491,[156],[1],157],[6,4,-492],[5,-493,[1,0.005,0.005,0.005]]],[1,-0.017498958855867386,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.017",3,[[3,1,-494,[158],[1],159],[6,4,-495],[5,-496,[1,0.005,0.005,0.005]]],[1,-0.012499326840043068,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.018",3,[[3,1,-497,[160],[1],161],[6,4,-498],[5,-499,[1,0.005,0.005,0.005]]],[1,-0.007499693427234888,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.019",3,[[3,1,-500,[162],[1],163],[6,4,-501],[5,-502,[1,0.005,0.005,0.005]]],[1,-0.0025000611785799265,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.020",3,[[3,1,-503,[164],[1],165],[6,4,-504],[5,-505,[1,0.005,0.005,0.005]]],[1,0.0024995713029056787,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.021",3,[[3,1,-506,[166],[1],167],[6,4,-507],[5,-508,[1,0.005,0.005,0.005]]],[1,0.007499203085899353,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.022",3,[[3,1,-509,[168],[1],169],[6,4,-510],[5,-511,[1,0.005,0.005,0.005]]],[1,0.012498835101723671,0.0024532328825443983,-0.000001718401563266525]],[4,"break_wall.023",3,[[3,1,-512,[170],[1],171],[6,4,-513],[5,-514,[1,0.005,0.005,0.005]]],[1,0.017498468980193138,0.0024532328825443983,-0.000001718401563266525]],[115,"MocQuanAo",9,[-517],[[78,-515,[174],[1],175],[27,-516,[1,0,0.009,0],[1,0.006667,0.020667,0.006667]]],[1,8.969,0,-4.229],[3,0,-0.6205731361358193,0,0.7841485718322477],[1,150,150,150],[1,0,-76.716,0]],[92,"Tham",9,[19,-519],[[152,-518,[178],[1]]],[1,-7.62,0,2.195],[1,80.00000000000001,80,80.00000000000001]],[56,"Door1_1",[[3,1,-520,[194],[1],195],[52,8,0.0001,-521,[1,0,0,0],[1,0,1,0]],[27,-522,[1,-0.004,0,0],[1,0.006,0.015,0.002]]],[1,0.007821347564458847,0.00755288265645504,1.175609470882577e-10]],[56,"Door1_2",[[3,1,-523,[196],[1],197],[52,8,0.0001,-524,[1,0,0,0],[1,0,1,0]],[27,-525,[1,0.004,0,0],[1,0.006,0.015,0.002]]],[1,-0.007821347564458847,0.00755288265645504,1.175609470882577e-10]],[56,"Door1",[[3,1,-526,[198],[1],199],[52,8,0.0001,-527,[1,0,0,0],[1,0,1,0]],[27,-528,[1,-0.004,0,0],[1,0.006,0.015,0.003]]],[1,0.007821347564458847,0.00755288265645504,1.175609470882577e-10]],[56,"Door2",[[3,1,-529,[200],[1],201],[52,8,0.0001,-530,[1,0,0,0],[1,0,1,0]],[27,-531,[1,0.004,0,0],[1,0.006,0.015,0.003]]],[1,-0.007821347564458847,0.00755288265645504,1.175609470882577e-10]],[56,"Door1",[[3,1,-532,[202],[1],203],[52,8,0.1,-533,[1,0,0,0],[1,0,1,0]],[27,-534,[1,-0.004,0,0],[1,0.007,0.014,0.002]]],[1,0.007821347564458847,0.00755288265645504,1.175609470882577e-10]],[56,"Door2",[[3,1,-535,[204],[1],205],[27,-536,[1,0.004,0,0],[1,0.007,0.014,0.002]],[52,8,0.1,-537,[1,0,0,0],[1,0,1,0]]],[1,-0.007821347564458847,0.00755288265645504,1.175609470882577e-10]],[18,"WallLaserBtn",75,[[3,1,-538,[220],[1],221],[27,-539,[1,-1.1874362826347351e-8,0.0005,4.889443516731262e-9],[1,0.002,0.1,0.002]],[33,2,2,-540]]],[51,"Lasers",15,[-541,-542,-543]],[36,"Electro",[-544,-545,-546]],[81,"Electro_vfx_mesh",135,[[3,1,-547,[228],[1],229],[5,-548,[1,0.0019843416521325707,0.010201558005064726,0.03618932329118252]]],[1,2.410281751963339e-7,0.007962931878864765,1.182999476156965e-9],[1,1.2,1.2,1]],[36,"laser",[-549,-550,-551]],[4,"laser_vfx_mesh",137,[[3,1,-552,[232],[1],233],[5,-553,[1,0.0016475273296236992,0.012324807699769735,0.02926943451166153]]],[1,-2.109229413349567e-8,0.007881137542426586,2.020315292838859e-7]],[36,"laser",[-554,-555,-556]],[4,"laser_vfx_mesh",139,[[3,1,-557,[238],[1],239],[5,-558,[1,0.0016475273296236992,0.012324807699769735,0.02926943451166153]]],[1,-2.109229413349567e-8,0.007881137542426586,2.020315292838859e-7]],[80,"Chest_M",[-559,-560,-561],[1,0.005447485018521547,-1.554312241092664e-17,-5.346294532827751e-18],[3,-9.193751724705897e-17,7.319178504059276e-18,-0.017864119002931025,0.9998404238938577],[1,-1.0525317154700937e-14,6.507944086134008e-16,-2.0471861423310167]],[155,13,16,8,6,78,27,11,80],[35,"Gradient",33554432,6,[[32,-562,[5,16,478]],[53,-563,292]],[1,0,240,0],[1,50,0.2,1]],[35,"text",33554432,6,[[32,-564,[5,438,56]],[53,-565,293]],[1,0,-224.365,0],[1,0.3,0.3,0.3]],[35,"title",33554432,6,[[32,-566,[5,557,220]],[106,0,-567,294]],[1,-40,206.99999999999997,0],[1,0.2,0.2,0.4]],[35,"icon",33554432,6,[[32,-568,[5,198,198]],[53,-569,295]],[1,56,206.99999999999997,0],[1,0.25,0.25,0.6]],[35,"hand",33554432,78,[[32,-570,[5,108,134]],[53,-571,297],[84,true,-572,[298],299]],[1,-53.722999999999985,-197.265,0],[1,0.24999999999999997,0.24999999999999997,0.24999999999999997]],[88,"LoadMap",33554432,11,[[32,-573,[5,2000,2000]],[79,0,-574,[4,0],301]]],[35,"Download",33554432,11,[[32,-575,[5,373,167]],[71,-576,[4,16777215],302]],[1,0,-163,0],[1,0.4,0.4,1]],[35,"hand",33554432,11,[[104,-577,[5,205,168],[0,0.5,0]],[71,-578,[4,16777215],307],[84,true,-579,[308],309]],[1,39.009000000000015,-238.782,0],[1,0.35,0.35,1]],[80,"Chest_M",[-580,-581,-582],[1,0.0533306784927845,2.381428366645137e-16,3.4815426486148546e-17],[3,-2.794241066213517e-18,-1.276094809930094e-16,0.03289460314046024,0.9994588261075249],[1,1.6134277965385988e-16,-1.463619740813736e-14,3.7701239795085772]],[80,"Chest_M",[-583,-584,-585],[1,0.005447485018521547,-1.554312241092664e-17,-5.346294532827751e-18],[3,-9.193751724705897e-17,7.319178504059276e-18,-0.017864119002931025,0.9998404238938577],[1,-1.0525317154700937e-14,6.507944086134008e-16,-2.0471861423310167]],[75,"Camera",13,[[156,"Camera<CameraComponent>",2,1822425087,-586,[4,4285583532]]],[1,-13,24,0],[3,-0.3588838181618332,-0.6092638222162746,-0.358883818161833,0.6092638222162747],[1,-61,-90,6.3611093629270335e-15]],[116,"Ground",15,[[87,"Plane<ModelComponent>",-587,[0],[153,true],1],[158,-588]],[1,2,1,1]],[50,"Doors_1",9,[-589],[1,-4.943,0,2.084],[3,0,0.7071067811865475,0,0.7071067811865476],[1,140,140,140],[1,0,89.99999999999999,0]],[51,"Doors",155,[127,128]],[36,"Doors",[129,130]],[36,"Doors",[131,132]],[36,"exit_door",[-590,-591]],[4,"ExitDoor",159,[[3,1,-592,[206],[1],207],[27,-593,[1,0.008676467288751155,-0.00008720159530639648,-0.0007142104441300035],[1,0.02070255985017866,0.014756504446268082,0.004769404651597142]]],[1,-0.019050396978855133,0.0074655115604400635,-0.00011989556514890864]],[4,"ExitDoor",159,[[3,1,-594,[208],[1],209],[27,-595,[1,-0.008676467288751155,-0.00008720159530639648,-0.0007142079994082451],[1,0.02070255985017866,0.014756504446268082,0.0047693997621536255]]],[1,0.019050396978855133,0.0074655115604400635,-0.00011989721679128706]],[18,"LaserButtonGreen",74,[[3,1,-596,[210],[1],211]]],[18,"LaserBtn",74,[[3,1,-597,[212],[1],213],[27,-598,[1,-1.1874362826347351e-8,0.005,4.889443516731262e-9],[1,0.002,0.05,0.002]]]],[93,"LaserButtonRed",false,74,[[3,1,-599,[214],[1],215]]],[93,"WallLaserButtonGreen",false,75,[[3,1,-600,[218],[1],219]]],[18,"WallLaserButtonRed",75,[[3,1,-601,[222],[1],223]]],[4,"laser_base2",139,[[3,1,-602,[240],[1],241],[27,-603,[1,-0.0022566841216757894,0.007889981320338947,-0.0005208068469073623],[1,0.009780378779396415,0.015779962885702645,0.002453161228913814]]],[1,-2.078171768005177e-8,0.0000016899934962566476,0.014305144548416138]],[4,"laser_base1",139,[[3,1,-604,[242],[1],243],[27,-605,[1,-0.0022566841216757894,0.007889981320338947,0.0005208076327107847],[1,0.009780378779396415,0.015779962885702645,0.0024531626841053367]]],[1,-2.2032313751196853e-8,0.0000016899934962566476,-0.014305144548416138]],[65,0.3,false,22,[248],[9],[12,3,0.6,0.9],[0],[0],[12,3,2,4],[0],[0],[12,3,6.283185307179586,6.283185307179586],[0],[12,3,0.15,0.3],[0],[2,20],[0],[[21,[2,9]]],[22,true,[20,1,[28,[[60,[4,33554431]],[13,0.3727678571428572,[4,33539082]]]]]],[66,true,3,0.01,0.5,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[61,true,0.5,[0],[0],[0],[2,0.2]],[25,[0],[0],[0]],[44,true,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-606],[68,1,249]],[65,0.3,false,23,[254],[9],[12,3,0.6,0.9],[0],[0],[12,3,2,4],[0],[0],[69,3,6.283185307179586],[0],[12,3,0.15,0.3],[0],[2,20],[0],[[21,[2,9]]],[22,true,[20,1,[28,[[60,[4,33554431]],[13,0.3727678571428572,[4,33539082]]]]]],[66,true,3,0.01,0.5,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[61,true,0.5,[0],[0],[0],[2,0.2]],[25,[0],[0],[0]],[44,true,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-607],[68,1,255]],[65,0.6,false,24,[260],[9],[12,3,0.6,0.9],[0],[0],[12,3,2,4],[0],[0],[69,3,6.283185307179586],[0],[12,3,0.15,0.3],[0],[2,20],[0],[[21,[2,9]]],[22,true,[20,1,[28,[[60,[4,33554431]],[13,0.3727678571428572,[4,33539082]]]]]],[66,true,3,0.01,0.5,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[61,true,0.5,[0],[0],[0],[2,0.2]],[25,[0],[0],[0]],[44,true,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-608],[68,1,261]],[65,0.8,false,25,[266],[9],[12,3,0.6,0.9],[0],[0],[12,3,2,4],[0],[0],[69,3,6.283185307179586],[0],[12,3,0.15,0.3],[0],[2,20],[0],[[21,[2,9]]],[22,true,[20,1,[28,[[60,[4,33554431]],[13,0.3727678571428572,[4,33539082]]]]]],[66,true,3,0.01,0.5,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[61,true,0.5,[0],[0],[0],[2,0.2]],[25,[0],[0],[0]],[44,true,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-609],[68,1,267]],[65,0.8,false,26,[272],[9],[12,3,0.6,0.9],[0],[0],[12,3,2,4],[0],[0],[69,3,6.283185307179586],[0],[12,3,0.15,0.3],[0],[2,20],[0],[[21,[2,9]]],[22,true,[20,1,[28,[[60,[4,33554431]],[13,0.3727678571428572,[4,33539082]]]]]],[66,true,3,0.01,0.5,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[61,true,0.5,[0],[0],[0],[2,0.2]],[25,[0],[0],[0]],[44,true,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-610],[68,1,273]],[51,"Characters",13,[8,5]],[95,"Head_M",[[[14,"HeadEnd_M",-611,[1,0.015095275826752186,-2.2204459996194763e-18,1.1147259642693237e-17]],-612],4,1],[1,0.005839296150952578,-2.2204459996194763e-18,7.335141521958022e-11],[3,-3.2970677530887142e-24,2.9610711926934064e-25,-0.05829603108103105,0.9982993402583213],[1,-3.7776313382545368e-22,1.1929573189923404e-23,-6.684022599098756]],[75,"Tail5_M Socket",8,[[49,1,-613,[283],[58,true],77,284,285]],[1,6.341056700567878e-12,0.028416548234473003,-0.015795044030911892],[3,-0.4938677723887209,-0.5060579260202104,0.49386777290395006,0.5060579233593901],[1,0.000007402513691849027,-90.00000752545665,88.60307687403271]],[75,"HeadEnd_M Socket",8,[[49,1,-614,[286],[58,true],77,287,288]],[1,1.023330506786563e-10,0.0420388874710939,0.011561717930852245],[3,0.5100338561202763,0.4897606207231051,0.5100338561202766,0.48976062072310483],[1,-179.99999999999915,-90.00000000000078,87.67669918311346]],[160,27,16,13,8,79,81],[35,"8",33554432,78,[[32,-615,[5,416,201]],[53,-616,296]],[1,0,-180.053,0],[1,0.3,0.3,1]],[117,"icon",33554432,11,[[32,-617,[5,198,198]],[71,-618,[4,16777215],305]],[1,0.6,0.6,1]],[35,"title_game",33554432,11,[[32,-619,[5,557,220]],[79,0,-620,[4,16777215],306]],[1,0,157.99999999999997,0],[1,0.5,0.5,1]],[94,"Spine1_M",17,[[-621,[62,"Belly1_M",-622,[1,0.0077425935305655,0.07469058781862259,5.683020321453694e-18],[3,-0.49471446425189547,-0.5052302434137925,-0.49471446425189547,0.5052302434137925],[1,-88.7949582615246,-90,0]]],1,4],[1,0.04725191742181778,-1.3322675997716858e-17,-2.7206586596425432e-18],[3,3.2975108234797884e-18,-1.1535630463133295e-16,0.008673650158111692,0.9999623831889553],[1,4.925825648115789e-16,-1.322362871078532e-14,0.9939395570423156]],[7,"Wrist_R Socket",5,[-623],[1,-0.23649517833507505,0.2995391313682958,0.007875874325497878],[3,0.007358544050005315,0.6876916440780526,0.7259240642975096,-0.007765781897171327],[1,-93.09776297189606,-178.77581523134523,-0.06611461176780299]],[118,"police_cathernet",183,[83],[[3,1,-624,[334],[1],335]],[1,0.308,-0.298,0]],[95,"Head_M",[[[14,"HeadEnd_M",-625,[1,0.015095275826752186,-2.2204459996194763e-18,1.1147259642693237e-17]],-626],4,1],[1,0.005839296150952578,-2.2204459996194763e-18,7.335141521958022e-11],[3,-3.2970677530887142e-24,2.9610711926934064e-25,-0.05829603108103105,0.9982993402583213],[1,-3.7776313382545368e-22,1.1929573189923404e-23,-6.684022599098756]],[75,"Directional Light",13,[[161,90000,2.34375,-627,[162]]],[1,-12.927,23.868,0.609],[3,-0.46772509094040937,-0.4606509224664642,-0.3889418124971846,0.6463421953013637],[1,-74.895,-74.112,-4.121]],[64,"breakwall_1",99,[1],[1,-2.437,0.04,-0.891],[1,120,120,120]],[50,"breakwall_2",99,[2],[1,1.256,0.04,-2.962],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,90,110,110],[1,0,-89.99999999999999,0]],[50,"breakwall_3",99,[3],[1,-5.586,0.04,-2.921],[3,0,-0.7071067811865475,0,0.7071067811865476],[1,90,110,110],[1,0,-89.99999999999999,0]],[18,"coat",125,[[3,1,-628,[172],[1],173]]],[76,"polySurface5",19,[[54,"transform2",-629]]],[76,"polySurface6",19,[[54,"transform5",-630]]],[76,"polySurface7",19,[[54,"transform3",-631]]],[76,"polySurface9",19,[[54,"transform4",-632]]],[18,"polySurface6",126,[[78,-633,[176],[1],177]]],[18,"cat_food",20,[[3,1,-634,[179],[58,true],180]]],[8,["f2sDa1qWtF56f7v5izDlLP"]],[50,"tree_A_1",9,[-635],[1,4.066,0,7.047],[3,0,0.7336231290607853,0,0.6795565498963736],[1,75,75,75],[1,0,94.38200000000002,0]],[18,"Tree_A",198,[[78,-636,[190],[1],191]]],[50,"tree_A_2",9,[-637],[1,0.984,0,-6.896],[3,0,0.8902803762621423,0,0.45541283649293224],[1,50.00000000000001,50,50.00000000000001],[1,0,125.81700000000001,0]],[18,"Tree_A",200,[[78,-638,[192],[1],193]]],[50,"Doors_2",9,[157],[1,1.192,0.142,2.084],[3,-3.407318703740833e-18,0.7071067811865475,3.40731870374083e-18,0.7071067811865476],[1,140.00000000000003,140,140.00000000000003],[1,-5.521796321985272e-16,89.99999999999999,-2.2069531490250793e-31]],[64,"Doors_3",9,[158],[1,5.898,0.003,-0.858],[1,140,140,140]],[64,"Doors_4",9,[159],[1,7.74,0.542,4.881],[1,80,90,90]],[64,"laser_button_1",9,[74],[1,-2,0,-3],[1,100,100,100]],[41,"icon",74,[[34,"Quad<ModelComponent>",1,-639,[216],[1],217]],[1,-0.001,0.005,0],[3,-0.5,-0.5,-0.4999999999999999,0.5000000000000001],[1,0.007,0.007,0.007],[1,-90,-90,0]],[64,"laser_button_2",9,[75],[1,-7.7,0,-3],[1,100,100,100]],[41,"icon",75,[[34,"Quad<ModelComponent>",1,-640,[224],[1],225]],[1,0,0.003,0],[3,-0.5,-0.5,-0.4999999999999999,0.5000000000000001],[1,0.006,0.006,0.006],[1,-90,-90,0]],[64,"Electro",134,[135],[1,2.61,0,2.007],[1,130,130,130]],[4,"Electro_wall1",135,[[3,1,-641,[226],[1],227]],[1,2.452812566389184e-7,0.00001882825199572835,0.021018020808696747]],[4,"Electro_wall2",135,[[3,1,-642,[230],[1],231]],[1,2.452812566389184e-7,0.00001882825199572835,-0.021018020808696747]],[50,"laser_wall_1",134,[137],[1,5.685,0,2.944],[3,0,1,0,-6.123233995736766e-17],[1,120,120,120],[1,0,-180,0]],[4,"laser_base2",137,[[3,1,-643,[234],[1],235]],[1,-2.078171768005177e-8,0.0000016899934962566476,0.014305144548416138]],[4,"laser_base1",137,[[3,1,-644,[236],[1],237]],[1,-2.2032313751196853e-8,0.0000016899934962566476,-0.014305144548416138]],[50,"laser_wall_2",134,[139],[1,7.933,0,1.394],[3,0,0.7071067811865476,0,0.7071067811865475],[1,120,120,120],[1,0,90.00000000000003,0]],[40,"Nova",22,[-645],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[42,1,false,216,[244],[9],[12,3,1,2.5],[0],[0],[0],[0],[0],[0],[0],[2,0.25],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[28,[[39],[13,0.5,[4,4294943551]]]]]],[43,3,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[44,true,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-646],[38,245]],[40,"Glow",22,[-647],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[42,1,false,218,[246],[9],[2,5],[0],[0],[0],[0],[0],[0],[0],[2,0.5],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[28,[[39],[13,0.5,[4,4294943551]]]]]],[43,3,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[67,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-648],[38,247]],[40,"Nova",23,[-649],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[42,1,false,220,[250],[9],[12,3,1,2.5],[0],[0],[0],[0],[0],[0],[0],[2,0.25],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[28,[[39],[13,0.5,[4,4294943551]]]]]],[43,3,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[44,true,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-650],[38,251]],[40,"Glow",23,[-651],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[42,1,false,222,[252],[9],[2,5],[0],[0],[0],[0],[0],[0],[0],[2,0.5],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[28,[[39],[13,0.5,[4,4294943551]]]]]],[43,3,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[67,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-652],[38,253]],[40,"Nova",24,[-653],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[42,1,false,224,[256],[9],[12,3,1,2.5],[0],[0],[0],[0],[0],[0],[0],[2,0.25],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[28,[[39],[13,0.5,[4,4294943551]]]]]],[43,3,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[44,true,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-654],[38,257]],[40,"Glow",24,[-655],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[42,1,false,226,[258],[9],[2,5],[0],[0],[0],[0],[0],[0],[0],[2,0.5],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[28,[[39],[13,0.5,[4,4294943551]]]]]],[43,3,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[67,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-656],[38,259]],[40,"Nova",25,[-657],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[42,1,false,228,[262],[9],[12,3,1,2.5],[0],[0],[0],[0],[0],[0],[0],[2,0.25],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[28,[[39],[13,0.5,[4,4294943551]]]]]],[43,3,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[44,true,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-658],[38,263]],[40,"Glow",25,[-659],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[42,1,false,230,[264],[9],[2,5],[0],[0],[0],[0],[0],[0],[0],[2,0.5],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[28,[[39],[13,0.5,[4,4294943551]]]]]],[43,3,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[67,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-660],[38,265]],[40,"Nova",26,[-661],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[42,1,false,232,[268],[9],[12,3,1,2.5],[0],[0],[0],[0],[0],[0],[0],[2,0.25],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[28,[[39],[13,0.5,[4,4294943551]]]]]],[43,3,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[44,true,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-662],[38,269]],[40,"Glow",26,[-663],[3,0.7071067811865475,0,0,0.7071067811865476],[1,90,0,0]],[42,1,false,234,[270],[9],[2,5],[0],[0],[0],[0],[0],[0],[0],[2,0.5],[0],[0],[0],[[21,[2,1]]],[22,true,[20,1,[28,[[39],[13,0.5,[4,4294943551]]]]]],[43,3,[2,1]],[29,[0],[0],[0],[0]],[23,[0],[0],[0],[2,1]],[24,[0],[0],[0]],[37,[0],[0],[0],[0]],[25,[0],[0],[0]],[67,3,3,1,[15,1,[16,[0,1],[[30,1,1,1,1],[31,1,1,1,1,1]]]],[0]],[26,[2,1],[0],[9],[9],-664],[38,271]],[7,"Tail0_M",76,[-665],[1,-0.003016774309799075,-0.0010064324596896768,4.4113056957284513e-11],[3,-0.13222044449472428,0.9912203357768733,1.899605991128237e-9,-2.5339324590359113e-10],[1,-2.1960685843697459e-7,-179.9999999999998,-15.19584442452546]],[7,"Tail1_M",236,[-666],[1,0.0032178927212953568,-1.1102229998097382e-18,-1.5827465746491744e-16],[3,7.854134306970377e-17,6.62973558865667e-17,-0.04753538670956306,0.9988695545517303],[1,9.393584386234256e-15,8.05274822932461e-15,-5.449207570713341]],[7,"Tail2_M",237,[-667],[1,0.002976355142891407,-5.551115205843844e-18,1.0832962131501755e-12],[3,-1.3949894977543174e-17,-3.883391342022682e-17,-0.11471089869868772,0.993398917716211],[1,-2.155174162256571e-15,-4.728473690825402e-15,-13.173900830243293]],[7,"Tail3_M",238,[-668],[1,0.003203141037374735,4.440891999238953e-18,3.920579572797012e-12],[3,-9.969521051823741e-17,-9.806948956650378e-17,-0.1655651210611257,0.9861988596059187],[1,-1.3888595449279292e-14,-1.3726848857505547e-14,-19.060130128725042]],[7,"Tail4_M",239,[-669],[1,0.0028079531621187925,0,6.5790389629227786e-12],[3,-8.251598561738025e-17,-1.135794569833411e-16,-0.06482256304208014,0.9978968059477171],[1,-1.0366549825034899e-14,-1.3716080958521048e-14,-7.433330535637716]],[19,"Tail5_M",240,[[14,"Tail6_M",-670,[1,0.0030258502811193466,8.881783998477905e-18,9.688655260020607e-12]]],[1,0.002689178567379713,4.440891999238953e-18,7.303118179646795e-12],[3,9.537444787153138e-17,-2.118270460406824e-16,-0.10054238934768282,0.9949327755905215],[1,8.60721837145069e-15,-2.3527419865239222e-14,-11.54080902638327]],[7,"Hip_R",76,[-671],[1,-0.00007880734483478591,0.0005406050477176905,-0.003936111461371183],[3,0.9649268585378106,0.23634742681996387,-0.11070779936605146,0.02828134840243218],[1,173.12485222053104,14.725639548400835,26.73431895575666]],[7,"Knee_R",242,[-672],[1,0.006485617719590664,9.992007618673103e-18,9.992007618673103e-18],[3,1.0421712215713451e-17,9.1641098275595e-18,-0.7509635080199943,0.6603437056732683],[1,180,180,-82.65218201681442]],[7,"Ankle_R",243,[-673],[1,0.006850753910839558,-9.992007618673103e-18,-1.4432898790731443e-17],[3,-0.107779091379776,0.03794360473263759,0.4382270207142593,0.8915722228945604],[1,-20.825588126741046,14.81324250428513,50.646009467453176]],[19,"Toes1_R",244,[[14,"Toes2_R",-674,[1,0.0028587731067091227,-0.0018769684247672558,-2.8829633125226906e-11]]],[1,0.003821877297013998,9.992007618673103e-18,1.4055525840439564e-11],[3,7.078807208851528e-26,7.338928554393833e-26,0.7197470906365884,0.6942363614217905],[1,-180,180,87.93279256115314]],[55,"RootPart1_M",76,[-675],[1,0.0020652245730161667,2.2204459996194763e-18,-6.089342295085281e-19]],[55,"RootPart2_M",246,[-676],[1,0.0020652245730161667,2.2204459996194763e-18,-6.089341778097398e-19]],[7,"Spine2_M",247,[141],[1,0.0020652245730161667,4.440891999238953e-18,2.7589170037440396e-18],[3,2.833542290373483e-16,-5.276558712844762e-17,-0.13887424912163487,0.9903100236445666],[1,3.257203985875381e-14,-1.5379762679065733e-15,-15.965418280697603]],[7,"Neck_M",141,[-677],[1,0.002901608357205987,-0.0031024303752928972,-9.727658892874631e-18],[3,-2.4871766108048305e-24,2.1821083289339757e-24,-0.6595017750111039,0.7517030056858913],[1,-3.791516639546766e-22,0,-82.52377277072583]],[55,"NeckPart1_M",249,[175],[1,0.005839296150952578,5.551115205843844e-18,2.898164867815023e-11]],[19,"Jaw_M",175,[[14,"JawEnd_M",-678,[1,0.01144465059041977,-4.440891999238953e-18,2.616274463397792e-18]]],[1,-0.0070828660391271114,0.001565893879160285,-4.563028938995164e-18],[3,-4.0602511795263196e-25,8.309202330691217e-25,0.7944917325602083,0.6072749681103925],[1,-180,180,74.7854503251938]],[7,"Scapula_R",141,[-679],[1,0.0009082318283617496,-0.0016960602952167392,-0.0035904867108911276],[3,0.7485383193052008,0.6073311003787559,-0.20668350270817637,0.16769391388107713],[1,112.31256356364936,70.98174103154757,57.129780034201545]],[7,"Shoulder_R",252,[-680],[1,0.002976213349029422,0,-8.881783998477905e-18],[3,-0.07353511641712662,0.25579661788485253,-0.2663195499695608,0.9264095067712771],[1,0.0000012480393304219223,30.871376804796846,-32.07723760154569]],[7,"Elbow_R",253,[-681],[1,0.006145196035504341,-5.551115205843844e-18,1.0769163656501374e-16],[3,8.504070203628985e-25,6.16430870102796e-26,0.3120392175523727,0.9500692220618996],[1,1.1223607321790314e-22,-2.942762314065395e-23,36.36433252877887]],[7,"Wrist_R",254,[-682],[1,0.003922537434846163,-7.77156120546332e-18,2.0003202219620597e-11],[3,1.26163860488356e-8,3.485806502145198e-9,0.26631405719129686,0.9638863122496919],[1,0.0000014998981938610756,2.921850661819311e-14,30.890097833571968]],[19,"Fingers1_R",255,[[14,"Fingers2_R",-683,[1,0.0024803609121590853,-0.0011090633925050497,4.9960034784643064e-17]]],[1,0.0013398798182606697,1.1102229998097382e-18,2.8932013035332105e-12],[3,-1.0268690676414758e-8,-4.1971217162257e-9,0.37834661793140156,0.9256639977334487],[1,-0.0000012712012910317389,-1.2653603427533027e-14,44.46261181934115]],[7,"Scapula_L",141,[-684],[1,0.0009082318283617496,-0.0016960602952167392,0.0035904867108911276],[3,-0.6073310985082828,0.7485383169998342,0.16769391336460931,0.20668351697278872],[1,-67.68743656021654,109.01825758625266,-57.12977896045119]],[7,"Shoulder_L",257,[-685],[1,-0.002976213349029422,-2.2204459996194763e-18,-6.661337998858429e-18],[3,-0.08087501841085962,0.2535716049327198,-0.29290211802618116,0.9183512518773331],[1,-0.0000020023668605326484,30.871375957102188,-35.37948463187456]],[7,"Elbow_L",258,[-686],[1,-0.006145196035504341,2.1649348186097164e-17,2.5022001831631613e-11],[3,3.698432393575249e-24,7.844895137691728e-26,0.4660808189363135,0.8847421490014223],[1,6.556099890129191e-22,-3.352136588885891e-22,55.56038648837976]],[7,"Wrist_L",259,[-687],[1,-0.003922537434846163,1.1102230411687688e-17,-2.0801102160183937e-11],[3,-2.2213494740521317e-8,2.682952490230911e-9,-0.11990886018104767,0.9927849038185872],[1,-0.000002563978345591965,-1.238952164628575e-14,-13.773685345369223]],[19,"Fingers1_L",260,[[14,"Fingers2_L",-688,[1,-0.0024803609121590853,0.0011090633925050497,-1.7181324071802173e-11]]],[1,-0.0013398798182606697,3.3306689994292145e-18,-3.0510691195750894e-11],[3,1.202641542986473e-8,-1.7758621256120527e-8,0.5607324843663741,0.8279970295697404],[1,0.000006148774687692887,-0.0000066217698935251255,68.21293812945635]],[7,"Hip_L",76,[-689],[1,-0.00007880722841946408,0.0005406050477176905,0.003936111461371183],[3,-0.33800700071914674,0.9337119991241997,0.028422765236197228,0.11456577400194808],[1,-9.622341407618702,162.62735726022657,-38.65942560522658]],[7,"Knee_L",262,[-690],[1,-0.006485617719590664,-5.551114999048691e-19,1.1102229998097382e-18],[3,-1.7336686139568426e-19,-9.811546734126506e-18,-0.719488810323054,0.6945040329759912],[1,-179.99999999999997,-179.99999999999997,-87.97541642889963]],[7,"Ankle_L",263,[-691],[1,-0.006850753910839558,9.992007618673103e-18,7.77156120546332e-18],[3,-0.10166416476507739,0.05983485747743264,0.6161200500698334,0.7787684324208453],[1,-46.51448788453161,43.07919569002581,71.34531796373011]],[19,"Toes1_L",264,[[14,"Toes2_L",-692,[1,-0.0028587731067091227,0.0018769684247672558,2.8829636594673858e-11]]],[1,-0.003821877297013998,0,2.3568615808988724e-11],[3,-0.00020272489692942466,0.00016227147528271118,0.6862465063574965,0.727369002008413],[1,-0.5101740052366177,0.5068947396755507,86.66730611092152]],[18,"Cat_model",8,[[49,1,-693,[274,275,276,277],[58,true],8,278,279]]],[7,"Root_M Socket",8,[-694],[1,1.0018953194960331e-25,0.01481025293469429,-0.0051376777701079845],[3,-0.6968476547856596,0.12001394093906889,-0.6968476547856595,0.12001394093906896],[1,-180,-90,-19.543700609739716]],[18,"Nacklace_03",267,[[159,-695,[280],[1],77,281,282]]],[163,8,16,142,155,178],[48,"BgSound",10,[-696]],[99,true,false,270],[48,"catAngrySoound",10,[-697]],[59,false,272],[48,"electricSound",10,[-698]],[99,true,false,274],[48,"electric2Sund",10,[-699]],[59,false,276],[48,"winSound",10,[-700]],[59,false,278],[48,"loseSoound",10,[-701]],[59,false,280],[48,"eatSound",10,[-702]],[59,false,282],[48,"clockSound",10,[-703]],[59,false,284],[112,"Camera",6,[-704],[1,0,0,1000]],[157,0,3,240,2000,6,41943040,286,[4,4278190080]],[164,16],[113,"GameController","9fgkvo20FBAKynqRhhqW/W",14,[288]],[7,"Spine2_M",182,[151],[1,0.0529840886592865,1.9317880734356842e-16,7.913655945448904e-18],[3,1.59653115827679e-18,-1.1437177449015343e-16,0.006651127207577884,0.9999778810088095],[1,2.701387872169356e-16,-1.3108126613390177e-14,0.762168655473236]],[7,"Neck_M",151,[-705],[1,0.04995439574122429,4.440892164675075e-17,4.32763757305452e-17],[3,7.771092302403045e-17,3.141471072609305e-17,0.005056470487761085,0.9999872159713875],[1,8.887153843039344e-15,3.554968494150405e-15,0.5794313055199013]],[19,"Head_M",291,[[14,"HeadEnd_M",-706,[1,0.12103284150362015,-6.300515611808204e-17,-3.361059491057321e-17]]],[1,0.06877291202545166,6.883382540917734e-16,8.258370727148945e-17],[3,-1.6069880936063149e-16,-1.4475227627136765e-16,-0.02972651022747891,0.9995580696436278],[1,-1.8933135374120044e-14,-1.715778760004779e-14,-3.406909038336909]],[7,"Scapula_R",151,[-707],[1,0.019262749701738358,0.01245173066854477,-0.0370938740670681],[3,0.0013493490321890777,0.7071458057518473,-0.0014779679385766669,0.7070649222493876],[1,0.22909391510412205,90.00657468872008,-0.01040866958080289]],[7,"Shoulder_R",293,[-708],[1,0.02444273978471756,-7.327472253693609e-17,-1.0658140798173486e-16],[3,-0.0000021503426025227283,-0.00005831555473670341,-0.009419804220521624,0.9999556309572536],[1,-0.00030940264875414775,-0.00668568147479377,-1.0794459992370342]],[19,"Elbow_R",294,[[14,"Wrist_R",-709,[1,0.0816095843911171,3.552713599391162e-17,-3.552713599391162e-17]]],[1,0.09338455647230148,3.996803047469241e-17,7.815970051009455e-16],[3,-4.4445069374134324e-17,-3.299727683376842e-17,0.020208222761823387,0.9997957930161583],[1,-5.019678031168802e-15,-3.6805222124929556e-15,2.315849391111249]],[7,"Scapula_L",151,[-710],[1,0.019262749701738358,0.01245173066854477,0.0370938740670681],[3,0.7071458057490803,-0.0013493440263249903,-0.7070649222466209,-0.0014779751563207923],[1,-179.7709059056131,89.99342530928352,0.010409660028795393]],[7,"Shoulder_L",296,[-711],[1,-0.02444273978471756,9.992006956928613e-17,-3.552713599391162e-17],[3,-0.0000021503426025227283,-0.00005831555473670341,-0.009419804220521624,0.9999556309572536],[1,-0.00030940264875414775,-0.00668568147479377,-1.0794459992370342]],[19,"Elbow_L",297,[[14,"Wrist_L",-712,[1,-0.0816095843911171,-1.776356799695581e-17,8.171241609471918e-16]]],[1,-0.09338455647230148,-8.881783998477905e-18,-1.0302869372059921e-15],[3,-3.7509785296623065e-17,-3.274865612050279e-17,0.020208222761823387,0.9997957930161583],[1,-4.225042019150996e-15,-3.6680880197500774e-15,2.315849391111249]],[7,"Hip_R",17,[-713],[1,-0.013682468794286251,-0.0012203477090224624,-0.05554671958088875],[3,0.16618651318955646,0.9858849743909147,-0.00017639259927130745,0.02031819356570466],[1,0.4306378076991254,177.56614860686935,19.127681958936297]],[7,"Knee_R",299,[-714],[1,0.05022026598453522,-1.332267682489747e-16,-2.5518253959563864e-13],[3,-9.518974254788701e-17,5.4738645451065224e-21,-0.3690863896759494,0.9293950919581904],[1,-1.393381721456747e-14,-5.532797704604732e-15,-43.318567206855924]],[7,"Ankle_R",300,[-715],[1,0.043153680860996246,-3.2267743164948737e-13,-1.600231042510683e-13],[3,-0.011484564534798845,0.01799553299819029,0.1906909090532255,0.9814179755710671],[1,-1.816857587635506,2.453397727152498,21.95520760854224]],[19,"Toes_R",301,[[62,"ToesEnd_R",-716,[1,0.008133307099342346,-3.604894296483155e-15,2.1022124485625682e-8],[3,1.754164031807122e-7,-0.0000012923479744120337,2.2667127506559457e-13,0.9999999999991496],[1,0.000020101239119256964,-0.0001480921691922244,-3.1808627288522512e-15]]],[1,0.02468482218682766,0.02989344485104084,7.938168455901007e-10],[3,0.002656072892099482,-0.0023199296978108444,0.6578327536948384,0.7531557816077993],[1,3.001861554994413,-2.9745621326411364,82.25971987154263]],[7,"Hip_L",17,[-717],[1,-0.013682468794286251,-0.0012203477090224624,0.05554671958088875],[3,0.9858849743909097,-0.16618651318955563,-0.020318193565704554,-0.0001763926283751373],[1,-179.56936218882086,2.433851393716727,-19.12768195886437]],[7,"Knee_L",303,[-718],[1,-0.05022026598453522,3.9867921464153966e-11,2.5518253959563864e-13],[3,-1.0161553971190601e-16,-6.77521811173757e-18,-0.3690863896759494,0.9293950919581904],[1,-1.52686202586018e-14,-6.898920371138734e-15,-43.318567206855924]],[7,"Ankle_L",304,[-719],[1,-0.043153680860996246,3.4580747987345006e-11,-7.836664802328419e-13],[3,-0.011484564567432416,0.017995533049324882,0.19069089469391517,0.981417978359782],[1,-1.816857543390386,2.4533976909996236,21.95520593294532]],[19,"Toes_L",305,[[14,"ToesEnd_L",-720,[1,-0.008133307099342346,-5.4400929265423855e-17,-2.8360424902604264e-13]]],[1,-0.02468482218682766,-0.02989344485104084,-7.796541190430162e-10],[3,0.002657055192385141,-0.002320786736754183,0.6578327506699668,0.7531557781446095],[1,3.0029692206456007,-2.975659625233852,82.25971211842969]],[18,"soldier_gun",82,[[49,1,-721,[316],[1],5,317,318]]],[18,"soldier_Jacket",82,[[49,1,-722,[319],[1],5,320,321]]],[18,"soldier_body",82,[[49,1,-723,[322],[1],5,323,324]]],[18,"soldier_hat",82,[[49,1,-724,[325],[1],5,326,327]]],[7,"Tail0_M",84,[-725],[1,-0.003016774309799075,-0.0010064324596896768,4.4113056957284513e-11],[3,-0.13222044449472428,0.9912203357768733,1.899605991128237e-9,-2.5339324590359113e-10],[1,-2.1960685843697459e-7,-179.9999999999998,-15.19584442452546]],[7,"Tail1_M",311,[-726],[1,0.0032178927212953568,-1.1102229998097382e-18,-1.5827465746491744e-16],[3,7.854134306970377e-17,6.62973558865667e-17,-0.04753538670956306,0.9988695545517303],[1,9.393584386234256e-15,8.05274822932461e-15,-5.449207570713341]],[7,"Tail2_M",312,[-727],[1,0.002976355142891407,-5.551115205843844e-18,1.0832962131501755e-12],[3,-1.3949894977543174e-17,-3.883391342022682e-17,-0.11471089869868772,0.993398917716211],[1,-2.155174162256571e-15,-4.728473690825402e-15,-13.173900830243293]],[7,"Tail3_M",313,[-728],[1,0.003203141037374735,4.440891999238953e-18,3.920579572797012e-12],[3,-9.969521051823741e-17,-9.806948956650378e-17,-0.1655651210611257,0.9861988596059187],[1,-1.3888595449279292e-14,-1.3726848857505547e-14,-19.060130128725042]],[7,"Tail4_M",314,[-729],[1,0.0028079531621187925,0,6.5790389629227786e-12],[3,-8.251598561738025e-17,-1.135794569833411e-16,-0.06482256304208014,0.9978968059477171],[1,-1.0366549825034899e-14,-1.3716080958521048e-14,-7.433330535637716]],[19,"Tail5_M",315,[[14,"Tail6_M",-730,[1,0.0030258502811193466,8.881783998477905e-18,9.688655260020607e-12]]],[1,0.002689178567379713,4.440891999238953e-18,7.303118179646795e-12],[3,9.537444787153138e-17,-2.118270460406824e-16,-0.10054238934768282,0.9949327755905215],[1,8.60721837145069e-15,-2.3527419865239222e-14,-11.54080902638327]],[7,"Hip_R",84,[-731],[1,-0.00007880734483478591,0.0005406050477176905,-0.003936111461371183],[3,0.9649268585378106,0.23634742681996387,-0.11070779936605146,0.02828134840243218],[1,173.12485222053104,14.725639548400835,26.73431895575666]],[7,"Knee_R",317,[-732],[1,0.006485617719590664,9.992007618673103e-18,9.992007618673103e-18],[3,1.0421712215713451e-17,9.1641098275595e-18,-0.7509635080199943,0.6603437056732683],[1,180,180,-82.65218201681442]],[7,"Ankle_R",318,[-733],[1,0.006850753910839558,-9.992007618673103e-18,-1.4432898790731443e-17],[3,-0.107779091379776,0.03794360473263759,0.4382270207142593,0.8915722228945604],[1,-20.825588126741046,14.81324250428513,50.646009467453176]],[19,"Toes1_R",319,[[14,"Toes2_R",-734,[1,0.0028587731067091227,-0.0018769684247672558,-2.8829633125226906e-11]]],[1,0.003821877297013998,9.992007618673103e-18,1.4055525840439564e-11],[3,7.078807208851528e-26,7.338928554393833e-26,0.7197470906365884,0.6942363614217905],[1,-180,180,87.93279256115314]],[55,"RootPart1_M",84,[-735],[1,0.0020652245730161667,2.2204459996194763e-18,-6.089342295085281e-19]],[55,"RootPart2_M",321,[-736],[1,0.0020652245730161667,2.2204459996194763e-18,-6.089341778097398e-19]],[7,"Spine2_M",322,[152],[1,0.0020652245730161667,4.440891999238953e-18,2.7589170037440396e-18],[3,2.833542290373483e-16,-5.276558712844762e-17,-0.13887424912163487,0.9903100236445666],[1,3.257203985875381e-14,-1.5379762679065733e-15,-15.965418280697603]],[7,"Neck_M",152,[-737],[1,0.002901608357205987,-0.0031024303752928972,-9.727658892874631e-18],[3,-2.4871766108048305e-24,2.1821083289339757e-24,-0.6595017750111039,0.7517030056858913],[1,-3.791516639546766e-22,0,-82.52377277072583]],[55,"NeckPart1_M",324,[185],[1,0.005839296150952578,5.551115205843844e-18,2.898164867815023e-11]],[19,"Jaw_M",185,[[14,"JawEnd_M",-738,[1,0.01144465059041977,-4.440891999238953e-18,2.616274463397792e-18]]],[1,-0.0070828660391271114,0.001565893879160285,-4.563028938995164e-18],[3,-4.0602511795263196e-25,8.309202330691217e-25,0.7944917325602083,0.6072749681103925],[1,-180,180,74.7854503251938]],[7,"Scapula_R",152,[-739],[1,0.0009082318283617496,-0.0016960602952167392,-0.0035904867108911276],[3,0.7485383193052008,0.6073311003787559,-0.20668350270817637,0.16769391388107713],[1,112.31256356364936,70.98174103154757,57.129780034201545]],[7,"Shoulder_R",327,[-740],[1,0.002976213349029422,0,-8.881783998477905e-18],[3,-0.07353511641712662,0.25579661788485253,-0.2663195499695608,0.9264095067712771],[1,0.0000012480393304219223,30.871376804796846,-32.07723760154569]],[7,"Elbow_R",328,[-741],[1,0.006145196035504341,-5.551115205843844e-18,1.0769163656501374e-16],[3,8.504070203628985e-25,6.16430870102796e-26,0.3120392175523727,0.9500692220618996],[1,1.1223607321790314e-22,-2.942762314065395e-23,36.36433252877887]],[7,"Wrist_R",329,[-742],[1,0.003922537434846163,-7.77156120546332e-18,2.0003202219620597e-11],[3,1.26163860488356e-8,3.485806502145198e-9,0.26631405719129686,0.9638863122496919],[1,0.0000014998981938610756,2.921850661819311e-14,30.890097833571968]],[19,"Fingers1_R",330,[[14,"Fingers2_R",-743,[1,0.0024803609121590853,-0.0011090633925050497,4.9960034784643064e-17]]],[1,0.0013398798182606697,1.1102229998097382e-18,2.8932013035332105e-12],[3,-1.0268690676414758e-8,-4.1971217162257e-9,0.37834661793140156,0.9256639977334487],[1,-0.0000012712012910317389,-1.2653603427533027e-14,44.46261181934115]],[7,"Scapula_L",152,[-744],[1,0.0009082318283617496,-0.0016960602952167392,0.0035904867108911276],[3,-0.6073310985082828,0.7485383169998342,0.16769391336460931,0.20668351697278872],[1,-67.68743656021654,109.01825758625266,-57.12977896045119]],[7,"Shoulder_L",332,[-745],[1,-0.002976213349029422,-2.2204459996194763e-18,-6.661337998858429e-18],[3,-0.08087501841085962,0.2535716049327198,-0.29290211802618116,0.9183512518773331],[1,-0.0000020023668605326484,30.871375957102188,-35.37948463187456]],[7,"Elbow_L",333,[-746],[1,-0.006145196035504341,2.1649348186097164e-17,2.5022001831631613e-11],[3,3.698432393575249e-24,7.844895137691728e-26,0.4660808189363135,0.8847421490014223],[1,6.556099890129191e-22,-3.352136588885891e-22,55.56038648837976]],[7,"Wrist_L",334,[-747],[1,-0.003922537434846163,1.1102230411687688e-17,-2.0801102160183937e-11],[3,-2.2213494740521317e-8,2.682952490230911e-9,-0.11990886018104767,0.9927849038185872],[1,-0.000002563978345591965,-1.238952164628575e-14,-13.773685345369223]],[19,"Fingers1_L",335,[[14,"Fingers2_L",-748,[1,-0.0024803609121590853,0.0011090633925050497,-1.7181324071802173e-11]]],[1,-0.0013398798182606697,3.3306689994292145e-18,-3.0510691195750894e-11],[3,1.202641542986473e-8,-1.7758621256120527e-8,0.5607324843663741,0.8279970295697404],[1,0.000006148774687692887,-0.0000066217698935251255,68.21293812945635]],[7,"Hip_L",84,[-749],[1,-0.00007880722841946408,0.0005406050477176905,0.003936111461371183],[3,-0.33800700071914674,0.9337119991241997,0.028422765236197228,0.11456577400194808],[1,-9.622341407618702,162.62735726022657,-38.65942560522658]],[7,"Knee_L",337,[-750],[1,-0.006485617719590664,-5.551114999048691e-19,1.1102229998097382e-18],[3,-1.7336686139568426e-19,-9.811546734126506e-18,-0.719488810323054,0.6945040329759912],[1,-179.99999999999997,-179.99999999999997,-87.97541642889963]],[7,"Ankle_L",338,[-751],[1,-0.006850753910839558,9.992007618673103e-18,7.77156120546332e-18],[3,-0.10166416476507739,0.05983485747743264,0.6161200500698334,0.7787684324208453],[1,-46.51448788453161,43.07919569002581,71.34531796373011]],[19,"Toes1_L",339,[[14,"Toes2_L",-752,[1,-0.0028587731067091227,0.0018769684247672558,2.8829636594673858e-11]]],[1,-0.003821877297013998,0,2.3568615808988724e-11],[3,-0.00020272489692942466,0.00016227147528271118,0.6862465063574965,0.727369002008413],[1,-0.5101740052366177,0.5068947396755507,86.66730611092152]],[18,"Cat_model",83,[[49,1,-753,[328,329,330,331],[58,true],83,332,333]]],[82,"LaserController","252+iqgvVFK61BOQRNHXeq",14,[[165,-754,16,269,138,140,136,164,162,166,165,[169,170,171,172,173]]]],[82,"CubeController","b3nb8h/T5GgIPN/YxYu1K3",14,[[166,-755,[28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,18,18,60,61,62,63,64,65,66,67,68,69,70,71,72,73]]]],[82,"Responsive","93m7EM2HBCV798YB+7/26R",14,[[167,-756,143,142]]]],0,[0,-1,28,0,-2,29,0,-3,30,0,-4,100,0,-5,31,0,-6,32,0,-7,33,0,-8,34,0,-9,35,0,-10,36,0,-11,37,0,-12,38,0,-13,39,0,-14,40,0,-15,41,0,-16,42,0,-17,43,0,-18,44,0,-19,45,0,-20,46,0,-21,47,0,-22,48,0,-23,49,0,-24,50,0,-1,51,0,-2,52,0,-3,53,0,-4,54,0,-5,55,0,-6,56,0,-7,57,0,-8,58,0,-9,59,0,-10,18,0,-11,60,0,-12,61,0,-13,62,0,-14,63,0,-15,64,0,-16,65,0,-17,66,0,-18,67,0,-19,68,0,-20,69,0,-21,70,0,-22,71,0,-23,72,0,-24,73,0,-1,101,0,-2,102,0,-3,103,0,-4,104,0,-5,105,0,-6,106,0,-7,107,0,-8,108,0,-9,109,0,-10,110,0,-11,111,0,-12,112,0,-13,113,0,-14,114,0,-15,115,0,-16,116,0,-17,117,0,-18,118,0,-19,119,0,-20,120,0,-21,121,0,-22,122,0,-23,123,0,-24,124,0,9,183,0,0,5,0,0,5,0,0,5,0,18,85,0,19,83,0,20,142,0,21,16,0,0,5,0,2,5,0,-2,17,0,-3,82,0,-4,183,0,-5,85,0,0,6,0,17,287,0,0,6,0,0,6,0,-1,286,0,-2,143,0,-3,144,0,-4,145,0,-5,146,0,-6,78,0,-7,27,0,-8,79,0,-9,11,0,-10,81,0,-1,86,0,-2,87,0,-3,88,0,-4,89,0,-5,90,0,-6,91,0,-7,92,0,-8,93,0,-9,94,0,-10,95,0,-11,96,0,-12,97,0,-13,98,0,9,176,0,9,177,0,0,8,0,0,8,0,0,8,0,-4,269,0,-1,76,0,-2,266,0,-3,77,0,-4,267,0,-5,176,0,-6,177,0,-1,125,0,-2,126,0,-3,20,0,-4,198,0,-5,200,0,-6,155,0,-7,202,0,-8,203,0,-9,204,0,-10,205,0,-11,207,0,-1,16,0,-1,270,0,-2,272,0,-3,274,0,-4,276,0,-5,278,0,-6,280,0,-7,282,0,-8,284,0,0,11,0,0,11,0,-1,148,0,-2,149,0,-3,80,0,-4,180,0,-5,181,0,-6,150,0,15,197,0,15,197,0,16,12,0,-1,142,0,-1,153,0,-2,186,0,-3,15,0,-4,174,0,9,22,0,13,22,0,9,23,0,13,23,0,9,24,0,13,24,0,9,26,0,13,26,0,9,25,0,13,25,0,-2,289,0,-3,342,0,-4,343,0,-6,344,0,-1,154,0,-3,99,0,-5,134,0,-6,21,0,-1,182,0,2,17,0,2,17,0,2,17,0,-5,299,0,-6,303,0,0,18,0,0,18,0,0,18,0,-1,191,0,-2,192,0,-3,193,0,-4,194,0,2,19,0,0,20,0,0,20,0,0,20,0,-1,196,0,-1,22,0,-2,23,0,-3,24,0,-4,25,0,-5,26,0,-1,169,0,-1,216,0,-2,218,0,-1,170,0,-1,220,0,-2,222,0,-1,171,0,-1,224,0,-2,226,0,-1,172,0,-1,228,0,-2,230,0,-1,173,0,-1,232,0,-2,234,0,0,27,0,0,27,0,-3,178,0,0,27,0,0,28,0,0,28,0,0,28,0,0,29,0,0,29,0,0,29,0,0,30,0,0,30,0,0,30,0,0,31,0,0,31,0,0,31,0,0,32,0,0,32,0,0,32,0,0,33,0,0,33,0,0,33,0,0,34,0,0,34,0,0,34,0,0,35,0,0,35,0,0,35,0,0,36,0,0,36,0,0,36,0,0,37,0,0,37,0,0,37,0,0,38,0,0,38,0,0,38,0,0,39,0,0,39,0,0,39,0,0,40,0,0,40,0,0,40,0,0,41,0,0,41,0,0,41,0,0,42,0,0,42,0,0,42,0,0,43,0,0,43,0,0,43,0,0,44,0,0,44,0,0,44,0,0,45,0,0,45,0,0,45,0,0,46,0,0,46,0,0,46,0,0,47,0,0,47,0,0,47,0,0,48,0,0,48,0,0,48,0,0,49,0,0,49,0,0,49,0,0,50,0,0,50,0,0,50,0,0,51,0,0,51,0,0,51,0,0,52,0,0,52,0,0,52,0,0,53,0,0,53,0,0,53,0,0,54,0,0,54,0,0,54,0,0,55,0,0,55,0,0,55,0,0,56,0,0,56,0,0,56,0,0,57,0,0,57,0,0,57,0,0,58,0,0,58,0,0,58,0,0,59,0,0,59,0,0,59,0,0,60,0,0,60,0,0,60,0,0,61,0,0,61,0,0,61,0,0,62,0,0,62,0,0,62,0,0,63,0,0,63,0,0,63,0,0,64,0,0,64,0,0,64,0,0,65,0,0,65,0,0,65,0,0,66,0,0,66,0,0,66,0,0,67,0,0,67,0,0,67,0,0,68,0,0,68,0,0,68,0,0,69,0,0,69,0,0,69,0,0,70,0,0,70,0,0,70,0,0,71,0,0,71,0,0,71,0,0,72,0,0,72,0,0,72,0,0,73,0,0,73,0,0,73,0,-1,162,0,-2,163,0,-3,164,0,-4,206,0,-1,165,0,-2,133,0,-3,166,0,-4,208,0,-1,236,0,-2,242,0,-3,246,0,-4,262,0,0,77,0,0,78,0,-1,179,0,-2,147,0,0,79,0,0,79,0,0,79,0,0,80,0,0,80,0,0,80,0,0,81,0,0,81,0,0,81,0,-1,307,0,-2,308,0,-3,309,0,-4,310,0,-1,84,0,-2,341,0,-1,311,0,-2,317,0,-3,321,0,-4,337,0,0,85,0,0,85,0,0,85,0,0,86,0,0,86,0,0,86,0,0,87,0,0,87,0,0,87,0,0,88,0,0,88,0,0,88,0,0,89,0,0,89,0,0,89,0,0,90,0,0,90,0,0,90,0,0,91,0,0,91,0,0,91,0,0,92,0,0,92,0,0,92,0,0,93,0,0,93,0,0,93,0,0,94,0,0,94,0,0,94,0,0,95,0,0,95,0,0,95,0,0,96,0,0,96,0,0,96,0,0,97,0,0,97,0,0,97,0,0,98,0,0,98,0,0,98,0,-1,187,0,-2,188,0,-3,189,0,0,100,0,0,100,0,0,100,0,0,101,0,0,101,0,0,101,0,0,102,0,0,102,0,0,102,0,0,103,0,0,103,0,0,103,0,0,104,0,0,104,0,0,104,0,0,105,0,0,105,0,0,105,0,0,106,0,0,106,0,0,106,0,0,107,0,0,107,0,0,107,0,0,108,0,0,108,0,0,108,0,0,109,0,0,109,0,0,109,0,0,110,0,0,110,0,0,110,0,0,111,0,0,111,0,0,111,0,0,112,0,0,112,0,0,112,0,0,113,0,0,113,0,0,113,0,0,114,0,0,114,0,0,114,0,0,115,0,0,115,0,0,115,0,0,116,0,0,116,0,0,116,0,0,117,0,0,117,0,0,117,0,0,118,0,0,118,0,0,118,0,0,119,0,0,119,0,0,119,0,0,120,0,0,120,0,0,120,0,0,121,0,0,121,0,0,121,0,0,122,0,0,122,0,0,122,0,0,123,0,0,123,0,0,123,0,0,124,0,0,124,0,0,124,0,0,125,0,0,125,0,-1,190,0,0,126,0,-2,195,0,0,127,0,0,127,0,0,127,0,0,128,0,0,128,0,0,128,0,0,129,0,0,129,0,0,129,0,0,130,0,0,130,0,0,130,0,0,131,0,0,131,0,0,131,0,0,132,0,0,132,0,0,132,0,0,133,0,0,133,0,0,133,0,-1,209,0,-2,212,0,-3,215,0,-1,210,0,-2,136,0,-3,211,0,0,136,0,0,136,0,-1,138,0,-2,213,0,-3,214,0,0,138,0,0,138,0,-1,140,0,-2,167,0,-3,168,0,0,140,0,0,140,0,-1,249,0,-2,252,0,-3,257,0,0,143,0,0,143,0,0,144,0,0,144,0,0,145,0,0,145,0,0,146,0,0,146,0,0,147,0,0,147,0,0,147,0,0,148,0,0,148,0,0,149,0,0,149,0,0,150,0,0,150,0,0,150,0,-1,291,0,-2,293,0,-3,296,0,-1,324,0,-2,327,0,-3,332,0,0,153,0,0,154,0,0,154,0,-1,156,0,-1,160,0,-2,161,0,0,160,0,0,160,0,0,161,0,0,161,0,0,162,0,0,163,0,0,163,0,0,164,0,0,165,0,0,166,0,0,167,0,0,167,0,0,168,0,0,168,0,3,169,0,3,170,0,3,171,0,3,172,0,3,173,0,2,175,0,-2,251,0,0,176,0,0,177,0,0,179,0,0,179,0,0,180,0,0,180,0,0,181,0,0,181,0,-1,290,0,2,182,0,-1,184,0,0,184,0,2,185,0,-2,326,0,0,186,0,0,190,0,2,191,0,2,192,0,2,193,0,2,194,0,0,195,0,0,196,0,-1,199,0,0,199,0,-1,201,0,0,201,0,0,206,0,0,208,0,0,210,0,0,211,0,0,213,0,0,214,0,-1,217,0,3,217,0,-1,219,0,3,219,0,-1,221,0,3,221,0,-1,223,0,3,223,0,-1,225,0,3,225,0,-1,227,0,3,227,0,-1,229,0,3,229,0,-1,231,0,3,231,0,-1,233,0,3,233,0,-1,235,0,3,235,0,-1,237,0,-1,238,0,-1,239,0,-1,240,0,-1,241,0,2,241,0,-1,243,0,-1,244,0,-1,245,0,2,245,0,-1,247,0,-1,248,0,-1,250,0,2,251,0,-1,253,0,-1,254,0,-1,255,0,-1,256,0,2,256,0,-1,258,0,-1,259,0,-1,260,0,-1,261,0,2,261,0,-1,263,0,-1,264,0,-1,265,0,2,265,0,0,266,0,-1,268,0,0,268,0,-1,271,0,-1,273,0,-1,275,0,-1,277,0,-1,279,0,-1,281,0,-1,283,0,-1,285,0,-1,287,0,-1,292,0,2,292,0,-1,294,0,-1,295,0,2,295,0,-1,297,0,-1,298,0,2,298,0,-1,300,0,-1,301,0,-1,302,0,2,302,0,-1,304,0,-1,305,0,-1,306,0,2,306,0,0,307,0,0,308,0,0,309,0,0,310,0,-1,312,0,-1,313,0,-1,314,0,-1,315,0,-1,316,0,2,316,0,-1,318,0,-1,319,0,-1,320,0,2,320,0,-1,322,0,-1,323,0,-1,325,0,2,326,0,-1,328,0,-1,329,0,-1,330,0,-1,331,0,2,331,0,-1,333,0,-1,334,0,-1,335,0,-1,336,0,2,336,0,-1,338,0,-1,339,0,-1,340,0,2,340,0,0,341,0,0,342,0,0,343,0,0,344,0,22,14,1,2,187,2,2,188,3,2,189,5,2,174,6,2,13,7,2,15,8,2,174,9,2,15,10,2,14,12,2,20,13,2,14,16,23,285,16,24,283,16,25,281,16,26,279,16,27,277,16,28,275,16,29,273,16,30,271,19,2,126,74,2,205,75,2,207,83,2,184,127,2,156,128,2,156,129,2,157,130,2,157,131,2,158,132,2,158,135,2,209,137,2,212,139,2,215,141,2,248,142,31,149,142,32,148,142,33,153,142,34,145,142,35,144,142,36,146,142,37,288,142,38,178,151,2,290,152,2,323,157,2,202,158,2,203,159,2,204,175,2,250,185,2,325,288,0,289,756],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,271,273,275,277,279,281,283,285],[-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,-1,1,39,14,14,14,14,-1,1,-1,12,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,4,-1,-2,-3,-4,1,8,-1,1,8,-1,1,8,-1,1,8,-1,-2,12,5,5,5,5,5,5,-1,12,5,5,5,5,40,5,5,5,-1,12,-1,12,5,-1,12,5,-1,1,8,-1,1,8,-1,1,8,-1,1,8,-1,-2,-3,-4,1,8,-1,1,-1,1,-1,-2,-3,12,41,42,10,10,10,10,10,10,10,10],[74,75,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,0,19,1,20,0,21,1,22,0,23,1,24,0,25,1,26,1,27,0,28,1,29,0,30,1,31,0,32,1,33,0,34,0,35,1,36,0,37,1,38,0,39,1,40,0,41,1,42,0,19,1,20,0,21,1,22,0,23,1,24,0,25,1,26,1,27,0,28,1,29,0,30,1,31,0,32,1,33,0,34,0,35,1,36,0,37,1,38,0,39,1,40,0,41,1,42,0,19,1,20,0,21,1,22,0,23,1,24,0,25,1,26,1,27,0,28,1,29,0,30,1,31,0,32,1,33,0,34,0,35,1,36,0,37,1,38,0,39,1,40,0,41,1,42,45,46,45,46,47,76,47,5,48,77,43,71,44,70,5,48,49,49,5,50,5,50,7,15,7,16,7,15,7,16,7,15,7,16,7,78,7,79,0,12,5,51,52,12,80,17,81,12,5,51,52,12,82,17,5,83,84,85,5,86,53,54,5,55,5,56,53,54,5,55,5,56,9,2,10,2,11,2,9,2,10,2,11,2,9,2,10,2,11,2,9,2,10,2,11,2,9,2,10,2,11,2,8,8,8,8,57,58,18,87,88,18,89,90,18,91,92,59,93,59,94,95,60,61,96,97,62,62,63,64,98,65,65,61,60,99,66,66,67,67,64,123,123,63,13,100,101,13,102,103,13,104,105,13,106,107,8,8,8,8,57,58,108,109,110,17,111,68,112,68,113,114,115,116,117,118,119,120,121,122]],[[[183,[[184,"ShadowFlow",[[185,"ShadowStage"]]],[186,"ForwardFlow",1,[[187,"ForwardStage",[[188,["default"]],[189,true,1,["default"]]]]]]]]],0,0,[],[],[]]]]
