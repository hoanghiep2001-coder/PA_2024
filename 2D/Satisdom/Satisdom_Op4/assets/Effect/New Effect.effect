// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.  

CCEffect %{
  techniques:
  - passes:
    - vert: vs
      frag: fs
      blendState:
        targets:
        - blend: true
      rasterizerState:
        cullMode: none
      properties:
        texture: { value: white }
        alphaThreshold: { value: 0.5 }
}%


CCProgram vs %{
  precision highp float;

  #include <cc-global>
  #include <cc-local>

  in vec3 a_position;
  in vec4 a_color;
  out vec4 v_color;

  #if USE_TEXTURE
  in vec2 a_uv0;
  out vec2 v_uv0;
  #endif

  void main () {
    vec4 pos = vec4(a_position, 1);

    #if CC_USE_MODEL
    pos = cc_matViewProj * cc_matWorld * pos;
    #else
    pos = cc_matViewProj * pos;
    #endif

    #if USE_TEXTURE
    v_uv0 = a_uv0;
    #endif

    v_color = a_color;

    gl_Position = pos;
  }
}%


CCProgram fs %{
  precision highp float;
  
  #include <alpha-test>
  #include <cc-global>
  #include <texture>

  in vec4 v_color;

  #if USE_TEXTURE
  in vec2 v_uv0;
  uniform sampler2D texture;
  #endif

  #define HASHSCALE 0.1031
  #define FADE_SCALE 30.0

  float hash(float p)
  {
    vec3 p3  = fract(vec3(p) * HASHSCALE);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
  }

  float fade(float t) { return t*t*t*(t*(6.*t-15.)+10.); }

  float grad(float hash, float p)
  {
      // int i = int();
      int m = int(mod(1e4*hash,2.0));
      if(m==0){
        return p;
      }else{
        return -p;
      }
    // return (i & 1) == 0 ? p : -p;
  }

  float perlinNoise1D(float p)
  {
    float pi = floor(p), pf = p - pi, w = fade(pf);
    return mix(grad(hash(pi), pf), grad(hash(pi + 1.0), pf - 1.0), w) * 2.0;
  }

  float fbm(float pos, int octaves, float persistence) 
  {
    float total = 0.;
    float frequency = 1.;
    float amplitude = 1.;
    float maxValue = 0.;
    const int MAX_FOR_NUM = 100;
    for(int i = 0; i < MAX_FOR_NUM; ++i) 
    {
      if(i>octaves) break;
      total += perlinNoise1D(pos * frequency) * amplitude;
      maxValue += amplitude;
      amplitude *= persistence;
      frequency *= 2.;
    }
    return total / maxValue;
  }

  // float Noise1(vec2 p) {
  //     return fract(sin(
  //         dot(p, vec2(12.9898,78.233))
  //     ) * 43758.5453123);
  // }

  vec4 renderLR(in vec2 uv)
  {
      float noise = .04 * (fbm(uv.x, 4, .1) + fbm(uv.x + cc_time.x, 4, .1));
      float d = (uv.y + noise + .24) * FADE_SCALE;
    float t = clamp(d, 0., 1.);
      
      vec3 skyColor = vec3(.0, .3, .3) - uv.y * .3;
      vec3 waterColor = vec3(.0, .1, .3) + .3 * uv.y;
      return vec4(mix(waterColor, skyColor, t), 1.);
  }

  void main () {
    vec4 o = vec4(1, 1, 1, 1);

    #if USE_TEXTURE
      CCTexture(texture, v_uv0, o);
    #endif

    o *= v_color;

    ALPHA_TEST(o);


    vec2 iResolution = vec2(500.0,500.0);
    // vec2 uv =  (2.*gl_FragCoord.xy-iResolution.xy)/iResolution.y*2.0;
    // vec2 uv = 2.0 * v_uv0 - 1.0;
    vec2 uv = 1.0 -2.0* v_uv0;

    gl_FragColor = renderLR(uv);
  }
}%

//shaderToy地址 https://www.shadertoy.com/view/lt3BWM