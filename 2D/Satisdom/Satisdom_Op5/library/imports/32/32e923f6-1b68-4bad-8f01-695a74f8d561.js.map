{"version":3,"sources":["packages\\neutrinoparticles\\runtime\\NeutrinoAssemblerWebGL.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["import NeutrinoComponent from './NeutrinoComponent';\r\n\r\nconst indices = [0, 1, 3, 1, 2, 3];\r\n\r\nexport default class NeutrinoAssembler extends cc.Assembler {\r\n    _initialized = false;\r\n    _currentVertex = 0;\r\n    _renderStyleIndex = null;\r\n    _vertexFormat = cc.gfx.VertexFormat.XYZ_UV_Color;\r\n    _buffer = null;\r\n    _bufferOffsetInfo = null;\r\n    _modelBatcher = null;\r\n    _worldScale = new cc.Vec3();\r\n\r\n    fillBuffers (comp, modelBatcher) {\r\n        if (!comp._neutrinoEffect || !comp.context.loaded()) {\r\n            return;\r\n        }\r\n\r\n        if (!this._initialized) {\r\n            this._buffer = modelBatcher.getBuffer('mesh', this._vertexFormat);\r\n            this._initialized = true;\r\n        }\r\n\r\n        this._modelBatcher = modelBatcher;\r\n        this._renderStyleIndex = null;\r\n        this._worldScale = comp._worldScale;\r\n        \r\n        comp._neutrinoEffect.fillGeometryBuffers([1, 0, 0], [0, 1, 0], [0, 0, -1]);\r\n    }\r\n\r\n    // Methods called by neutrinoEffect\r\n\r\n    initialize(maxNumVertices, texChannels, indices, maxNumRenderCalls) {\r\n    }\r\n\r\n    beforeQuad(renderStyleIndex) {\r\n        if (this._renderStyleIndex !== renderStyleIndex) {\r\n            const material = this._renderComp.materials[renderStyleIndex];\r\n            if (material) {\r\n                if (material.getHash() !== this._modelBatcher.material.getHash()) {\r\n                    this._modelBatcher._flush();\r\n                    this._modelBatcher.material = material;\r\n                }\r\n            }\r\n\r\n            this._renderStyleIndex = renderStyleIndex;\r\n        }\r\n        \r\n        this._bufferOffsetInfo = this._buffer.request(4, indices.length);\r\n    }\r\n\r\n    pushVertex(vertex) {\r\n        const oi = this._bufferOffsetInfo;\r\n        const floatsPerVertex = this._vertexFormat._bytes / 4;\r\n        const buffer = this._buffer;\r\n\r\n        const floatsBuffer = buffer._vData;\r\n        const uintsBuffer = buffer._uintVData;\r\n\r\n        const floatsStart = oi.byteOffset / 4 + this._currentVertex * floatsPerVertex;\r\n\r\n        const x = vertex.position[0] * this._worldScale.x;\r\n        const y = vertex.position[1] * this._worldScale.y;\r\n        const z = vertex.position[2] * this._worldScale.z;\r\n\r\n        floatsBuffer[floatsStart + 0] = x;\r\n        floatsBuffer[floatsStart + 1] = y;\r\n        floatsBuffer[floatsStart + 2] = z;\r\n\r\n        floatsBuffer[floatsStart + 3] = vertex.texCoords[0][0];\r\n        floatsBuffer[floatsStart + 4] = 1.0 - vertex.texCoords[0][1];\r\n\r\n        uintsBuffer[floatsStart + 5] = \r\n            (vertex.color[0]) |\r\n            (vertex.color[1] << 8) |\r\n            (vertex.color[2] << 16) |\r\n            (vertex.color[3] << 24);\r\n\r\n        ++this._currentVertex;\r\n\r\n        if (this._currentVertex == 4) {\r\n            const idicesBuffer = buffer._iData;\r\n\r\n            for (let i = 0; i < indices.length; ++i) {\r\n                idicesBuffer[oi.indiceOffset + i] = oi.vertexOffset + indices[i];\r\n            }\r\n\r\n            this._currentVertex = 0;\r\n        }\r\n    }\r\n\r\n    pushRenderCall(rc) {\r\n    }\r\n\r\n    cleanup() {\r\n    }\r\n}\r\n"]}