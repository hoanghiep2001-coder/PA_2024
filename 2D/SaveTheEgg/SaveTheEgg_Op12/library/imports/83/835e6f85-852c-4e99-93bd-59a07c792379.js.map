{"version":3,"sources":["assets\\Script\\Plugin\\Astar.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["import {Grid} from './Grid'\r\n \r\ninterface AStarNode {\r\n    x: number;\r\n    y: number;\r\n    g: number;\r\n    h: number;\r\n    f: number;\r\n    parent: AStarNode | null;\r\n}\r\n\r\nclass AStar {\r\n    private grid: Grid;\r\n\r\n    constructor(grid: Grid) {\r\n        this.grid = grid;\r\n    }\r\n\r\n    private heuristic(node: AStarNode, endNode: AStarNode): number {\r\n        return Math.abs(node.x - endNode.x) + Math.abs(node.y - endNode.y);\r\n    }\r\n\r\n    private getNeighbors(node: AStarNode): AStarNode[] {\r\n        const neighbors: AStarNode[] = [];\r\n        const directions = [\r\n            { x: -1, y: 0 }, // Trái\r\n            { x: 1, y: 0 },  // Phải\r\n            { x: 0, y: -1 }, // Trên\r\n            { x: 0, y: 1 },  // Dưới\r\n        ];\r\n\r\n        for (const direction of directions) {\r\n            const newX = node.x + direction.x;\r\n            const newY = node.y + direction.y;\r\n\r\n            if (this.grid.isWalkable(newX, newY)) {\r\n                neighbors.push({\r\n                    x: newX,\r\n                    y: newY,\r\n                    g: 0,\r\n                    h: 0,\r\n                    f: 0,\r\n                    parent: null,\r\n                });\r\n            }\r\n        }\r\n\r\n        return neighbors;\r\n    }\r\n\r\n    public findPath(startPos: { x: number, y: number }, endPos: { x: number, y: number }): AStarNode[] | null {\r\n        const startNode: AStarNode = {\r\n            x: startPos.x,\r\n            y: startPos.y,\r\n            g: 0,\r\n            h: 0,\r\n            f: 0,\r\n            parent: null,\r\n        };\r\n        const endNode: AStarNode = {\r\n            x: endPos.x,\r\n            y: endPos.y,\r\n            g: 0,\r\n            h: 0,\r\n            f: 0,\r\n            parent: null,\r\n        };\r\n\r\n        const openList: AStarNode[] = [];\r\n        const closedList: AStarNode[] = [];\r\n\r\n        openList.push(startNode);\r\n\r\n        while (openList.length > 0) {\r\n            let currentNode = openList.reduce((prev, curr) => (prev.f < curr.f ? prev : curr));\r\n\r\n            if (currentNode.x === endNode.x && currentNode.y === endNode.y) {\r\n                return this.reconstructPath(currentNode);\r\n            }\r\n\r\n            openList.splice(openList.indexOf(currentNode), 1);\r\n            closedList.push(currentNode);\r\n\r\n            const neighbors = this.getNeighbors(currentNode);\r\n\r\n            for (const neighbor of neighbors) {\r\n                if (closedList.find(n => n.x === neighbor.x && n.y === neighbor.y)) {\r\n                    continue;\r\n                }\r\n\r\n                const tentativeG = currentNode.g + 1;\r\n\r\n                let inOpenList = openList.find(n => n.x === neighbor.x && n.y === neighbor.y);\r\n                if (!inOpenList || tentativeG < neighbor.g) {\r\n                    neighbor.g = tentativeG;\r\n                    neighbor.h = this.heuristic(neighbor, endNode);\r\n                    neighbor.f = neighbor.g + neighbor.h;\r\n                    neighbor.parent = currentNode;\r\n\r\n                    if (!inOpenList) {\r\n                        openList.push(neighbor);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private reconstructPath(node: AStarNode): AStarNode[] {\r\n        const path: AStarNode[] = [];\r\n        let currentNode: AStarNode | null = node;\r\n\r\n        while (currentNode) {\r\n            path.push(currentNode);\r\n            currentNode = currentNode.parent;\r\n        }\r\n\r\n        return path.reverse();\r\n    }\r\n}\r\n\r\nexport default AStar;\r\n"]}